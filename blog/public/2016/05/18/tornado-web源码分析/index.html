<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Tornado.web源码分析 | 菊香书屋</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Tornado.web源码分析</h1><a id="logo" href="/.">菊香书屋</a><p class="description">文字是思想的载体</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/"><i class="fa fa-book"> 书单</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Tornado.web源码分析</h1><div class="post-meta">May 18, 2016<span> | </span><span class="category"><a href="/categories/Tornado系列/">Tornado系列</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#torndao-web-Application"><span class="toc-number">1.</span> <span class="toc-text">torndao.web.Application</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Application类的方法和工作原理简单介绍"><span class="toc-number">1.1.</span> <span class="toc-text">Application类的方法和工作原理简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#def-init"><span class="toc-number">1.2.</span> <span class="toc-text">def init()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#def-listen"><span class="toc-number">1.3.</span> <span class="toc-text">def listen()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码"><span class="toc-number">1.3.1.</span> <span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#def-add-handlers"><span class="toc-number">1.4.</span> <span class="toc-text">def add_handlers()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#def-add-transform"><span class="toc-number">1.5.</span> <span class="toc-text">def add_transform()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#def-call-备注：前后双下划线，下同"><span class="toc-number">1.6.</span> <span class="toc-text">def call()(备注：前后双下划线，下同)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Application对request的处理过程"><span class="toc-number">1.6.1.</span> <span class="toc-text">Application对request的处理过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#torndao-web-RequestHandler"><span class="toc-number">2.</span> <span class="toc-text">torndao.web.RequestHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#execute方法"><span class="toc-number">2.1.</span> <span class="toc-text">_execute方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数原型："><span class="toc-number">2.1.1.</span> <span class="toc-text">函数原型：</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>torndao.web是Handler类的集合，tornado的web框架是在web.py中实现的，tornado.web模块中提供了两个重量级的类，Application和RequestHandler（本质是http请求处理的封装）类。Application类主要是做路由转发，torndao使用web.Application做URI，然后在通过RequestHandler类去处理这些请求。</p>
<a id="more"></a>
<h1 id="torndao-web-Application"><a href="#torndao-web-Application" class="headerlink" title="torndao.web.Application"></a>torndao.web.Application</h1><p>Application官网解释说它是一系列网络请求的Handler，这些Handler的组合撑起了一个web网站。</p>
<p>torndao.web.Application提供的函数：<br><img src="tornado-web源码分析/torndao_001.PNG" alt="torndao.web.Application提供的函数"></p>
<h2 id="Application类的方法和工作原理简单介绍"><a href="#Application类的方法和工作原理简单介绍" class="headerlink" title="Application类的方法和工作原理简单介绍"></a>Application类的方法和工作原理简单介绍</h2><ul>
<li>构造函数：接受handlers参数，也是最终匹配主机的路径路由列表；设定transform列表；设定静态文件的路由；添加(“.*$”)的路由列表。</li>
<li>listen方法：创建server，并把自身，self作为回调函数</li>
<li>accept到新连接后主动调（<strong>call</strong>），其根据请求，把该请求转发到相应的路由路径表中具体的handler上去处理请求</li>
</ul>
<h2 id="def-init"><a href="#def-init" class="headerlink" title="def init()"></a><strong>def <strong>init</strong>()</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, transforms=None,</span></span></div><div class="line">        **settings):</div></pre></td></tr></table></figure>
<p>参数解析：</p>
<ul>
<li><p><strong>handlers：</strong>类型为list，一系列的URI的处理器列表，为对应的每个URI与handlers处理器的map，类似[(URI,handler_1),(URI_01,handler_1),…..]，当然还可以带一系列参数，比如static_path等:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">application = web.Application([</div><div class="line">(<span class="string">r"/static/(.*)"</span>, web.StaticFileHandler, &#123;<span class="string">"path"</span>: <span class="string">"/var/www"</span>&#125;),</div><div class="line">])</div></pre></td></tr></table></figure>
</li>
<li><p><strong>default_host:</strong></p>
</li>
<li><strong>transforms：</strong>分块、压缩等</li>
<li><strong>settings：</strong>各种设置，如static、gzip、cookie_secret等等，是一个dict</li>
</ul>
<p>Application类的初始化函数，将传入的处理器列表调用add_handlers函数注册，再有一些分块、压缩、UI、静态文件处理器的初始化，并调用add_handlers 方法，完成URI和处理器的映射关系，这个函数我们下面将会详细的介绍这个函数。</p>
<h2 id="def-listen"><a href="#def-listen" class="headerlink" title="def listen()"></a><strong>def listen()</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>, **kwargs)</span>:</span></div></pre></td></tr></table></figure>
<p>这个函数只是对HTTPServer的listen函数的一个封装，返回一个HTTPServer实例。在HTTPServer类中将仔细分析该函数。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">from</span> tornado.httpserver <span class="keyword">import</span> HTTPServer</div><div class="line">    <span class="comment">#简单的封装</span></div><div class="line">    server = HTTPServer(self, **kwargs) <span class="comment">#当连接到来后，HTTPServer负责调用</span></div><div class="line">    server.listen(port, address)</div><div class="line">    <span class="keyword">return</span> server</div></pre></td></tr></table></figure>
<p><strong>这里我们可以认为，在特定的地址-端口上创建并监听socket，并注册socket的可读事件到自身的call（前后双下划线，下同）方法上，即每逢一个新连接到来后，call将被调用。</strong></p>
<h2 id="def-add-handlers"><a href="#def-add-handlers" class="headerlink" title="def add_handlers()"></a><strong>def add_handlers()</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handlers</span><span class="params">(self, host_pattern, host_handlers)</span></span></div></pre></td></tr></table></figure>
<p>参数解析：</p>
<ul>
<li><strong>host_pattern：</strong>主机名正则</li>
<li><strong>host_handlers:</strong>路由表和handler，即路径路由列表。如：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">application = web.Application([</div><div class="line">    (<span class="string">r"/static/(.*)"</span>, web.StaticFileHandler, &#123;<span class="string">"path"</span>: <span class="string">"/var/www"</span>&#125;),</div><div class="line">])</div></pre></td></tr></table></figure>
</li>
</ul>
<p>添加路由与handlers的到处理器列表中，完成URI和处理器的映射。</p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handlers</span><span class="params">(self, host_pattern, host_handlers)</span>:</span></div><div class="line">    <span class="comment">#若无正则表达式的结束符，则添加</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> host_pattern.endswith(<span class="string">"$"</span>):</div><div class="line">        host_pattern += <span class="string">"$"</span></div><div class="line">    handlers = []</div><div class="line"></div><div class="line">    <span class="comment">#self.handlesr是一个主机和路由列表，每个元素是一个tuple，</span></div><div class="line">    <span class="comment">#将主机名和路径路由列表合成tuple，添加到self.handlers中，供_get_host_handler()检索，</span></div><div class="line">    <span class="comment">#可以根据主机名找到路径路由列表</span></div><div class="line">    <span class="keyword">if</span> self.handlers <span class="keyword">and</span> self.handlers[<span class="number">-1</span>][<span class="number">0</span>].pattern == <span class="string">'.*$'</span>: <span class="comment">#由于'.*$'的特殊性，必须放在列表的最后</span></div><div class="line">        self.handlers.insert(<span class="number">-1</span>, (re.compile(host_pattern), handlers))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        self.handlers.append((re.compile(host_pattern), handlers))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> spec <span class="keyword">in</span> host_handlers:</div><div class="line">        <span class="keyword">if</span> isinstance(spec, (tuple, list)):</div><div class="line">            <span class="keyword">assert</span> len(spec) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">            spec = URLSpec(*spec)</div><div class="line">        <span class="comment">#添加到处理器列表中</span></div><div class="line">        handlers.append(spec)</div><div class="line">        <span class="keyword">if</span> spec.name:</div><div class="line">            <span class="keyword">if</span> spec.name <span class="keyword">in</span> self.named_handlers:</div><div class="line">                app_log.warning(</div><div class="line">                    <span class="string">"Multiple handlers named %s; replacing previous value"</span>,</div><div class="line">                    spec.name)</div><div class="line">            self.named_handlers[spec.name] = spec</div></pre></td></tr></table></figure>
<p>我们看这个函数函数还是很简单的，就是把URI和handler添加到处理器列表中，完成映射map，完事。</p>
<h2 id="def-add-transform"><a href="#def-add-transform" class="headerlink" title="def add_transform()"></a><strong>def add_transform()</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_transform</span><span class="params">(self, transform_class)</span>:</span></div></pre></td></tr></table></figure>
<p>这个函数及其简单，完成的任务就是添加输出过滤器，例如gzip，chunk，会在输出的时候调用其。</p>
<h2 id="def-call-备注：前后双下划线，下同"><a href="#def-call-备注：前后双下划线，下同" class="headerlink" title="def call()(备注：前后双下划线，下同)"></a>def <strong>call</strong>()(备注：前后双下划线，下同)</h2><p>这个函数可以说是Application的主要核心方法之一，我们详细的来看看。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></div><div class="line">    <span class="comment">#传统的HTTP服务器接口</span></div><div class="line">    dispatcher = _RequestDispatcher(self, <span class="keyword">None</span>)<span class="comment">#传进去的是self参数</span></div><div class="line">    dispatcher.set_request(request)</div><div class="line">    <span class="keyword">return</span> dispatcher.execute()</div></pre></td></tr></table></figure>
<p>参数解析：</p>
<ul>
<li><strong>request:</strong>HttpRequest对象对象，定义在httputil中。</li>
</ul>
<p>这个函数实现的挺有技巧性，实现了一个<strong>call</strong>函数，这个函数有什么作用呢，就是类Application可以当做函数来调用了。<br>Application类可以这么理解它自身的一些函数的关系：<br>在特定的地址-端口上创建并监听该socket，并且注册了该sockt的可读事件到自身的<strong>call</strong>函数。</p>
<p><strong><strong>call</strong>函数的好处</strong></p>
<ul>
<li>Application类的对象可以当做函数来调用。</li>
<li>当类对象当做函数来调用的时候，<strong>call</strong>会自动被调用，并且会保留对象的上下文。</li>
</ul>
<p>我们在tornado版的hello world前面的举例中，会发现当时是这么调用的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">application = tornado.web.Application([</div><div class="line">    (<span class="string">r"/"</span>, MainHandler),</div><div class="line">])</div><div class="line">http_server = tornado.httpserver.HTTPServer(application)</div><div class="line">http_server.listen(options.port)</div><div class="line">tornado.ioloop.IOLoop.current().start()</div></pre></td></tr></table></figure></p>
<p>上述举例可以看出，<strong>我们将Application实例传给了HTTPServer，当监听到（listen()函数）请求的，由于Application类实现了<strong>call</strong>函数,所以当请求到来后，通过HTTPServer来调用Application实例，<strong>call</strong>方法中完成具体的URI转发工作，即，<strong>call</strong>函数会遍历Application的handlers列表，匹配到相应的URL的handler后，通过handler._execute进行相应处理；如果没有匹配的URL，则会调用ErrorHandler。</strong></p>
<p>由上面的<strong>call</strong>函数我们看到，此方法主要是调用_RequestDispatcher来完成请求的处理，那么下面我们具体看看请求到来后的处理过程：</p>
<h3 id="Application对request的处理过程"><a href="#Application对request的处理过程" class="headerlink" title="Application对request的处理过程"></a><strong>Application对request的处理过程</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_has_stream_request_body</span><span class="params">(cls)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> issubclass(cls, RequestHandler):</div><div class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"expected subclass of RequestHandler, got %r"</span>, cls)</div><div class="line">    <span class="keyword">return</span> getattr(cls, <span class="string">'_stream_request_body'</span>, <span class="keyword">False</span>)</div><div class="line"></div><div class="line"><span class="comment">#Application类的方法</span></div><div class="line"><span class="comment">#Application类的构造函数有这么一段代码：</span></div><div class="line"><span class="string">"""</span></div><div class="line">if handlers:</div><div class="line">    self.add_handlers(".*$", handlers)#host_pattern传入".*$",表示无限次的匹配，即默认情况下，所有的主机名都会被匹配</div><div class="line">"""</div><div class="line"><span class="comment">#所以显然，默认情况下，任何host都会被匹配的，</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_host_handlers</span><span class="params">(self, request)</span>:</span></div><div class="line">    host = split_host_and_port(request.host.lower())[<span class="number">0</span>]</div><div class="line">    matches = []</div><div class="line">    <span class="keyword">for</span> pattern, handlers <span class="keyword">in</span> self.handlers:</div><div class="line">        <span class="keyword">if</span> pattern.match(host):</div><div class="line">            matches.extend(handlers)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matches <span class="keyword">and</span> <span class="string">"X-Real-Ip"</span> <span class="keyword">not</span> <span class="keyword">in</span> request.headers:</div><div class="line">        <span class="keyword">for</span> pattern, handlers <span class="keyword">in</span> self.handlers:</div><div class="line">            <span class="keyword">if</span> pattern.match(self.default_host):</div><div class="line">                matches.extend(handlers)</div><div class="line">    <span class="keyword">return</span> matches <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RequestDispatcher</span><span class="params">(httputil.HTTPMessageDelegate)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, application, connection)</span>:</span></div><div class="line">        self.application = application</div><div class="line">        self.connection = connection</div><div class="line">        self.request = <span class="keyword">None</span></div><div class="line">        self.chunks = []</div><div class="line">        self.handler_class = <span class="keyword">None</span></div><div class="line">        self.handler_kwargs = <span class="keyword">None</span></div><div class="line">        self.path_args = []</div><div class="line">        self.path_kwargs = &#123;&#125;</div><div class="line"></div><div class="line">    .....</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_request</span><span class="params">(self, request)</span>:</span></div><div class="line">        self.request = request</div><div class="line">        self._find_handler()</div><div class="line">        self.stream_request_body = _has_stream_request_body(self.handler_class)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_find_handler</span><span class="params">(self)</span>:</span></div><div class="line">        app = self.application</div><div class="line">        <span class="comment">#该函数将得到该host对应的路径路由列表，也就是那个映射map，</span></div><div class="line">        <span class="comment">#也就是说返回的列表就是传递给构造Application的那个tuple列表</span></div><div class="line">        handlers = app._get_host_handlers(self.request)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> handlers:</div><div class="line">            self.handler_class = RedirectHandler</div><div class="line">            self.handler_kwargs = dict(url=<span class="string">"%s://%s/"</span></div><div class="line">                                       % (self.request.protocol,</div><div class="line">                                          app.default_host))</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment">#handler得到类似：[URLSpec('/$', &lt;class '__main__.IndexHandler'&gt;, kwargs=&#123;&#125;, name=None), URLSpec('/poem$', &lt;class '__main__.PoemPageHandler'&gt;, kwargs=&#123;&#125;, name=None)]的返回值，就是对应的路径路由列表</span></div><div class="line">        <span class="keyword">for</span> spec <span class="keyword">in</span> handlers:</div><div class="line">            <span class="comment">#对于路由表中的每个对象用request.path匹配，根据请求URL路径匹配Handler</span></div><div class="line">            match = spec.regex.match(self.request.path)</div><div class="line">            <span class="comment">#匹配到路径后，生成RequstHandler对象，取得URL路径参数，跳出循环</span></div><div class="line">            <span class="keyword">if</span> match:</div><div class="line">                <span class="comment">#实例化，生成RequstHandler对象，即调用此类的构造函数</span></div><div class="line">                self.handler_class = spec.handler_class</div><div class="line">                self.handler_kwargs = spec.kwargs</div><div class="line">                <span class="comment">#根据path路径，得到请求的URL的参数</span></div><div class="line">                <span class="keyword">if</span> spec.regex.groups:</div><div class="line">                    <span class="comment">#字符串做key的正则表</span></div><div class="line">                    <span class="keyword">if</span> spec.regex.groupindex:</div><div class="line">                        self.path_kwargs = dict(</div><div class="line">                            (str(k), _unquote_or_none(v))</div><div class="line">                            <span class="keyword">for</span> (k, v) <span class="keyword">in</span> match.groupdict().items())</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="comment">#数字做key正则表</span></div><div class="line">                        self.path_args = [_unquote_or_none(s)</div><div class="line">                                          <span class="keyword">for</span> s <span class="keyword">in</span> match.groups()]</div><div class="line">                <span class="keyword">return</span></div><div class="line">        <span class="comment">#若没匹配的到，如果有默认的handler，则使用</span></div><div class="line">        <span class="keyword">if</span> app.settings.get(<span class="string">'default_handler_class'</span>):</div><div class="line">            self.handler_class = app.settings[<span class="string">'default_handler_class'</span>]</div><div class="line">            self.handler_kwargs = app.settings.get(</div><div class="line">                <span class="string">'default_handler_args'</span>, &#123;&#125;)</div><div class="line">        <span class="comment">#否则返回404</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.handler_class = ErrorHandler</div><div class="line">            self.handler_kwargs = dict(status_code=<span class="number">404</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.application.settings.get(<span class="string">"compiled_template_cache"</span>, <span class="keyword">True</span>):</div><div class="line">            <span class="keyword">with</span> RequestHandler._template_loader_lock:</div><div class="line">                <span class="keyword">for</span> loader <span class="keyword">in</span> RequestHandler._template_loaders.values():</div><div class="line">                    loader.reset()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.application.settings.get(<span class="string">'static_hash_cache'</span>, <span class="keyword">True</span>):</div><div class="line">            StaticFileHandler.reset()</div><div class="line"></div><div class="line">        self.handler = self.handler_class(self.application, self.request,</div><div class="line">                                          **self.handler_kwargs)</div><div class="line">        transforms = [t(self.request) <span class="keyword">for</span> t <span class="keyword">in</span> self.application.transforms]</div><div class="line"></div><div class="line">        <span class="keyword">if</span> self.stream_request_body:</div><div class="line">            self.handler._prepared_future = Future()</div><div class="line"></div><div class="line">        <span class="comment">#调用已注册的处理器的_execute方法，处理请求。</span></div><div class="line">        self.handler._execute(transforms, *self.path_args,</div><div class="line">                              **self.path_kwargs)</div><div class="line">        <span class="keyword">return</span> self.handler._prepared_future</div></pre></td></tr></table></figure>
<h1 id="torndao-web-RequestHandler"><a href="#torndao-web-RequestHandler" class="headerlink" title="torndao.web.RequestHandler"></a>torndao.web.RequestHandler</h1><p>RequestHandler就是具体处理请求的类。这个类非常重要，RequestHandler中涉及到很多HTTP相关的技术，包括 Header、Status、Cookie、Etag、Content-Type、链接参数、重定向、长连接等等，还有和用户身份相关的XSRF和CSRF等等。</p>
<p>在上面介绍Application中可以看到，Application通过调用RequestHandler类的方法_execute来完成调度，那么_execute显然就是真正干活的地方，我们就重点看这个函数。这个类中还包含了很多很实用的方法，具体在应用的时候可以看看。</p>
<h2 id="execute方法"><a href="#execute方法" class="headerlink" title="_execute方法"></a>_execute方法</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self, transforms, *args, **kwargs)</span>:</span></div></pre></td></tr></table></figure>
<p>参数解析：</p>
<ul>
<li><strong>transforms:</strong>相当于Application的中间件<br>-</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self, transforms, *args, **kwargs)</span>:</span></div><div class="line">    self._transforms = transforms</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">if</span> self.request.method <span class="keyword">not</span> <span class="keyword">in</span> self.SUPPORTED_METHODS:</div><div class="line">            <span class="keyword">raise</span> HTTPError(<span class="number">405</span>)</div><div class="line">        self.path_args = [self.decode_argument(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args]</div><div class="line">        self.path_kwargs = dict((k, self.decode_argument(v, name=k))</div><div class="line">                                <span class="keyword">for</span> (k, v) <span class="keyword">in</span> kwargs.items())</div><div class="line">        <span class="keyword">if</span> self.request.method <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"OPTIONS"</span>) <span class="keyword">and</span> \</div><div class="line">                self.application.settings.get(<span class="string">"xsrf_cookies"</span>):</div><div class="line">            self.check_xsrf_cookie()</div><div class="line"></div><div class="line">        result = self.prepare()</div><div class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            result = <span class="keyword">yield</span> result</div><div class="line">        <span class="keyword">if</span> self._prepared_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            self._prepared_future.set_result(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> self._finished:</div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> _has_stream_request_body(self.__class__):</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="keyword">yield</span> self.request.body</div><div class="line">            <span class="keyword">except</span> iostream.StreamClosedError:</div><div class="line">                <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="comment">#调handler的具体业务逻辑处理，在子类的get/post/put/delete 方法中处理，这里就是真正调Handler的post、get等方法的地方</span></div><div class="line">        method = getattr(self, self.request.method.lower())</div><div class="line">        result = method(*self.path_args, **self.path_kwargs)</div><div class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            result = <span class="keyword">yield</span> result</div><div class="line">        <span class="comment">#self.finish函数做一些善后事宜，比如释放缓冲区，关闭连接等</span></div><div class="line">        <span class="keyword">if</span> self._auto_finish <span class="keyword">and</span> <span class="keyword">not</span> self._finished:</div><div class="line">            self.finish()</div><div class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self._handle_request_exception(e)</div><div class="line">        <span class="keyword">except</span> Exception:</div><div class="line">            app_log.error(<span class="string">"Exception in exception handler"</span>, exc_info=<span class="keyword">True</span>)</div><div class="line">        <span class="keyword">if</span> (self._prepared_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span></div><div class="line">                <span class="keyword">not</span> self._prepared_future.done()):</div><div class="line">            self._prepared_future.set_result(<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/18/tornado-web源码分析/" data-id="citoiroo6000eta02solcpsz1" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Tornado源码分析/">Tornado源码分析</a></div><div class="post-nav"><a href="/2016/05/13/聊聊tornado源码之前奏曲-深入了解handler/" class="next">Tornado源码之handler</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python之聚石塔/">Python之聚石塔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tornado系列/">Tornado系列</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Python基础/" style="font-size: 15px;">Python基础</a> <a href="/tags/Python命令行解析/" style="font-size: 15px;">Python命令行解析</a> <a href="/tags/Tornado源码分析/" style="font-size: 15px;">Tornado源码分析</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/18/tornado-web源码分析/">Tornado.web源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/13/聊聊tornado源码之前奏曲-深入了解handler/">Tornado源码之handler</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/11/Tornado之web服务器的网络知识了解/">Tornado之web服务器的网络知识了解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/09/Tornado的HTTP-Server的服务模型/">Tornado的HTTP Server的服务模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/08/聊聊tornado源码之鸟瞰tornado框架/">鸟瞰Tornado框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/04/tornado源码剖析系列文章目录/">Tornado源码剖析系列文章目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/04/Tornado的简历/">Tornado的简历</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/19/Python命令行解析详解/">Python命令行解析详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/17/Python葵花宝典/">Python葵花宝典</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/LingYue/LingYue.github.io" title="翎月的github" target="_blank">翎月的github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">菊香书屋.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>