<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Python葵花宝典 | 菊香书屋</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python葵花宝典</h1><a id="logo" href="/.">菊香书屋</a><p class="description">文字是思想的载体</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/"><i class="fa fa-book"> 书单</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python葵花宝典</h1><div class="post-meta">Apr 17, 2016<span> | </span><span class="category"><a href="/categories/Python之聚石塔/">Python之聚石塔</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类"><span class="toc-number">1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是类？类的特点是什么？"><span class="toc-number">1.1.</span> <span class="toc-text">什么是类？类的特点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是元类？元类的特点是什么？-解释元类个人认为最好的文章链接"><span class="toc-number">1.2.</span> <span class="toc-text">什么是元类？元类的特点是什么？ 解释元类个人认为最好的文章链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#“metaclass“属性是什么？这个属性有什么作用？"><span class="toc-number">1.3.</span> <span class="toc-text">“metaclass“属性是什么？这个属性有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数传递说明"><span class="toc-number">2.1.</span> <span class="toc-text">函数参数传递说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#传递参数带星号"><span class="toc-number">2.1.1.</span> <span class="toc-text">传递参数带星号(*)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python的编码、乱码问题"><span class="toc-number">3.</span> <span class="toc-text">Python的编码、乱码问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么产生编码问题？"><span class="toc-number">3.1.</span> <span class="toc-text">为什么产生编码问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unicode、UTF-8"><span class="toc-number">3.2.</span> <span class="toc-text">unicode、UTF-8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码、解码"><span class="toc-number">3.3.</span> <span class="toc-text">编码、解码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解码（decode）："><span class="toc-number">3.3.1.</span> <span class="toc-text">解码（decode）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码（encode）"><span class="toc-number">3.3.2.</span> <span class="toc-text">编码（encode）:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码问题常见异常总结："><span class="toc-number">3.3.3.</span> <span class="toc-text">编码问题常见异常总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码问题常见处理方法总结："><span class="toc-number">3.3.4.</span> <span class="toc-text">编码问题常见处理方法总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python的call（前后双下划线-函数"><span class="toc-number">4.</span> <span class="toc-text">Python的call（前后双下划线) 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#举例"><span class="toc-number">4.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call函数总结"><span class="toc-number">4.2.</span> <span class="toc-text">call函数总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#识别编码的方法"><span class="toc-number">5.</span> <span class="toc-text">识别编码的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#识别编码库chardet库"><span class="toc-number">5.1.</span> <span class="toc-text">识别编码库chardet库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于print"><span class="toc-number">6.</span> <span class="toc-text">关于print</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#print输出文本中的中文"><span class="toc-number">6.1.</span> <span class="toc-text">print输出文本中的中文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#print的工作原理"><span class="toc-number">6.2.</span> <span class="toc-text">print的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#print会干什么？"><span class="toc-number">6.2.1.</span> <span class="toc-text">print会干什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类文件对象是什么？有什么特点？"><span class="toc-number">6.2.2.</span> <span class="toc-text">类文件对象是什么？有什么特点？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#super-内建函数"><span class="toc-number">7.</span> <span class="toc-text">super()内建函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#经典类怎么初始化继承类？"><span class="toc-number">7.1.</span> <span class="toc-text">经典类怎么初始化继承类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新式类的super"><span class="toc-number">7.2.</span> <span class="toc-text">新式类的super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super到底干了什么工作？"><span class="toc-number">7.3.</span> <span class="toc-text">super到底干了什么工作？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sorted排序"><span class="toc-number">8.</span> <span class="toc-text">sorted排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sorted函数："><span class="toc-number">8.1.</span> <span class="toc-text">sorted函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted原型和参数"><span class="toc-number">8.1.1.</span> <span class="toc-text">sorted原型和参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted和sort的区别"><span class="toc-number">8.1.2.</span> <span class="toc-text">sorted和sort的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sorted函数使用方法详解"><span class="toc-number">8.2.</span> <span class="toc-text">sorted函数使用方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字典排序"><span class="toc-number">8.2.1.</span> <span class="toc-text">字典排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#with上下文管理器"><span class="toc-number">9.</span> <span class="toc-text">with上下文管理器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取脚本的执行路径问题"><span class="toc-number">10.</span> <span class="toc-text">获取脚本的执行路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主执行文件，获取执行脚本路径"><span class="toc-number">10.1.</span> <span class="toc-text">主执行文件，获取执行脚本路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非主执行文件，import其他文件，获取执行脚本路径"><span class="toc-number">10.2.</span> <span class="toc-text">非主执行文件，import其他文件，获取执行脚本路径</span></a></li></ol></li></ol></div></div><div class="post-content"><p>基础经济决定上层建筑，扎实的基础知识是优秀工程师的基石，本文记录一些零碎的Python的基础知识。</p>
<blockquote>
<ul>
<li>类、元类</li>
<li>函数</li>
<li>Python的编码、乱码问题</li>
<li>Python的<strong>call</strong>（前后双下划线）函数</li>
<li>识别编码的办法</li>
<li>super函数</li>
<li>os模块的文件对象操作部分</li>
<li>文件对象的读写</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="什么是类？类的特点是什么？"><a href="#什么是类？类的特点是什么？" class="headerlink" title="什么是类？类的特点是什么？"></a><strong>什么是类？类的特点是什么？</strong></h2><ul>
<li><strong>类：</strong> 类就是一组用来描述描述如何生成对象的代码段。<strong>类就是能创建出类实例的对象。</strong></li>
<li><p><strong>类的特点：</strong>Python中的类也是对象，只要使用关键字<strong>class</strong>，Python的解释器执行的时候就会在内存中创建一个对象，对象名就是类名。<strong>这个对象（类）自身拥有创建对象（类实例）的能力</strong>，这就是为什么称这个对象为类的原因。但是Python中的类本质上还是一个对象，所以Python中类可以：</p>
<ul>
<li>将类赋给一个变量</li>
<li>可以拷贝类</li>
<li>可以为他增加属性</li>
<li>可以把类作为函数参数去传递</li>
<li>类是对象，因此可以动态的去创建类</li>
<li>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line">Foo.new_aut = <span class="string">'lingyue'</span></div><div class="line">foo = Foo()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myClass</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">return</span> Foo</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">return</span> Bar</div><div class="line">s = myClass(<span class="string">'foo'</span>)</div><div class="line">x = myClass(<span class="string">'bar'</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类既然也是对象，那么这个类对象是谁创建的呢？</p>
<ul>
<li>创建类的<strong>元类</strong>。<h2 id="什么是元类？元类的特点是什么？-解释元类个人认为最好的文章链接"><a href="#什么是元类？元类的特点是什么？-解释元类个人认为最好的文章链接" class="headerlink" title="什么是元类？元类的特点是什么？ 解释元类个人认为最好的文章链接"></a><strong>什么是元类？元类的特点是什么？</strong> <a href="http://blog.jobbole.com/21351/" target="_blank" rel="external">解释元类个人认为最好的文章链接</a></h2></li>
</ul>
</li>
<li><p><strong>元类：</strong>元类就是创建类（对象）的“东西”，即<strong>元类就是类的类，可以理解为元类就是类工厂</strong>。<br>记录开始</p>
</li>
</ul>
<h2 id="“metaclass“属性是什么？这个属性有什么作用？"><a href="#“metaclass“属性是什么？这个属性有什么作用？" class="headerlink" title="“metaclass“属性是什么？这个属性有什么作用？"></a><strong>“<strong>metaclass</strong>“属性是什么？这个属性有什么作用？</strong></h2><ul>
<li><strong>“<strong>metaclass</strong>“</strong>属性的怎么用？</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数参数传递说明"><a href="#函数参数传递说明" class="headerlink" title="函数参数传递说明"></a>函数参数传递说明</h2><h3 id="传递参数带星号"><a href="#传递参数带星号" class="headerlink" title="传递参数带星号(*)"></a>传递参数带星号<strong>(*)</strong></h3><p>在传递不确定个数的参数的时候，我们可能会使用（<em>args，*</em>kwargs）来传递，那么使用星号和不使用星号去给函数传递参数有什么区别？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> args</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> args[<span class="number">0</span>]</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="string">'lingyue'</span>,<span class="string">'jiangtao'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>func(a)</div><div class="line">((<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>),)</div><div class="line">(<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>)</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>func(*a)</div><div class="line">(<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>)</div><div class="line">lingyue</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="string">'lingyue'</span>,<span class="string">'jiangtao'</span>)</div><div class="line">(<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>)</div><div class="line">lingyue</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>上面举例可以看出，当不使用星号给函数传递参数的时候，你是怎么传递的，那么函数接受到的参数就是什么样子的，比如上例子中的<strong>func(a)</strong>，传递进来后，函数接受到的就是你所传递的参数，例子中使用的是元组的方式去传递的；那么你用list做参数，函数还是会把参数作为元组去处理，就是说*args永远接受到的是一个元组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>func([<span class="string">'lingyue'</span>,<span class="string">'jiangtao'</span>])</div><div class="line">([<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>],)</div><div class="line">[<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>func(*[<span class="string">'lingyue'</span>,<span class="string">'jiangtao'</span>])</div><div class="line">(<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>)</div><div class="line">lingyue</div></pre></td></tr></table></figure></p>
<p>那么当我们使用引用传参<strong>(func(*a))</strong>的时候，会发生什么呢？<br>由上面的例子可以看到，使用引用传参的时候，函数解析器实际会把元组给解包，解析成len（a）个参数，它会把你传进去的参数解包成一个元组，而不是原封不动的接受。<br>所以：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>func(*a)</div><div class="line">(<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>)</div><div class="line">lingyue</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="string">'lingyue'</span>,<span class="string">'jiangtao'</span>)<span class="comment">#表示传递两个参数</span></div><div class="line">(<span class="string">'lingyue'</span>, <span class="string">'jiangtao'</span>)</div><div class="line">lingyue</div></pre></td></tr></table></figure></p>
<h1 id="Python的编码、乱码问题"><a href="#Python的编码、乱码问题" class="headerlink" title="Python的编码、乱码问题"></a>Python的编码、乱码问题</h1><h2 id="为什么产生编码问题？"><a href="#为什么产生编码问题？" class="headerlink" title="为什么产生编码问题？"></a>为什么产生编码问题？</h2><p>计算机只能处理01编码，如果要处理非数字的数据结构，只能把其他数据结构转化为01编码，计算机才能处理。美国人在最初发明计算机的时候就把自己的一些字母，如a,b,A,D,以及一些特殊字符、数字等编码到计算机中，一共是127个字母被编译进去。<strong>这个编码就是ASCII编码，</strong>比如大写的A是65等。但是当计算机传入中国的时候，中国语言博大精深，<em>（计算机在设计时采用8个比特（bit）作为一个字节（byte）</em>，一个字节要处理中文显然是不够的，而且还不能与ASCII编码重复，至少需要两个字节才能处理一个汉字。所以，中国人就制作了中文的编码方式，就GB2312编码，把中文编译进去。<br>那么，世界上有形形色色的语言，各国可能都有自己的语言，比如日文、韩文、法文等，各国都有自己的标准，这怎么通信，就比如货币如果没有比率做等价交换，各国就无法通币了，显然没有一个标准就会有各种冲突。于是乎，unicode就产生了。unicode就是一个各国编码的一个通用的桥梁，好比现在美元就是世界通用的货币，英语就是世界通用的语言，<em>（谁让美国佬强大呢，再过几十年，世界通用标准说不定就中国了）</em>。有了unicode这个通用编码标准，世界任何国家就可以通过这个编码进行转化，进而进行交流。<br><strong>以上就是编码问题的由来和解决办法的知识的简单普及。</strong></p>
<h2 id="unicode、UTF-8"><a href="#unicode、UTF-8" class="headerlink" title="unicode、UTF-8"></a>unicode、UTF-8</h2><p>我们知道unicode就是一个通用的编码标准了，有了unicode，所有的乱码问题，语言不通问题就解决了。<br>但是这就万事大吉了？No，上面我们介绍了，如果只是英语，也就是字符串，ASCII是够用的，美国人就是这么用的，只不过，中文博大精深，需要更多的编码字节罢了，至少需要两个字节。我们中国人自古以来，勤俭节约，计算机中什么最珍贵？肯定是CPU和内存嘛，那么问题来了，有个学渣，语文课不好好上，写篇作文，由于大多数汉字学了后都还给老师了，此贼通篇文章绝大多数都是拼音替代，也就是字符串，只有个别是汉字。<br>此时如果你都用2个或者以上的字节去编码，显然不在信息存储上、信息传输上不合算呐，大多数比特位都是填充的0，要是你真这么编码，老师一定骂你是败家子了。<br>此时聪明的中国人就想办法了，出现<strong>UTF-8</strong>编码，<strong>所谓的UTF-8编码就是一种可变长度的unicode编码，</strong><br>UTF-8编码把一个unicode字符根据不同的数字大小编码成1-6个字节，比如字符就用1个字节，简单中文就用2-3个字节，只有很生僻的字符才会被编码成4-6个字节，此时如果你把有大量字符中夹杂少量汉字的作文传输给老师的时候，就能节省不少的空间，存储和传输都节省不少呢。</p>
<p>注意：<br>通常python的文件的开头会这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure></p>
<p>第一行是遥告诉Linux系统，这是一个Python的可执行程序，window会忽略这行。<br>第二行注释是为了告诉Python解释器，请按照UTF-8编码来读取源码，否则你在文件中可能就会看到乱码问题。<br><strong>以上就是Unicode编码和UTF-8编码的简单介绍。</strong></p>
<h2 id="编码、解码"><a href="#编码、解码" class="headerlink" title="编码、解码"></a>编码、解码</h2><p>Python紧跟潮流，也支持Unicode编码方式。Python 2.x的默认编码方式是ASCII方式。Python 3.x默认编码方式是unicode方式。str和unicode都是basestring的子类。严格意义上说，str其实是字节串，它是unicode经过编码后的字节组成的序列。对UTF-8编码的str’汉’使用len()函数时，结果是3，因为实际上，UTF-8编码的’汉’==’\xE6\xB1\x89’。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">str  -&gt; decode('the_coding_of_str') -&gt; unicode</div><div class="line">unicode -&gt; encode('the_coding_you_want') -&gt; str</div><div class="line"></div><div class="line">#s是code_A的str</div><div class="line">s.decode('code_A').encode('code_B') #不同编码转换,使用unicode作为中间编码</div></pre></td></tr></table></figure></p>
<p><strong>unicode才是真正意义上的字符串，由字符组成；str是经过unicode经过编码后的字节组成的一个序列。所以不要对str使用编码(encode)，不要对unicode使用解码(decode),</strong>虽然即使你使用了也不会报错，但是不建议这么做。</p>
<p>字符串在Python内部的表示是unicode编码，因此，<strong>在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。</strong> 但是，Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。也因为这个根本原因，在Python2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。</p>
<h3 id="解码（decode）："><a href="#解码（decode）：" class="headerlink" title="解码（decode）："></a>解码（decode）：</h3><p>decode函数的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘gb2312’)，表示将gb2312编码的字符串str1转换成unicode编码。</p>
<h3 id="编码（encode）"><a href="#编码（encode）" class="headerlink" title="编码（encode）:"></a>编码（encode）:</h3><p>encode函数的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘utf-8’)，表示将unicode编码的字符串str2编码成utf-8编码。</p>
<p>encode、decode语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">str.encode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'strict'</span>) <span class="comment">#参数</span></div><div class="line">Decoded string <span class="comment">#返回结果</span></div><div class="line"></div><div class="line">Str.decode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'strict'</span>) <span class="comment">#参数</span></div><div class="line">Decoded string <span class="comment"># 返回结果</span></div></pre></td></tr></table></figure></p>
<p>编码解码使用举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment">#! -*-coding:utf-8-*-</span></div><div class="line">Str = <span class="string">"this is string example....wow!!!"</span></div><div class="line">Str = Str.encode(<span class="string">'base64'</span>, <span class="string">'strict'</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Encoded String: "</span> + Str</div><div class="line"><span class="keyword">print</span> <span class="string">"Decoded String: "</span> + Str.decode(<span class="string">'base64'</span>, <span class="string">'strict'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#输出结果：</span></div><div class="line">Encoded String: dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE=</div><div class="line">Decoded String: this <span class="keyword">is</span> string example....wow!!!</div></pre></td></tr></table></figure></p>
<h3 id="编码问题常见异常总结："><a href="#编码问题常见异常总结：" class="headerlink" title="编码问题常见异常总结："></a>编码问题常见异常总结：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、SyntaxError: Non-ASCII character <span class="comment">#Python源文件中有非ASCII字符，但是同时没有声明编码格式。</span></div><div class="line"><span class="number">2</span>、UnicodeDecodeError <span class="comment">#将其他编码格式转换成unicode编码，但是字符本身的编码格式和decode传入的不相符。如下面：</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line">s = <span class="string">'中文'</span></div><div class="line">s.decode(<span class="string">'gb2312'</span>) <span class="comment"># UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 2-3: illegal multibyte sequence</span></div><div class="line"><span class="keyword">print</span> s</div><div class="line"><span class="number">3</span>、UnicodeEncodeError <span class="comment"># 错误的使用decode和encode方法会出现这种异常，比如：使用decode方法将Unicode字符串转化的时候，如下面：</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line">s = <span class="string">u'中文'</span></div><div class="line">s.decode(<span class="string">'utf-8'</span>) <span class="comment"># UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</span></div><div class="line"><span class="keyword">print</span> s</div></pre></td></tr></table></figure>
<h3 id="编码问题常见处理方法总结："><a href="#编码问题常见处理方法总结：" class="headerlink" title="编码问题常见处理方法总结："></a>编码问题常见处理方法总结：</h3><ul>
<li><p>遵循PEP标准，声明编码格式</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: &lt;encoding name&gt; -*-</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用u’中文’替代’中文’</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">str1 = <span class="string">'中文'</span></div><div class="line">str2 = <span class="string">u'中文'</span></div><div class="line"></div><div class="line"><span class="comment">#以上两种字符串变量的主要不同就是字符串编码不一致，str1的编码和Python声明的编码方式是一致的；str2的编码就是unicode格式。如果你的字符串变量中存在非ASCII字符，那么最好使用str2方式，这样你就不需要使用decode解码了，可以直接encode成你所需要的编码格式了，或者直接操作字符串了，避免异常情况出现。</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用人为的改变文本编码方式</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line"><span class="comment">#以上三行代码可算是解决编码问题的万能钥匙了，几乎能解决所有的编码问题，但是它会带来一些负面影响。</span></div></pre></td></tr></table></figure>
</li>
<li><p>先解码成unicode，再编码成所需的格式，decode early, unicode everywhere, encode late</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment">#! -*-coding:utf-8-*-</span></div><div class="line">Str = <span class="string">"this is string example....wow!!!"</span></div><div class="line">Str = Str.encode(<span class="string">'base64'</span>, <span class="string">'strict'</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Encoded String: "</span> + Str</div><div class="line"><span class="keyword">print</span> <span class="string">"Decoded String: "</span> + Str.decode(<span class="string">'base64'</span>, <span class="string">'strict'</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="http://blog.ernest.me/post/python-setdefaultencoding-unicode-bytes?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">sys.setdefaultencoding(‘utf-8’)的弊端说明的最好的文章</a></strong></p>
<h1 id="Python的call（前后双下划线-函数"><a href="#Python的call（前后双下划线-函数" class="headerlink" title="Python的call（前后双下划线) 函数"></a>Python的call（前后双下划线) 函数</h1><p>##概念<br>Python中有很多小函数，很有意思，也很有用，比如今天讲的<strong>call</strong>函数。<br>我们知道在调用一个类型的时候，必须先实例化，然后用对象去调用。但是如果这个类型中实现了<strong>call</strong>函数，那么这个类型就成为可调用的了，也就说，<strong>call</strong>函数相当于重载了括号运算符。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul>
<li>类型中不实现<strong>call</strong>的时候，如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Func</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, g)</span>:</span></div><div class="line">        self.g = g</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, t)</span>:</span></div><div class="line">        <span class="keyword">return</span> (self.g * t**<span class="number">2</span>) / <span class="number">2</span></div><div class="line"></div><div class="line">e_dpm = Func(<span class="number">2</span>)</div><div class="line">seq =  e_dpm.call(<span class="number">22</span>)</div></pre></td></tr></table></figure>
<ul>
<li>类型中实现了<strong>call</strong>函数的时候，调用可以如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Func</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, g)</span>:</span></div><div class="line">        self.g = g</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, t)</span>:</span></div><div class="line">        <span class="keyword">return</span> (self.g * t**<span class="number">2</span>) / <span class="number">2</span></div><div class="line"></div><div class="line">e_dpm = Func(<span class="number">2</span>)</div><div class="line"><span class="comment">#一下两种方式都可以调用</span></div><div class="line">seq =  e_dpm(<span class="number">22</span>)</div><div class="line">seq = e_dpm.__call__(<span class="number">22</span>)</div></pre></td></tr></table></figure>
<h2 id="call函数总结"><a href="#call函数总结" class="headerlink" title="call函数总结"></a><strong>call</strong>函数总结</h2><p>对象通过提供<strong>call</strong>(slef, [,<em>args [,*</em>kwargs]])方法可以模拟函数的行为，即x(arg1, arg2…) 等同于调用x.<strong>call</strong>(self, arg1, arg2)</p>
<h1 id="识别编码的方法"><a href="#识别编码的方法" class="headerlink" title="识别编码的方法"></a>识别编码的方法</h1><p>有时候在我们没有明确被告知某个字符串、文件等的编码的时候，我们需要识别编码。使用编码方式、编码范围等判断是可行的，比如常用字表等，可惜的是识别率太低了。<br>这时候我们强大的Python就出来解决全人类了。python提供了一个第三方库，<strong>chardet库</strong>可以用来识别编码。</p>
<h2 id="识别编码库chardet库"><a href="#识别编码库chardet库" class="headerlink" title="识别编码库chardet库"></a>识别编码库chardet库</h2><p>chardet库是个Python的第三方库，下面我们就来看看用法，很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> chardet</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'/path/file.txt'</span>,r) <span class="keyword">as</span> f:</div><div class="line">    data = f.read()</div><div class="line"><span class="keyword">print</span> chardet.detect(data)</div><div class="line"></div><div class="line"><span class="comment">#输出：返回值是一个dict，一个是检测的可信度，一个是检测到的编码</span></div><div class="line">&#123;<span class="string">'confidence'</span>: <span class="number">0.99</span>, <span class="string">'encoding'</span>: <span class="string">'utf-8'</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">#当然也可以直接检测字符串等容器的编码</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> chardet</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'zhong国'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> chardet.detect(s)</div><div class="line">&#123;<span class="string">'confidence'</span>: <span class="number">0.505</span>, <span class="string">'encoding'</span>: <span class="string">'utf-8'</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>备注：<a href="http://chardet.readthedocs.io/en/latest/api/chardet.html#module-chardet" target="_blank" rel="external">chardet官网</a></strong></p>
<h1 id="关于print"><a href="#关于print" class="headerlink" title="关于print"></a>关于print</h1><h2 id="print输出文本中的中文"><a href="#print输出文本中的中文" class="headerlink" title="print输出文本中的中文"></a>print输出文本中的中文</h2><p>Python中包含一个中文字符串的列表、字典、文件等的时候，直接print的时候，会出现以下情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dicts = &#123;<span class="string">"asdf"</span>: <span class="string">"学习Python，我们是认真的"</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> dicts</div><div class="line">&#123;<span class="string">'asdf'</span>: <span class="string">'\xe5\xad\xa6\xe4\xb9\xa0Python\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe6\x98\xaf\xe8\xae\xa4\xe7\x9c\x9f\xe7\x9a\x84'</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">#显然上述信息在处理的时候很不方便，此时只需要：</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dicts = &#123;<span class="string">"asdf"</span>: <span class="string">"学习Python，我们是认真的"</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> dicts</div><div class="line">&#123;<span class="string">'asdf'</span>: <span class="string">'\xe5\xad\xa6\xe4\xb9\xa0Python\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe6\x98\xaf\xe8\xae\xa4\xe7\x9c\x9f\xe7\x9a\x84'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> json.dumps(dicts, encoding=<span class="string">"UTF-8"</span>, ensure_ascii=<span class="keyword">False</span>)</div><div class="line">&#123;<span class="string">"asdf"</span>: <span class="string">"学习Python，我们是认真的"</span>&#125;</div></pre></td></tr></table></figure></p>
<h2 id="print的工作原理"><a href="#print的工作原理" class="headerlink" title="print的工作原理"></a>print的工作原理</h2><p>类UNIX系统中有标准输出和标准错误的说法（缩写为stdout、stderr），它们是建立在Unix系统内的管道（pipe）。对于Python来讲，当你输出的时候，结果就是输出到stdout管道中；当程序出错的时候，结果会输出到stderr管道中，而且<strong>一般来讲这两个管道都是与你正在工作的终端窗口相联。</strong>，当然如果你是在一个基于终端的Python IDE系统上工作，stedout和stderr是<strong>缺省窗口</strong>。</p>
<h3 id="print会干什么？"><a href="#print会干什么？" class="headerlink" title="print会干什么？"></a>print会干什么？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'Python2.%d'</span>%i</div><div class="line">...</div><div class="line">Python2<span class="number">.0</span></div><div class="line">Python2<span class="number">.1</span></div><div class="line">Python2<span class="number">.2</span></div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line"><span class="meta">... </span>    sys.stdout.write(<span class="string">'Python2.%d'</span>%i)</div><div class="line">...</div><div class="line">Python2<span class="number">.0</span>Python2<span class="number">.1</span>Python2<span class="number">.2</span>&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line"><span class="meta">... </span>    sys.stderr.write(<span class="string">'Python2.%d'</span>%i)</div><div class="line">...</div><div class="line">Python2<span class="number">.0</span>Python2<span class="number">.1</span>Python2<span class="number">.2</span>&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>由上述测试可以得出如下结论：</p>
<ul>
<li>stdout和stderr都是一个类文件对象，调用他的write，会打印出任何给出的字符串，<strong>并且不加换行符的输出</strong>。</li>
<li>stdout和sterr会把他们的输出发送到同一个地方：Python IDE或者终端（如果你正在终端运行Python）</li>
<li><strong>print所做的工作：</strong>它在字符串末尾加上换行符，然后调用sys.stdout.write()</li>
</ul>
<h3 id="类文件对象是什么？有什么特点？"><a href="#类文件对象是什么？有什么特点？" class="headerlink" title="类文件对象是什么？有什么特点？"></a>类文件对象是什么？有什么特点？</h3><p>stdout、stderr都是类文件对象，<strong>类文件对象是任意一个带有read方法的对象，</strong>这个方法带一个可选的size参数，并返回一个字符串。当不用size参数调用时，它从输入源中读出所有东西，并将所有数据作为单个字符串返回。当使用size参数调用时，它从输入源中读出size大小的数据，并返回那些数据；当再次调用时，它从余下的地方开始并返回下一块数据。<br><strong>虽然stdout、stderr是类文件对象，但是他比较特殊，它们只有write方法而没有read方法。</strong>但是我们可以通过将他绑定到其他的类文件对象来得到不通的输出位置，默认是输出到屏幕。<br>如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">saveout = sys.stdout</div><div class="line">fsock = open(<span class="string">'out.log'</span>, <span class="string">'w'</span>)</div><div class="line">sys.stdout = fsock</div><div class="line"><span class="keyword">print</span> <span class="string">'This message will be logged instead of displayed'</span></div><div class="line">sys.stdout = saveout <span class="comment">#要把stdout恢复回去，stderr一般不用恢复</span></div><div class="line">fsock.close()</div></pre></td></tr></table></figure></p>
<h1 id="super-内建函数"><a href="#super-内建函数" class="headerlink" title="super()内建函数"></a>super()内建函数</h1><p><strong>首先声明一点，super是针对新式类的，不适用于经典类。</strong>，这点一定要明确了。</p>
<h2 id="经典类怎么初始化继承类？"><a href="#经典类怎么初始化继承类？" class="headerlink" title="经典类怎么初始化继承类？"></a>经典类怎么初始化继承类？</h2><p>先看个代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"Base created"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildA</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        Base.__init__(self)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildB</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(ChildB, self).__init__()</div><div class="line"></div><div class="line"><span class="keyword">print</span> ChildA()</div><div class="line"><span class="keyword">print</span> ChildB()</div><div class="line"></div><div class="line"><span class="comment">#输出结果</span></div><div class="line">Base created</div><div class="line">&lt;__main__.ChildA object at <span class="number">0x7fcca2eafbd0</span>&gt;</div><div class="line">Base created</div><div class="line">&lt;__main__.ChildB object at <span class="number">0x7fcca2eafbd0</span>&gt;</div></pre></td></tr></table></figure></p>
<p>由此看出，其实super和直接使用继承类去初始化没什么区别，但是你想想，当有一天，你突然想改名父类Base(object)为Root呢，那么对于子类来说，是不是全要改一次呢，显然，如果大量子类继承这个父类的话，你的代码怎么维护。所以使用super显而易见的作用就是维护成本小，当然，这仅仅是它显而易见的作用，还有其他的作用，下面来讲。</p>
<h2 id="新式类的super"><a href="#新式类的super" class="headerlink" title="新式类的super"></a>新式类的super</h2><p>首先，要更深入的了解super，必须要先要了解<strong>MRO（方法解析顺序）</strong>。<br>在支持多继承的编程语言中，其方法、属性有可能是定义在当前类中，也有可能是在继承类中，那么问题来了，当有多个继承的时候，比如class Child（root_A,root_B）,那么假如父类中有重复的方法和类，到底使用那个呢？所以必须在调用该方法前先要对当前类和继承类进行搜素，以确定方法所在的位置，而这种搜索顺序就是所谓的MRO。</p>
<p><a href="http://hanjianwei.com/2013/07/25/python-mro/" target="_blank" rel="external">MRO知识普及文章推荐</a>,感谢作者。</p>
<h2 id="super到底干了什么工作？"><a href="#super到底干了什么工作？" class="headerlink" title="super到底干了什么工作？"></a>super到底干了什么工作？</h2><p>super本质上干的工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></div><div class="line">    mro = inst.__class__.mro()</div><div class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>上述函数解读，也是super函数的本质：</p>
<ul>
<li><strong>inst 负责生成 MRO 的 list</strong></li>
<li><strong>通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1]</strong></li>
</ul>
<p>是不是还有点丈二和尚摸不着头脑，不要紧，接下来，将举例说明上述函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Root(object):</div><div class="line">    def __init__(self):</div><div class="line">        print("this is Root")</div><div class="line">class B(Root):</div><div class="line">    def __init__(self):</div><div class="line">        print("enter B")</div><div class="line">        super(B, self).__init__()</div><div class="line">        print("leave B")</div><div class="line">class C(Root):</div><div class="line">    def __init__(self):</div><div class="line">        print("enter C")</div><div class="line">        super(C, self).__init__()</div><div class="line">        print("leave C")</div><div class="line">class D(B, C):</div><div class="line">    pass</div><div class="line">d = D()</div><div class="line">print(d.__class__.__mro__)</div><div class="line"></div><div class="line">#输出：</div><div class="line">enter B</div><div class="line">enter C</div><div class="line">this is Root</div><div class="line">leave C</div><div class="line">leave B</div><div class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure>
<p>有上述结果，我们能得到如下结论：</p>
<ul>
<li>super和父类并没有直接的关联，而是指MRO中的下一个类。因为如果直接关联的话，打印出来的结果应该是B之后就是Root类了，但是实质上是C类，因此super是mro[index + 1]。</li>
<li>super会根据MRO逐个按顺序的去找<strong>init</strong>(前后双下划线，下同)构造函数，所以会先找自身，发现D没有<strong>init</strong>，接着去找B的，再去找C，再去找Root，再去找元类type。<strong>在MRO中，基类永远出现在派生类后面，如果有多个基类，基类的相对顺序保持不变。</strong></li>
</ul>
<p>备注：<br>上述举例代码中，我们如果给class B()中加二个打印的print，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Root)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> self.__class__</div><div class="line">        <span class="keyword">print</span> self.__class__.__mro__</div><div class="line">        print(<span class="string">"enter B"</span>)</div><div class="line">        super(B, self).__init__()</div><div class="line">        print(<span class="string">"leave B"</span>)</div></pre></td></tr></table></figure></p>
<p>猜猜输出的是什么？<br>结果输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;class '__main__.D'&gt;</div><div class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure></p>
<p>注意：self输出的是D的instance，而不是B的instance。</p>
<h1 id="sorted排序"><a href="#sorted排序" class="headerlink" title="sorted排序"></a>sorted排序</h1><p>内建函数sorted()可对<strong>可迭代序列排序</strong>，返回一个排好序的可迭代序列。</p>
<h2 id="sorted函数："><a href="#sorted函数：" class="headerlink" title="sorted函数："></a>sorted函数：</h2><h3 id="sorted原型和参数"><a href="#sorted原型和参数" class="headerlink" title="sorted原型和参数"></a>sorted原型和参数</h3><p>源函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sorted(...)</div><div class="line">    sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list</div></pre></td></tr></table></figure></p>
<p>参数解析：</p>
<ul>
<li>iterable：是可迭代类型;</li>
<li>cmp：用于比较的函数，比较什么由key决定,有默认值，迭代集合中的一项;</li>
<li>key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;</li>
<li>reverse：排序规则. reverse = True 或者 reverse = False，默认升序；</li>
<li>返回值：是一个经过排序的可迭代类型，与iterable一样。</li>
</ul>
<h3 id="sorted和sort的区别"><a href="#sorted和sort的区别" class="headerlink" title="sorted和sort的区别"></a>sorted和sort的区别</h3><ul>
<li>sort仅仅是list的一个方法，其他可迭代序列无此方法；sorted对所有的可迭代序列有效。</li>
<li>sort是就地排序，排完序后list的本身也改变了；sorted是生成一个新的排好序的序列。</li>
</ul>
<p>举例说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lists = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lists)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lists</div><div class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lists.sort()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lists</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure></p>
<h2 id="sorted函数使用方法详解"><a href="#sorted函数使用方法详解" class="headerlink" title="sorted函数使用方法详解"></a>sorted函数使用方法详解</h2><p>list.sort()和sorted()都支持key参数，key参数指定一个函数或者表达式等，此函数在<strong>每个元素比较前</strong>被调用。此函数的参数只有一个，并且返回一个值来与其他元素做比较。<br>key指定的函数可以对每个元素快速的作用，所以这个速度其实是很快的。</p>
<p>在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数，cmp参数指定的函数用来进行元素间的比较。python3.0以后这个参数被废除。</p>
<p>比如：</p>
<ol>
<li><p>不区分大小写的进行排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(<span class="string">"This is a test string from Andrew"</span>.split(), key=str.lower)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'Andrew'</span>, <span class="string">'from'</span>, <span class="string">'is'</span>, <span class="string">'string'</span>, <span class="string">'test'</span>, <span class="string">'This'</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>按照年龄排队：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>student_tuples = [</div><div class="line"><span class="meta">... </span>        (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>),</div><div class="line"><span class="meta">... </span>        (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</div><div class="line"><span class="meta">... </span>        (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>),</div><div class="line"><span class="meta">... </span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(student_tuples, key=<span class="keyword">lambda</span> student: student[<span class="number">2</span>])</div><div class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(student_tuples, key=<span class="keyword">lambda</span> student: student[<span class="number">2</span>],reverse=<span class="keyword">True</span>)</div><div class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>)]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>调用cmp函数来比较大小：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">numeric_compare</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x - y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], cmp=numeric_compare)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">numeric_compare</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> y - x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], cmp=numeric_compare)</div><div class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h3><ul>
<li><p>按照字典的value中排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">x = &#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="number">0</span>&#125;</div><div class="line">sorted_value = sorted(x.iteritems(), key=<span class="keyword">lambda</span> e: e[<span class="number">1</span>])</div><div class="line"><span class="keyword">print</span> sorted_value</div><div class="line">sorte_values = sorted(x.iteritems(), key=<span class="keyword">lambda</span> e: e[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">print</span> sorte_values</div><div class="line"></div><div class="line"><span class="comment">#输出</span></div><div class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>)]</div><div class="line">[(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>)]</div></pre></td></tr></table></figure>
</li>
<li><p>list的元素是dict，排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">x = [&#123;<span class="string">'name'</span>: <span class="string">'Homer'</span>, <span class="string">'age'</span>: <span class="number">9</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'Bart'</span>, <span class="string">'age'</span>: <span class="number">10</span>&#125;]</div><div class="line">values = sorted(x, key=<span class="keyword">lambda</span> x: x[<span class="string">'name'</span>])</div><div class="line">value = sorted(x, key=<span class="keyword">lambda</span> x: x[<span class="string">'age'</span>])</div><div class="line"><span class="keyword">print</span> values</div><div class="line"><span class="keyword">print</span> value</div><div class="line"></div><div class="line"><span class="comment">#输出</span></div><div class="line">[&#123;<span class="string">'age'</span>: <span class="number">10</span>, <span class="string">'name'</span>: <span class="string">'Bart'</span>&#125;, &#123;<span class="string">'age'</span>: <span class="number">9</span>, <span class="string">'name'</span>: <span class="string">'Homer'</span>&#125;]</div><div class="line">[&#123;<span class="string">'age'</span>: <span class="number">9</span>, <span class="string">'name'</span>: <span class="string">'Homer'</span>&#125;, &#123;<span class="string">'age'</span>: <span class="number">10</span>, <span class="string">'name'</span>: <span class="string">'Bart'</span>&#125;]</div></pre></td></tr></table></figure>
</li>
<li><p>按照字典value的某个元素排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">myDict = &#123;<span class="string">'item1'</span>: [<span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>], <span class="string">'item2'</span>: [<span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'item3'</span>: [<span class="number">9</span>, <span class="number">3</span>, <span class="number">11</span>]&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortDic</span><span class="params">(Dict, valuePostion)</span>:</span></div><div class="line">    <span class="keyword">return</span> sorted(Dict.items(), key=<span class="keyword">lambda</span> e: e[<span class="number">1</span>][valuePostion])</div><div class="line"></div><div class="line"><span class="comment"># 按value的第3个值排序</span></div><div class="line"><span class="keyword">print</span> sortDic(myDict, <span class="number">2</span>)</div><div class="line">[(<span class="string">'item2'</span>, [<span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>]), (<span class="string">'item1'</span>, [<span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>]), (<span class="string">'item3'</span>, [<span class="number">9</span>, <span class="number">3</span>, <span class="number">11</span>])]</div><div class="line"></div><div class="line"><span class="comment"># 按value的第1个值排序</span></div><div class="line"><span class="keyword">print</span> sortDic(myDict, <span class="number">0</span>)</div><div class="line">[(<span class="string">'item1'</span>, [<span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>]), (<span class="string">'item2'</span>, [<span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>]), (<span class="string">'item3'</span>, [<span class="number">9</span>, <span class="number">3</span>, <span class="number">11</span>])]</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="with上下文管理器"><a href="#with上下文管理器" class="headerlink" title="with上下文管理器"></a>with上下文管理器</h1><h1 id="获取脚本的执行路径问题"><a href="#获取脚本的执行路径问题" class="headerlink" title="获取脚本的执行路径问题"></a>获取脚本的执行路径问题</h1><p>Python中有两种方法能获取到执行脚本的文件路径，一种是<strong>“<strong>file</strong>“</strong>，一种是<strong>“sys.argv[0]”</strong>。</p>
<h2 id="主执行文件，获取执行脚本路径"><a href="#主执行文件，获取执行脚本路径" class="headerlink" title="主执行文件，获取执行脚本路径"></a>主执行文件，获取执行脚本路径</h2><p>在主执行文件中，<strong>“<strong>file</strong>“</strong>和sys.argv[0]区别不大，都是根据的到执行该脚本的方式不同，而得到绝对路径或者相对路径。<br>如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"__file__    --------&gt;%s"</span>%__file__</div><div class="line"><span class="keyword">print</span> <span class="string">"sys.argv[0] --------&gt;%s"</span>%sys.argv[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment">#输出结果：</span></div><div class="line"><span class="string">"""</span></div><div class="line">[root@localhost workspace]# ./test.py</div><div class="line">__file__    --------&gt;./test.py</div><div class="line">sys.argv[0] --------&gt;./test.py</div><div class="line">[root@localhost workspace]# /root/workspace/test.py</div><div class="line">__file__    --------&gt;/root/workspace/test.py</div><div class="line">sys.argv[0] --------&gt;/root/workspace/test.py</div><div class="line">[root@localhost workspace]# ~/workspace/test.py</div><div class="line">__file__    --------&gt;/root/workspace/test.py</div><div class="line">sys.argv[0] --------&gt;/root/workspace/test.py</div><div class="line">"""</div></pre></td></tr></table></figure></p>
<p>由上面的测试可以看到，此两种获取路径的方式都是由执行脚本的方式不同，而结果是相对路径或者绝对路径，可以通过<strong>os.path.abspath()</strong>函数来取得执行脚本的绝对路径。<br>以上说明<strong>在主文件中执行的时候，这两种方式没什么区别。</strong></p>
<h2 id="非主执行文件，import其他文件，获取执行脚本路径"><a href="#非主执行文件，import其他文件，获取执行脚本路径" class="headerlink" title="非主执行文件，import其他文件，获取执行脚本路径"></a>非主执行文件，import其他文件，获取执行脚本路径</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># test_1.py脚本，主执行脚本</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">print</span> <span class="string">"__file__    --------&gt;%s"</span>%__file__</div><div class="line"><span class="keyword">print</span> <span class="string">"sys.argv[0] --------&gt;%s"</span>%sys.argv[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="keyword">import</span> test_2</div><div class="line">test_2.show_path()</div><div class="line"></div><div class="line"><span class="comment"># test_2.py脚本，供其他文件引入的脚本，非主执行文件</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_path</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"show_path:__file__    --------&gt;%s"</span>%__file__</div><div class="line">    <span class="keyword">print</span> <span class="string">"show_path:sys.argv[0] --------&gt;%s"</span>%sys.argv[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment">#输出结果：</span></div><div class="line"><span class="string">"""</span></div><div class="line">__file__    --------&gt;./test_1.py</div><div class="line">sys.argv[0] --------&gt;./test_1.py</div><div class="line">show_path:__file__    --------&gt;/root/workspace/test_2.py</div><div class="line">show_path:sys.argv[0] --------&gt;./test_1.py</div><div class="line">"""</div></pre></td></tr></table></figure>
<p>以上结果说明，<strong>“<strong>file</strong>“</strong>得到的不一定是主文件的执行路径，而是那个脚本中的<strong><strong>file</strong></strong>，则得到是那个脚本的路径，而<strong>sys.argv[0]</strong>得到的是永远是主执行文件的路径，这个很好理解，因为sys.argv[0]本质上就是脚本命令行的第一个参数，那么这个脚本是什么，肯定得到的第一个参数就是什么。</p>
<p><strong>以上结果说明：当需要获取执行脚本的路径的时候，sys.argv[0]比<strong>file</strong>更靠谱一些。</strong></p>
<p><a href="https://laike9m.com/blog/li-jie-python-super,70/" target="_blank" rel="external">super解释非常好的博客</a>，感谢作者！</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/04/17/Python葵花宝典/" data-id="citoiron40000ta02q7pi09gl" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Python基础/">Python基础</a></div><div class="post-nav"><a href="/2016/04/19/Python命令行解析详解/" class="pre">Python命令行解析详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python之聚石塔/">Python之聚石塔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tornado系列/">Tornado系列</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Python基础/" style="font-size: 15px;">Python基础</a> <a href="/tags/Python命令行解析/" style="font-size: 15px;">Python命令行解析</a> <a href="/tags/Tornado源码分析/" style="font-size: 15px;">Tornado源码分析</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/18/tornado-web源码分析/">Tornado.web源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/13/聊聊tornado源码之前奏曲-深入了解handler/">Tornado源码之handler</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/11/Tornado之web服务器的网络知识了解/">Tornado之web服务器的网络知识了解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/09/Tornado的HTTP-Server的服务模型/">Tornado的HTTP Server的服务模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/08/聊聊tornado源码之鸟瞰tornado框架/">鸟瞰Tornado框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/04/tornado源码剖析系列文章目录/">Tornado源码剖析系列文章目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/04/Tornado的简历/">Tornado的简历</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/19/Python命令行解析详解/">Python命令行解析详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/17/Python葵花宝典/">Python葵花宝典</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/LingYue/LingYue.github.io" title="翎月的github" target="_blank">翎月的github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">菊香书屋.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>