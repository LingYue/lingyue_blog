{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/about/1648683886.jpg","path":"about/1648683886.jpg","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1475164143000},{"_id":"themes/maupassant/README.md","hash":"75d8c42569809961953d1934de445418c00ab94c","modified":1475164143000},{"_id":"themes/maupassant/_config.yml","hash":"8561450ed0793687a586181a54ed43ad210a18b4","modified":1475164143000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1475164143000},{"_id":"source/_posts/Python命令行解析详解.md","hash":"0c5a1e7ef1f7257e6d2d330cb14b228c312b3978","modified":1475164143000},{"_id":"source/_posts/Python葵花宝典.md","hash":"dd7609705afa4be8c0a00ba7c46c9535d2db486f","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解.md","hash":"12eedf2bd2f8aa600f04fd441e50f1789b164133","modified":1475164143000},{"_id":"source/_posts/Tornado的HTTP-Server的服务模型.md","hash":"7cabcbd639de155b31bce65b8fd1c32340ec7d66","modified":1475164143000},{"_id":"source/_posts/Tornado的简历.md","hash":"186e70037f1820cb80b303fabdc7a10b5024f242","modified":1475164143000},{"_id":"source/_posts/tornado-web源码分析.md","hash":"35278e34c721c64daf036fd0a1e7a858dffebbe7","modified":1475164143000},{"_id":"source/_posts/tornado源码剖析系列文章目录.md","hash":"923adfd74b05b59922f7cd4ce3ef590aa3996307","modified":1475164143000},{"_id":"source/_posts/聊聊tornado源码之前奏曲-深入了解handler.md","hash":"b9b521173da082ee57e5029e09d3a2ea2da8cb4f","modified":1475164143000},{"_id":"source/_posts/聊聊tornado源码之鸟瞰tornado框架.md","hash":"8d7e15d2cb907ae4400f18575f8319330c67eedf","modified":1475164143000},{"_id":"source/about/.DS_Store","hash":"db151367d4f8511021f86752a1ce2e0fa27b6a36","modified":1475164143000},{"_id":"source/categories/index.md","hash":"3dc12d36cf078c14357d1a05285ffb4d898f1367","modified":1475164143000},{"_id":"source/about/index.md","hash":"25102b2d72e66c3f7332018b937405fc28e1d7b1","modified":1475164143000},{"_id":"source/tags/index.md","hash":"c286c81dc42f408dd716272f617d16e86fb921e9","modified":1475164143000},{"_id":"source/book/index.md","hash":"90b151bc4ebdfea3ff8ba7ec581526256b112143","modified":1475164143000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1475164143000},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1475164143000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1475164143000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1475164143000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1475164143000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1475164143000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1475164143000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1475164143000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"1ad721de96784bf4253316b796db6200148d4152","modified":1475164143000},{"_id":"themes/maupassant/layout/base.jade","hash":"852c610ac392ef2fa130dbe73bcf4f96f423c869","modified":1475164143000},{"_id":"themes/maupassant/layout/index.jade","hash":"7466ce52023ed8a413a6b4461354a9e20e62fc14","modified":1475164143000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1475164143000},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1475164143000},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1475164143000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1475164143000},{"_id":"source/about/1648683886.jpg","hash":"326c847292f657ed13649235882659c834c722c4","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/2013_10_14_03.gif","hash":"3f39ae70d1357658544e2da12ed782d65ff12c53","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_002.png","hash":"812008bb159f98ae1dfc05803268581f70b7bed4","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_003.png","hash":"67f92572e325b13e1d551e5086aa135a138556d6","modified":1475164143000},{"_id":"source/_posts/tornado-web源码分析/torndao_001.PNG","hash":"c3526dbb3b4ff07bdc09bafc3118b62c973405e3","modified":1475164143000},{"_id":"source/_posts/聊聊tornado源码之鸟瞰tornado框架/tornado_001.gif","hash":"dbcd9d2863281b640b4d2d0f36dda78196fca79e","modified":1475164143000},{"_id":"source/_posts/聊聊tornado源码之鸟瞰tornado框架/tornado_002.png","hash":"d75e438b75fefc45545c6b25b84ecd3ee229242d","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"260997e1d43b7b3adf7cb19da9eca6d235f5333b","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1475164143000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1475164143000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1475164143000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1475164143000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1475164143000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1475164143000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1475164143000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1475164143000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1475164143000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1475164143000},{"_id":"themes/maupassant/source/css/style.scss","hash":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1475164143000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1475164143000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1475164143000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1475164143000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1475164143000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1475164143000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1475164143000},{"_id":"themes/maupassant/source/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1475164143000},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1475164143000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1475164143000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_000.png","hash":"5b44d8344b3db4ef93e05d77a624a4a3072a532b","modified":1475164143000},{"_id":"source/_posts/聊聊tornado源码之鸟瞰tornado框架/tornado_003.png","hash":"02698e7130479b5be586553d620db2e074ad3faf","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_004.png","hash":"28049a44fae989f2e1064c513ac693787e085429","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_007.png","hash":"d8769e81d8b15d558404d805bd1d024e217d23b8","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_006.png","hash":"3f50f85745fc5405dfec8a4d31e9337e8649de98","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_005.png","hash":"e706080387623abcbce59b0853564c411812fc6d","modified":1475164143000},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_008.png","hash":"55538060a15bc989e959821a41a265c44b1d086c","modified":1475164143000},{"_id":"public/categories/index.html","hash":"6ccd9184e364eb4b34cf658bc8f83fb2a868a90f","modified":1475164355357},{"_id":"public/about/index.html","hash":"c837b4a17ee122b0f6d363a242a1f31822232f21","modified":1475164355357},{"_id":"public/tags/index.html","hash":"8fa59922e9c451e55f24c213a60ab9b5ca24aea1","modified":1475164355357},{"_id":"public/book/index.html","hash":"60f3f819796f397cf5cdcc1c631c7a83b14993a0","modified":1475164355357},{"_id":"public/2016/05/13/聊聊tornado源码之前奏曲-深入了解handler/index.html","hash":"3c410c75f42f776dccdf9b15f6e8a7c2c92dddaa","modified":1475164355357},{"_id":"public/2016/05/09/Tornado的HTTP-Server的服务模型/index.html","hash":"e9cab2b4322ee270e8d09df21de88441cd2432de","modified":1475164355358},{"_id":"public/2016/05/08/聊聊tornado源码之鸟瞰tornado框架/index.html","hash":"3767e2daea8c5d2d10836f6bdc056b3dbcf0f78b","modified":1475164355358},{"_id":"public/archives/index.html","hash":"33aeb6579947f86ce1ca24001eef4a668db5aeb6","modified":1475164355358},{"_id":"public/archives/2016/index.html","hash":"33aeb6579947f86ce1ca24001eef4a668db5aeb6","modified":1475164355358},{"_id":"public/archives/2016/04/index.html","hash":"36394af94511d7376cc5c0901c92f792fecc5373","modified":1475164355358},{"_id":"public/archives/2016/05/index.html","hash":"abc3f5e39617b3a695da952cc46250c1773db323","modified":1475164355358},{"_id":"public/categories/Python之聚石塔/index.html","hash":"60a4e8a090238ef49c352c4e3eea3873aabec66c","modified":1475164355358},{"_id":"public/categories/Tornado系列/index.html","hash":"e68247898d51bb8abe1e56b7c700017bdcc9e37b","modified":1475164355358},{"_id":"public/index.html","hash":"93ad077215b67e200375bad270dc2bd4ae602d0e","modified":1475164355358},{"_id":"public/tags/Python基础/index.html","hash":"9990f9a62e821cd60178ec303ff7bf98d0db7fe2","modified":1475164355358},{"_id":"public/tags/Python命令行解析/index.html","hash":"a4e4d95b688bd66d8a04de74365e1acd8028bad1","modified":1475164355358},{"_id":"public/tags/Tornado源码分析/index.html","hash":"9ef211c03759f678b8e278b17b68a8cebc6d0112","modified":1475164355358},{"_id":"public/2016/05/18/tornado-web源码分析/index.html","hash":"29905b0c35b01063bcf1d4da57c9752db359e41a","modified":1475164355358},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/index.html","hash":"6077c90be7832c9fb949eba69dfdcd18624acfa5","modified":1475164355358},{"_id":"public/2016/05/04/tornado源码剖析系列文章目录/index.html","hash":"8de046b86c2f88b1aad91f5143c84bb92f4ea462","modified":1475164355359},{"_id":"public/2016/05/04/Tornado的简历/index.html","hash":"b1150c7af7ee6d7f81e16a2c7087cc98b0c05bef","modified":1475164355359},{"_id":"public/2016/04/19/Python命令行解析详解/index.html","hash":"ffcd608ad3887312ced58c95f05a3ff17bd191c6","modified":1475164355359},{"_id":"public/2016/04/17/Python葵花宝典/index.html","hash":"17ee2b05260636d94cd4a48951a8231d64c8a240","modified":1475164355359},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1475164355373},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1475164355373},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1475164355373},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1475164355373},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1475164355373},{"_id":"public/2016/05/18/tornado-web源码分析/torndao_001.PNG","hash":"c3526dbb3b4ff07bdc09bafc3118b62c973405e3","modified":1475164355373},{"_id":"public/2016/05/08/聊聊tornado源码之鸟瞰tornado框架/tornado_001.gif","hash":"dbcd9d2863281b640b4d2d0f36dda78196fca79e","modified":1475164355373},{"_id":"public/2016/05/08/聊聊tornado源码之鸟瞰tornado框架/tornado_002.png","hash":"d75e438b75fefc45545c6b25b84ecd3ee229242d","modified":1475164355373},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/2013_10_14_03.gif","hash":"3f39ae70d1357658544e2da12ed782d65ff12c53","modified":1475164355373},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_002.png","hash":"812008bb159f98ae1dfc05803268581f70b7bed4","modified":1475164355373},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_003.png","hash":"67f92572e325b13e1d551e5086aa135a138556d6","modified":1475164355373},{"_id":"public/about/1648683886.jpg","hash":"326c847292f657ed13649235882659c834c722c4","modified":1475164355403},{"_id":"public/2016/05/08/聊聊tornado源码之鸟瞰tornado框架/tornado_003.png","hash":"02698e7130479b5be586553d620db2e074ad3faf","modified":1475164355403},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_000.png","hash":"5b44d8344b3db4ef93e05d77a624a4a3072a532b","modified":1475164355408},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1475164355414},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1475164355414},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1475164355415},{"_id":"public/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1475164355415},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1475164355415},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1475164355415},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1475164355415},{"_id":"public/css/style.css","hash":"2afb6e7e24abf81c8b7b7d472fb0bb9b9a1eac16","modified":1475164355415},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_004.png","hash":"28049a44fae989f2e1064c513ac693787e085429","modified":1475164355415},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_007.png","hash":"d8769e81d8b15d558404d805bd1d024e217d23b8","modified":1475164355415},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_006.png","hash":"3f50f85745fc5405dfec8a4d31e9337e8649de98","modified":1475164355420},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_005.png","hash":"e706080387623abcbce59b0853564c411812fc6d","modified":1475164355423},{"_id":"public/2016/05/11/Tornado之web服务器的网络知识了解/tornado_008.png","hash":"55538060a15bc989e959821a41a265c44b1d086c","modified":1475164355432}],"Category":[{"name":"Python之聚石塔","_id":"citoironi0004ta02o9pnlg6a"},{"name":"Tornado系列","_id":"citoiroo9000hta02xgypqwng"}],"Data":[],"Page":[{"title":"categories","date":"2016-09-27T04:57:28.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-09-27 12:57:28\n---\n","updated":"2016-09-29T15:49:03.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"citoirona0001ta02b53wc7wu","content":"","excerpt":"","more":""},{"date":"2016-04-17T03:48:33.000Z","type":"about","_content":"**关于我**\n- ID： 菊香书屋\n- 居于：长安\n- 现就职于： 阿里巴巴\n- 职位： 软件开发工程师\n- 兴趣： 阅读、旅游\n- 梦想： 所有的奋斗都是为了让我的亲人生活的更好，并尽可能的惠及更多的人。\n\n**关于博客**\n- 目的： 所思所想的札记。\n- 方向： 哲学、Python\n\n**联系方式**\n- 邮箱： taojbai@163.com\n\n**海棠花**\n![](1648683886.jpg)\n![](001.png)\n![](003.jpg)\n","source":"about/index.md","raw":"---\ndate: 2016-04-17 11:48:33\ntype: \"about\"\n---\n**关于我**\n- ID： 菊香书屋\n- 居于：长安\n- 现就职于： 阿里巴巴\n- 职位： 软件开发工程师\n- 兴趣： 阅读、旅游\n- 梦想： 所有的奋斗都是为了让我的亲人生活的更好，并尽可能的惠及更多的人。\n\n**关于博客**\n- 目的： 所思所想的札记。\n- 方向： 哲学、Python\n\n**联系方式**\n- 邮箱： taojbai@163.com\n\n**海棠花**\n![](1648683886.jpg)\n![](001.png)\n![](003.jpg)\n","updated":"2016-09-29T15:49:03.000Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"citoirong0003ta02bnref4o4","content":"<p><strong>关于我</strong></p>\n<ul>\n<li>ID： 菊香书屋</li>\n<li>居于：长安</li>\n<li>现就职于： 阿里巴巴</li>\n<li>职位： 软件开发工程师</li>\n<li>兴趣： 阅读、旅游</li>\n<li>梦想： 所有的奋斗都是为了让我的亲人生活的更好，并尽可能的惠及更多的人。</li>\n</ul>\n<p><strong>关于博客</strong></p>\n<ul>\n<li>目的： 所思所想的札记。</li>\n<li>方向： 哲学、Python</li>\n</ul>\n<p><strong>联系方式</strong></p>\n<ul>\n<li>邮箱： taojbai@163.com</li>\n</ul>\n<p><strong>海棠花</strong><br><img src=\"1648683886.jpg\" alt=\"\"><br><img src=\"001.png\" alt=\"\"><br><img src=\"003.jpg\" alt=\"\"></p>\n","excerpt":"","more":"<p><strong>关于我</strong></p>\n<ul>\n<li>ID： 菊香书屋</li>\n<li>居于：长安</li>\n<li>现就职于： 阿里巴巴</li>\n<li>职位： 软件开发工程师</li>\n<li>兴趣： 阅读、旅游</li>\n<li>梦想： 所有的奋斗都是为了让我的亲人生活的更好，并尽可能的惠及更多的人。</li>\n</ul>\n<p><strong>关于博客</strong></p>\n<ul>\n<li>目的： 所思所想的札记。</li>\n<li>方向： 哲学、Python</li>\n</ul>\n<p><strong>联系方式</strong></p>\n<ul>\n<li>邮箱： taojbai@163.com</li>\n</ul>\n<p><strong>海棠花</strong><br><img src=\"1648683886.jpg\" alt=\"\"><br><img src=\"001.png\" alt=\"\"><br><img src=\"003.jpg\" alt=\"\"></p>\n"},{"title":"tags","date":"2016-09-27T04:56:55.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-09-27 12:56:55\n---\n","updated":"2016-09-29T15:49:03.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"citoironq0007ta02m9hjm9rq","content":"","excerpt":"","more":""},{"date":"2016-04-18T11:36:37.000Z","type":"book","_content":"\n# 文字是思想的载体, 思想是语言的灵魂。\n\n> 为天地立心，为生民立命，为往圣继绝学，为万世开太平\n\n\n----------\n\n\n**正在读的书**\n《自控力》-【美】 凯利·麦格尼格尔\n\n\n----------\n\n\n**哲学系列**\n《中国哲学简史》-【中】 冯友兰\n《道德经》-【中】 老子\n\n\n----------\n\n\n**财务金融经济系列**\n《财务智慧》\n《激荡三十年》-【中】 吴晓波\n\n\n----------\n\n\n**管理系列**\n《卓有成效的管理者》\n《大败局Ⅰ》-【中】 吴晓波\n《大败局Ⅱ》-【中】 吴晓波\n《马云管理日志》\n《重新定义公司-谷歌是如何运营的》\n《创业的36条军规》\n\n\n----------\n\n\n**人物传记系列**\n《胡雪岩传》\n《雷军传-站在风口上》\n《诸时键-影响企业家的企业家》-【中】 先燕云\n\n\n----------\n\n\n**互联网系列**\n《人人都是产品经理》- 【中】 苏杰\n《互联网+ -从IT到DT》-【中】 阿里研究院\n《社交红利》\n《浪潮之巅》\n《淘宝技术这十年》\n\n----------\n\n\n**计算机系列**\n《构建高性能Web站点》\n\n\n----------\n\n**历史系列**\n《万历十五年》-【美】 黄仁宇\n《明朝那些事儿》\n\n----------\n\n\n**编程语言系列**\n《Python核心编程》\n《Python Cookbook》\n《编写高质量代码-Python的99个建议》\n《STL源码剖析》\n《Python自动化运维》\n\n\n----------\n\n\n**菊香书屋**\n《自控力》-【美】 凯利·麦格尼格尔\n《疯狂的简洁》-【美】 肯·西格尔\n《数学之美》\n《暗时间》\n《销售无处不在》\n\n\n----------\n","source":"book/index.md","raw":"---\ndate: 2016-04-18 19:36:37\ntype: \"book\"\n---\n\n# 文字是思想的载体, 思想是语言的灵魂。\n\n> 为天地立心，为生民立命，为往圣继绝学，为万世开太平\n\n\n----------\n\n\n**正在读的书**\n《自控力》-【美】 凯利·麦格尼格尔\n\n\n----------\n\n\n**哲学系列**\n《中国哲学简史》-【中】 冯友兰\n《道德经》-【中】 老子\n\n\n----------\n\n\n**财务金融经济系列**\n《财务智慧》\n《激荡三十年》-【中】 吴晓波\n\n\n----------\n\n\n**管理系列**\n《卓有成效的管理者》\n《大败局Ⅰ》-【中】 吴晓波\n《大败局Ⅱ》-【中】 吴晓波\n《马云管理日志》\n《重新定义公司-谷歌是如何运营的》\n《创业的36条军规》\n\n\n----------\n\n\n**人物传记系列**\n《胡雪岩传》\n《雷军传-站在风口上》\n《诸时键-影响企业家的企业家》-【中】 先燕云\n\n\n----------\n\n\n**互联网系列**\n《人人都是产品经理》- 【中】 苏杰\n《互联网+ -从IT到DT》-【中】 阿里研究院\n《社交红利》\n《浪潮之巅》\n《淘宝技术这十年》\n\n----------\n\n\n**计算机系列**\n《构建高性能Web站点》\n\n\n----------\n\n**历史系列**\n《万历十五年》-【美】 黄仁宇\n《明朝那些事儿》\n\n----------\n\n\n**编程语言系列**\n《Python核心编程》\n《Python Cookbook》\n《编写高质量代码-Python的99个建议》\n《STL源码剖析》\n《Python自动化运维》\n\n\n----------\n\n\n**菊香书屋**\n《自控力》-【美】 凯利·麦格尼格尔\n《疯狂的简洁》-【美】 肯·西格尔\n《数学之美》\n《暗时间》\n《销售无处不在》\n\n\n----------\n","updated":"2016-09-29T15:49:03.000Z","path":"book/index.html","title":"","comments":1,"layout":"page","_id":"citoironw0009ta02o465kjix","content":"<h1 id=\"文字是思想的载体-思想是语言的灵魂。\"><a href=\"#文字是思想的载体-思想是语言的灵魂。\" class=\"headerlink\" title=\"文字是思想的载体, 思想是语言的灵魂。\"></a>文字是思想的载体, 思想是语言的灵魂。</h1><blockquote>\n<p>为天地立心，为生民立命，为往圣继绝学，为万世开太平</p>\n</blockquote>\n<hr>\n<p><strong>正在读的书</strong><br>《自控力》-【美】 凯利·麦格尼格尔</p>\n<hr>\n<p><strong>哲学系列</strong><br>《中国哲学简史》-【中】 冯友兰<br>《道德经》-【中】 老子</p>\n<hr>\n<p><strong>财务金融经济系列</strong><br>《财务智慧》<br>《激荡三十年》-【中】 吴晓波</p>\n<hr>\n<p><strong>管理系列</strong><br>《卓有成效的管理者》<br>《大败局Ⅰ》-【中】 吴晓波<br>《大败局Ⅱ》-【中】 吴晓波<br>《马云管理日志》<br>《重新定义公司-谷歌是如何运营的》<br>《创业的36条军规》</p>\n<hr>\n<p><strong>人物传记系列</strong><br>《胡雪岩传》<br>《雷军传-站在风口上》<br>《诸时键-影响企业家的企业家》-【中】 先燕云</p>\n<hr>\n<p><strong>互联网系列</strong><br>《人人都是产品经理》- 【中】 苏杰<br>《互联网+ -从IT到DT》-【中】 阿里研究院<br>《社交红利》<br>《浪潮之巅》<br>《淘宝技术这十年》</p>\n<hr>\n<p><strong>计算机系列</strong><br>《构建高性能Web站点》</p>\n<hr>\n<p><strong>历史系列</strong><br>《万历十五年》-【美】 黄仁宇<br>《明朝那些事儿》</p>\n<hr>\n<p><strong>编程语言系列</strong><br>《Python核心编程》<br>《Python Cookbook》<br>《编写高质量代码-Python的99个建议》<br>《STL源码剖析》<br>《Python自动化运维》</p>\n<hr>\n<p><strong>菊香书屋</strong><br>《自控力》-【美】 凯利·麦格尼格尔<br>《疯狂的简洁》-【美】 肯·西格尔<br>《数学之美》<br>《暗时间》<br>《销售无处不在》</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"文字是思想的载体-思想是语言的灵魂。\"><a href=\"#文字是思想的载体-思想是语言的灵魂。\" class=\"headerlink\" title=\"文字是思想的载体, 思想是语言的灵魂。\"></a>文字是思想的载体, 思想是语言的灵魂。</h1><blockquote>\n<p>为天地立心，为生民立命，为往圣继绝学，为万世开太平</p>\n</blockquote>\n<hr>\n<p><strong>正在读的书</strong><br>《自控力》-【美】 凯利·麦格尼格尔</p>\n<hr>\n<p><strong>哲学系列</strong><br>《中国哲学简史》-【中】 冯友兰<br>《道德经》-【中】 老子</p>\n<hr>\n<p><strong>财务金融经济系列</strong><br>《财务智慧》<br>《激荡三十年》-【中】 吴晓波</p>\n<hr>\n<p><strong>管理系列</strong><br>《卓有成效的管理者》<br>《大败局Ⅰ》-【中】 吴晓波<br>《大败局Ⅱ》-【中】 吴晓波<br>《马云管理日志》<br>《重新定义公司-谷歌是如何运营的》<br>《创业的36条军规》</p>\n<hr>\n<p><strong>人物传记系列</strong><br>《胡雪岩传》<br>《雷军传-站在风口上》<br>《诸时键-影响企业家的企业家》-【中】 先燕云</p>\n<hr>\n<p><strong>互联网系列</strong><br>《人人都是产品经理》- 【中】 苏杰<br>《互联网+ -从IT到DT》-【中】 阿里研究院<br>《社交红利》<br>《浪潮之巅》<br>《淘宝技术这十年》</p>\n<hr>\n<p><strong>计算机系列</strong><br>《构建高性能Web站点》</p>\n<hr>\n<p><strong>历史系列</strong><br>《万历十五年》-【美】 黄仁宇<br>《明朝那些事儿》</p>\n<hr>\n<p><strong>编程语言系列</strong><br>《Python核心编程》<br>《Python Cookbook》<br>《编写高质量代码-Python的99个建议》<br>《STL源码剖析》<br>《Python自动化运维》</p>\n<hr>\n<p><strong>菊香书屋</strong><br>《自控力》-【美】 凯利·麦格尼格尔<br>《疯狂的简洁》-【美】 肯·西格尔<br>《数学之美》<br>《暗时间》<br>《销售无处不在》</p>\n<hr>\n"}],"Post":[{"title":"Python葵花宝典","date":"2016-04-17T11:48:10.000Z","toc":true,"comments":1,"_content":"\n基础经济决定上层建筑，扎实的基础知识是优秀工程师的基石，本文记录一些零碎的Python的基础知识。\n> * 类、元类\n> * 函数\n> * Python的编码、乱码问题\n> * Python的__call__（前后双下划线）函数\n> * 识别编码的办法\n> * super函数\n> * os模块的文件对象操作部分\n> * 文件对象的读写\n\n<!--more-->\n\n# 类\n\n## **什么是类？类的特点是什么？**\n -  **类：** 类就是一组用来描述描述如何生成对象的代码段。**类就是能创建出类实例的对象。**\n - **类的特点：**Python中的类也是对象，只要使用关键字**class**，Python的解释器执行的时候就会在内存中创建一个对象，对象名就是类名。**这个对象（类）自身拥有创建对象（类实例）的能力**，这就是为什么称这个对象为类的原因。但是Python中的类本质上还是一个对象，所以Python中类可以：\n- 将类赋给一个变量\n- 可以拷贝类\n- 可以为他增加属性\n- 可以把类作为函数参数去传递\n- 类是对象，因此可以动态的去创建类\n- 示例：\n    ```python\n    class Foo(object):\n        pass\n    Foo.new_aut = 'lingyue'\n    foo = Foo()\n\n    def myClass(name):\n        if name == 'foo':\n            class Foo():\n                pass\n            return Foo\n        else:\n            class Bar():\n                pass\n            return Bar\n    s = myClass('foo')\n    x = myClass('bar')\n    ```\n\n - 类既然也是对象，那么这个类对象是谁创建的呢？\n    -  创建类的**元类**。\n## **什么是元类？元类的特点是什么？** [解释元类个人认为最好的文章链接](http://blog.jobbole.com/21351/)\n\n - **元类：**元类就是创建类（对象）的“东西”，即**元类就是类的类，可以理解为元类就是类工厂**。\n 记录开始\n\n## **\"__metaclass__\"属性是什么？这个属性有什么作用？**\n\n - **\"__metaclass__\"**属性的怎么用？\n\n# 函数\n## 函数参数传递说明\n### 传递参数带星号**(*)**\n在传递不确定个数的参数的时候，我们可能会使用（*args，**kwargs）来传递，那么使用星号和不使用星号去给函数传递参数有什么区别？\n```python\n>>> def func(*args):\n...     print args\n...     print args[0]\n...\n>>> a = ('lingyue','jiangtao')\n>>> func(a)\n(('lingyue', 'jiangtao'),)\n('lingyue', 'jiangtao')\n>>>\n>>> func(*a)\n('lingyue', 'jiangtao')\nlingyue\n>>>\n>>> func('lingyue','jiangtao')\n('lingyue', 'jiangtao')\nlingyue\n>>>\n```\n上面举例可以看出，当不使用星号给函数传递参数的时候，你是怎么传递的，那么函数接受到的参数就是什么样子的，比如上例子中的**func(a)**，传递进来后，函数接受到的就是你所传递的参数，例子中使用的是元组的方式去传递的；那么你用list做参数，函数还是会把参数作为元组去处理，就是说*args永远接受到的是一个元组：\n```python\n>>> func(['lingyue','jiangtao'])\n(['lingyue', 'jiangtao'],)\n['lingyue', 'jiangtao']\n>>> func(*['lingyue','jiangtao'])\n('lingyue', 'jiangtao')\nlingyue\n```\n\n那么当我们使用引用传参**(func(*a))**的时候，会发生什么呢？\n由上面的例子可以看到，使用引用传参的时候，函数解析器实际会把元组给解包，解析成len（a）个参数，它会把你传进去的参数解包成一个元组，而不是原封不动的接受。\n所以：\n```python\n>>> func(*a)\n('lingyue', 'jiangtao')\nlingyue\n```\n等价于\n```python\n>>> func('lingyue','jiangtao')#表示传递两个参数\n('lingyue', 'jiangtao')\nlingyue\n```\n\n# Python的编码、乱码问题\n\n## 为什么产生编码问题？\n计算机只能处理01编码，如果要处理非数字的数据结构，只能把其他数据结构转化为01编码，计算机才能处理。美国人在最初发明计算机的时候就把自己的一些字母，如a,b,A,D,以及一些特殊字符、数字等编码到计算机中，一共是127个字母被编译进去。**这个编码就是ASCII编码，**比如大写的A是65等。但是当计算机传入中国的时候，中国语言博大精深，*（计算机在设计时采用8个比特（bit）作为一个字节（byte）*，一个字节要处理中文显然是不够的，而且还不能与ASCII编码重复，至少需要两个字节才能处理一个汉字。所以，中国人就制作了中文的编码方式，就GB2312编码，把中文编译进去。\n那么，世界上有形形色色的语言，各国可能都有自己的语言，比如日文、韩文、法文等，各国都有自己的标准，这怎么通信，就比如货币如果没有比率做等价交换，各国就无法通币了，显然没有一个标准就会有各种冲突。于是乎，unicode就产生了。unicode就是一个各国编码的一个通用的桥梁，好比现在美元就是世界通用的货币，英语就是世界通用的语言，*（谁让美国佬强大呢，再过几十年，世界通用标准说不定就中国了）*。有了unicode这个通用编码标准，世界任何国家就可以通过这个编码进行转化，进而进行交流。\n**以上就是编码问题的由来和解决办法的知识的简单普及。**\n\n## unicode、UTF-8\n我们知道unicode就是一个通用的编码标准了，有了unicode，所有的乱码问题，语言不通问题就解决了。\n但是这就万事大吉了？No，上面我们介绍了，如果只是英语，也就是字符串，ASCII是够用的，美国人就是这么用的，只不过，中文博大精深，需要更多的编码字节罢了，至少需要两个字节。我们中国人自古以来，勤俭节约，计算机中什么最珍贵？肯定是CPU和内存嘛，那么问题来了，有个学渣，语文课不好好上，写篇作文，由于大多数汉字学了后都还给老师了，此贼通篇文章绝大多数都是拼音替代，也就是字符串，只有个别是汉字。\n此时如果你都用2个或者以上的字节去编码，显然不在信息存储上、信息传输上不合算呐，大多数比特位都是填充的0，要是你真这么编码，老师一定骂你是败家子了。\n此时聪明的中国人就想办法了，出现**UTF-8**编码，**所谓的UTF-8编码就是一种可变长度的unicode编码，**\nUTF-8编码把一个unicode字符根据不同的数字大小编码成1-6个字节，比如字符就用1个字节，简单中文就用2-3个字节，只有很生僻的字符才会被编码成4-6个字节，此时如果你把有大量字符中夹杂少量汉字的作文传输给老师的时候，就能节省不少的空间，存储和传输都节省不少呢。\n\n注意：\n通常python的文件的开头会这么写：\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n```\n第一行是遥告诉Linux系统，这是一个Python的可执行程序，window会忽略这行。\n第二行注释是为了告诉Python解释器，请按照UTF-8编码来读取源码，否则你在文件中可能就会看到乱码问题。\n**以上就是Unicode编码和UTF-8编码的简单介绍。**\n\n## 编码、解码\nPython紧跟潮流，也支持Unicode编码方式。Python 2.x的默认编码方式是ASCII方式。Python 3.x默认编码方式是unicode方式。str和unicode都是basestring的子类。严格意义上说，str其实是字节串，它是unicode经过编码后的字节组成的序列。对UTF-8编码的str'汉'使用len()函数时，结果是3，因为实际上，UTF-8编码的'汉'=='\\xE6\\xB1\\x89'。\n```python\nstr  -> decode('the_coding_of_str') -> unicode\nunicode -> encode('the_coding_you_want') -> str\n\n#s是code_A的str\ns.decode('code_A').encode('code_B') #不同编码转换,使用unicode作为中间编码\n```\n**unicode才是真正意义上的字符串，由字符组成；str是经过unicode经过编码后的字节组成的一个序列。所以不要对str使用编码(encode)，不要对unicode使用解码(decode),**虽然即使你使用了也不会报错，但是不建议这么做。\n\n字符串在Python内部的表示是unicode编码，因此，**在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。** 但是，Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。也因为这个根本原因，在Python2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。\n\n### 解码（decode）：\ndecode函数的作用是将其他编码的字符串转换成unicode编码，如str1.decode('gb2312')，表示将gb2312编码的字符串str1转换成unicode编码。\n\n### 编码（encode）:\nencode函数的作用是将unicode编码转换成其他编码的字符串，如str2.encode('utf-8')，表示将unicode编码的字符串str2编码成utf-8编码。\n\nencode、decode语法：\n```python\nstr.encode(encoding='UTF-8',errors='strict') #参数\nDecoded string #返回结果\n\nStr.decode(encoding='UTF-8',errors='strict') #参数\nDecoded string # 返回结果\n```\n编码解码使用举例：\n```python\n#! /usr/bin/env python\n#! -*-coding:utf-8-*-\nStr = \"this is string example....wow!!!\"\nStr = Str.encode('base64', 'strict')\n\nprint \"Encoded String: \" + Str\nprint \"Decoded String: \" + Str.decode('base64', 'strict')\n\n\n#输出结果：\nEncoded String: dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE=\nDecoded String: this is string example....wow!!!\n```\n\n### 编码问题常见异常总结：\n\n```python\n1、SyntaxError: Non-ASCII character #Python源文件中有非ASCII字符，但是同时没有声明编码格式。\n2、UnicodeDecodeError #将其他编码格式转换成unicode编码，但是字符本身的编码格式和decode传入的不相符。如下面：\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = '中文'\ns.decode('gb2312') # UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 2-3: illegal multibyte sequence\nprint s\n3、UnicodeEncodeError # 错误的使用decode和encode方法会出现这种异常，比如：使用decode方法将Unicode字符串转化的时候，如下面：\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = u'中文'\ns.decode('utf-8') # UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\nprint s\n```\n\n### 编码问题常见处理方法总结：\n\n\n - 遵循PEP标准，声明编码格式\n\n    ```python\n    #!/usr/bin/env python\n    # -*- coding: <encoding name> -*-\n    ```\n\n - 使用u'中文'替代'中文'\n\n    ```python\n    str1 = '中文'\n    str2 = u'中文'\n\n    #以上两种字符串变量的主要不同就是字符串编码不一致，str1的编码和Python声明的编码方式是一致的；str2的编码就是unicode格式。如果你的字符串变量中存在非ASCII字符，那么最好使用str2方式，这样你就不需要使用decode解码了，可以直接encode成你所需要的编码格式了，或者直接操作字符串了，避免异常情况出现。\n    ```\n\n - 使用人为的改变文本编码方式\n    ```python\n    import sys\n    reload(sys)\n    sys.setdefaultencoding('utf-8')\n    #以上三行代码可算是解决编码问题的万能钥匙了，几乎能解决所有的编码问题，但是它会带来一些负面影响。\n    ```\n - 先解码成unicode，再编码成所需的格式，decode early, unicode everywhere, encode late\n    ```python\n    #! /usr/bin/env python\n    #! -*-coding:utf-8-*-\n    Str = \"this is string example....wow!!!\"\n    Str = Str.encode('base64', 'strict')\n\n    print \"Encoded String: \" + Str\n    print \"Decoded String: \" + Str.decode('base64', 'strict')\n    ```\n\n**[sys.setdefaultencoding('utf-8')的弊端说明的最好的文章](http://blog.ernest.me/post/python-setdefaultencoding-unicode-bytes?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)**\n\n# Python的call（前后双下划线) 函数\n\n##概念\nPython中有很多小函数，很有意思，也很有用，比如今天讲的__call__函数。\n我们知道在调用一个类型的时候，必须先实例化，然后用对象去调用。但是如果这个类型中实现了__call__函数，那么这个类型就成为可调用的了，也就说，__call__函数相当于重载了括号运算符。\n\n## 举例\n\n - 类型中不实现__call__的时候，如下：\n\n```python\nclass Func(object):\n    def __init__(self, g):\n        self.g = g\n\n    def call(self, t):\n        return (self.g * t**2) / 2\n\ne_dpm = Func(2)\nseq =  e_dpm.call(22)\n```\n\n - 类型中实现了__call__函数的时候，调用可以如下：\n\n```python\nclass Func(object):\n    def __init__(self, g):\n        self.g = g\n\n    def __call__(self, t):\n        return (self.g * t**2) / 2\n\ne_dpm = Func(2)\n#一下两种方式都可以调用\nseq =  e_dpm(22)\nseq = e_dpm.__call__(22)\n```\n\n## __call__函数总结\n\n对象通过提供__call__(slef, [,*args [,**kwargs]])方法可以模拟函数的行为，即x(arg1, arg2...) 等同于调用x.__call__(self, arg1, arg2)\n\n# 识别编码的方法\n有时候在我们没有明确被告知某个字符串、文件等的编码的时候，我们需要识别编码。使用编码方式、编码范围等判断是可行的，比如常用字表等，可惜的是识别率太低了。\n这时候我们强大的Python就出来解决全人类了。python提供了一个第三方库，**chardet库**可以用来识别编码。\n## 识别编码库chardet库\nchardet库是个Python的第三方库，下面我们就来看看用法，很简单：\n\n```python\nimport chardet\n\nwith open('/path/file.txt',r) as f:\n    data = f.read()\nprint chardet.detect(data)\n\n#输出：返回值是一个dict，一个是检测的可信度，一个是检测到的编码\n{'confidence': 0.99, 'encoding': 'utf-8'}\n\n#当然也可以直接检测字符串等容器的编码\n>>> import chardet\n>>> s = 'zhong国'\n>>> print chardet.detect(s)\n{'confidence': 0.505, 'encoding': 'utf-8'}\n```\n**备注：[chardet官网](http://chardet.readthedocs.io/en/latest/api/chardet.html#module-chardet)**\n\n# 关于print\n## print输出文本中的中文\nPython中包含一个中文字符串的列表、字典、文件等的时候，直接print的时候，会出现以下情况：\n```python\n>>> dicts = {\"asdf\": \"学习Python，我们是认真的\"}\n>>> print dicts\n{'asdf': '\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'}\n\n#显然上述信息在处理的时候很不方便，此时只需要：\n\n>>> dicts = {\"asdf\": \"学习Python，我们是认真的\"}\n>>> print dicts\n{'asdf': '\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'}\n>>> import json\n>>> print json.dumps(dicts, encoding=\"UTF-8\", ensure_ascii=False)\n{\"asdf\": \"学习Python，我们是认真的\"}\n```\n\n## print的工作原理\n类UNIX系统中有标准输出和标准错误的说法（缩写为stdout、stderr），它们是建立在Unix系统内的管道（pipe）。对于Python来讲，当你输出的时候，结果就是输出到stdout管道中；当程序出错的时候，结果会输出到stderr管道中，而且**一般来讲这两个管道都是与你正在工作的终端窗口相联。**，当然如果你是在一个基于终端的Python IDE系统上工作，stedout和stderr是**缺省窗口**。\n\n### print会干什么？\n```python\n>>> for i in range(3):\n...     print 'Python2.%d'%i\n...\nPython2.0\nPython2.1\nPython2.2\n>>>\n>>> import sys\n>>> for i in range(3):\n...     sys.stdout.write('Python2.%d'%i)\n...\nPython2.0Python2.1Python2.2>>>\n>>>\n>>> for i in range(3):\n...     sys.stderr.write('Python2.%d'%i)\n...\nPython2.0Python2.1Python2.2>>>\n>>>\n```\n由上述测试可以得出如下结论：\n\n - stdout和stderr都是一个类文件对象，调用他的write，会打印出任何给出的字符串，**并且不加换行符的输出**。\n - stdout和sterr会把他们的输出发送到同一个地方：Python IDE或者终端（如果你正在终端运行Python）\n - **print所做的工作：**它在字符串末尾加上换行符，然后调用sys.stdout.write()\n\n\n### 类文件对象是什么？有什么特点？\nstdout、stderr都是类文件对象，**类文件对象是任意一个带有read方法的对象，**这个方法带一个可选的size参数，并返回一个字符串。当不用size参数调用时，它从输入源中读出所有东西，并将所有数据作为单个字符串返回。当使用size参数调用时，它从输入源中读出size大小的数据，并返回那些数据；当再次调用时，它从余下的地方开始并返回下一块数据。\n**虽然stdout、stderr是类文件对象，但是他比较特殊，它们只有write方法而没有read方法。**但是我们可以通过将他绑定到其他的类文件对象来得到不通的输出位置，默认是输出到屏幕。\n如：\n```python\nimport sys\nsaveout = sys.stdout\nfsock = open('out.log', 'w')\nsys.stdout = fsock\nprint 'This message will be logged instead of displayed'\nsys.stdout = saveout #要把stdout恢复回去，stderr一般不用恢复\nfsock.close()\n```\n\n# super()内建函数\n\n**首先声明一点，super是针对新式类的，不适用于经典类。**，这点一定要明确了。\n\n## 经典类怎么初始化继承类？\n\n先看个代码：\n```python\nclass Base(object):\n    def __init__(self):\n        print \"Base created\"\n\nclass ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        super(ChildB, self).__init__()\n\nprint ChildA()\nprint ChildB()\n\n#输出结果\nBase created\n<__main__.ChildA object at 0x7fcca2eafbd0>\nBase created\n<__main__.ChildB object at 0x7fcca2eafbd0>\n```\n由此看出，其实super和直接使用继承类去初始化没什么区别，但是你想想，当有一天，你突然想改名父类Base(object)为Root呢，那么对于子类来说，是不是全要改一次呢，显然，如果大量子类继承这个父类的话，你的代码怎么维护。所以使用super显而易见的作用就是维护成本小，当然，这仅仅是它显而易见的作用，还有其他的作用，下面来讲。\n\n## 新式类的super\n首先，要更深入的了解super，必须要先要了解**MRO（方法解析顺序）**。\n在支持多继承的编程语言中，其方法、属性有可能是定义在当前类中，也有可能是在继承类中，那么问题来了，当有多个继承的时候，比如class Child（root_A,root_B）,那么假如父类中有重复的方法和类，到底使用那个呢？所以必须在调用该方法前先要对当前类和继承类进行搜素，以确定方法所在的位置，而这种搜索顺序就是所谓的MRO。\n\n[MRO知识普及文章推荐](http://hanjianwei.com/2013/07/25/python-mro/),感谢作者。\n\n## super到底干了什么工作？\n\nsuper本质上干的工作：\n\n```python\ndef super(cls, inst):\n    mro = inst.__class__.mro()\n    return mro[mro.index(cls) + 1]\n```\n\n上述函数解读，也是super函数的本质：\n\n - **inst 负责生成 MRO 的 list**\n - **通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1]**\n\n是不是还有点丈二和尚摸不着头脑，不要紧，接下来，将举例说明上述函数：\n\n\n```python\nclass Root(object):\n    def __init__(self):\n        print(\"this is Root\")\nclass B(Root):\n    def __init__(self):\n        print(\"enter B\")\n        super(B, self).__init__()\n        print(\"leave B\")\nclass C(Root):\n    def __init__(self):\n        print(\"enter C\")\n        super(C, self).__init__()\n        print(\"leave C\")\nclass D(B, C):\n    pass\nd = D()\nprint(d.__class__.__mro__)\n\n#输出：\nenter B\nenter C\nthis is Root\nleave C\nleave B\n(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.Root'>, <type 'object'>)\n```\n\n\n有上述结果，我们能得到如下结论：\n\n - super和父类并没有直接的关联，而是指MRO中的下一个类。因为如果直接关联的话，打印出来的结果应该是B之后就是Root类了，但是实质上是C类，因此super是mro[index + 1]。\n - super会根据MRO逐个按顺序的去找__init__(前后双下划线，下同)构造函数，所以会先找自身，发现D没有__init__，接着去找B的，再去找C，再去找Root，再去找元类type。**在MRO中，基类永远出现在派生类后面，如果有多个基类，基类的相对顺序保持不变。**\n\n备注：\n上述举例代码中，我们如果给class B()中加二个打印的print，如下：\n```python\nclass B(Root):\n    def __init__(self):\n        print self.__class__\n        print self.__class__.__mro__\n        print(\"enter B\")\n        super(B, self).__init__()\n        print(\"leave B\")\n```\n猜猜输出的是什么？\n结果输出：\n```python\n<class '__main__.D'>\n(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.Root'>, <type 'object'>)\n```\n注意：self输出的是D的instance，而不是B的instance。\n\n# sorted排序\n\n内建函数sorted()可对**可迭代序列排序**，返回一个排好序的可迭代序列。\n\n## sorted函数：\n\n### sorted原型和参数\n源函数：\n```python\nsorted(...)\n    sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list\n```\n参数解析：\n\n - iterable：是可迭代类型;\n - cmp：用于比较的函数，比较什么由key决定,有默认值，迭代集合中的一项;\n - key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;\n - reverse：排序规则. reverse = True 或者 reverse = False，默认升序；\n - 返回值：是一个经过排序的可迭代类型，与iterable一样。\n\n### sorted和sort的区别\n\n - sort仅仅是list的一个方法，其他可迭代序列无此方法；sorted对所有的可迭代序列有效。\n - sort是就地排序，排完序后list的本身也改变了；sorted是生成一个新的排好序的序列。\n\n举例说明：\n```python\n>>> lists = [5,3,2,1,4,6]\n>>> sorted(lists)\n[1, 2, 3, 4, 5, 6]\n>>> lists\n[5, 3, 2, 1, 4, 6]\n>>> lists.sort()\n>>> lists\n[1, 2, 3, 4, 5, 6]\n```\n\n## sorted函数使用方法详解\n\nlist.sort()和sorted()都支持key参数，key参数指定一个函数或者表达式等，此函数在**每个元素比较前**被调用。此函数的参数只有一个，并且返回一个值来与其他元素做比较。\nkey指定的函数可以对每个元素快速的作用，所以这个速度其实是很快的。\n\n在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数，cmp参数指定的函数用来进行元素间的比较。python3.0以后这个参数被废除。\n\n比如：\n\n 1. 不区分大小写的进行排序：\n```python\n>>> sorted(\"This is a test string from Andrew\".split(), key=str.lower)\n['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']\n```\n 2. 按照年龄排队：\n```python\n>>> student_tuples = [\n...         ('john', 'A', 15),\n...         ('jane', 'B', 12),\n...         ('dave', 'B', 10),\n... ]\n>>> sorted(student_tuples, key=lambda student: student[2])\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n>>> sorted(student_tuples, key=lambda student: student[2],reverse=True)\n[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n>>>\n```\n 3. 调用cmp函数来比较大小：\n```python\n>>> def numeric_compare(x, y):\n...     return x - y\n...\n>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)\n[1, 2, 3, 4, 5]\n>>> def numeric_compare(x, y):\n...     return y - x\n...\n>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)\n[5, 4, 3, 2, 1]\n>>>\n```\n\n### 字典排序\n\n - 按照字典的value中排序：\n```python\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_value = sorted(x.iteritems(), key=lambda e: e[1])\nprint sorted_value\nsorte_values = sorted(x.iteritems(), key=lambda e: e[1], reverse=True)\nprint sorte_values\n\n#输出\n[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]\n[(3, 4), (4, 3), (1, 2), (2, 1), (0, 0)]\n```\n\n - list的元素是dict，排序：\n```python\nx = [{'name': 'Homer', 'age': 9}, {'name': 'Bart', 'age': 10}]\nvalues = sorted(x, key=lambda x: x['name'])\nvalue = sorted(x, key=lambda x: x['age'])\nprint values\nprint value\n\n#输出\n[{'age': 10, 'name': 'Bart'}, {'age': 9, 'name': 'Homer'}]\n[{'age': 9, 'name': 'Homer'}, {'age': 10, 'name': 'Bart'}]\n```\n\n - 按照字典value的某个元素排序：\n```python\nmyDict = {'item1': [7, 1, 9], 'item2': [8, 2, 3], 'item3': [9, 3, 11]}\n\ndef sortDic(Dict, valuePostion):\n    return sorted(Dict.items(), key=lambda e: e[1][valuePostion])\n\n# 按value的第3个值排序\nprint sortDic(myDict, 2)\n[('item2', [8, 2, 3]), ('item1', [7, 1, 9]), ('item3', [9, 3, 11])]\n\n# 按value的第1个值排序\nprint sortDic(myDict, 0)\n[('item1', [7, 1, 9]), ('item2', [8, 2, 3]), ('item3', [9, 3, 11])]\n```\n\n# with上下文管理器\n\n\n# 获取脚本的执行路径问题\nPython中有两种方法能获取到执行脚本的文件路径，一种是**\"__file__\"**，一种是**\"sys.argv[0]\"**。\n## 主执行文件，获取执行脚本路径\n在主执行文件中，**\"__file__\"**和sys.argv[0]区别不大，都是根据的到执行该脚本的方式不同，而得到绝对路径或者相对路径。\n如下所示：\n```python\n#! /usr/bin/env python\n#-*-coding:utf-8-*-\n\nimport sys\n\nprint \"__file__    -------->%s\"%__file__\nprint \"sys.argv[0] -------->%s\"%sys.argv[0]\n\n#输出结果：\n\"\"\"\n[root@localhost workspace]# ./test.py\n__file__    -------->./test.py\nsys.argv[0] -------->./test.py\n[root@localhost workspace]# /root/workspace/test.py\n__file__    -------->/root/workspace/test.py\nsys.argv[0] -------->/root/workspace/test.py\n[root@localhost workspace]# ~/workspace/test.py\n__file__    -------->/root/workspace/test.py\nsys.argv[0] -------->/root/workspace/test.py\n\"\"\"\n```\n由上面的测试可以看到，此两种获取路径的方式都是由执行脚本的方式不同，而结果是相对路径或者绝对路径，可以通过**os.path.abspath()**函数来取得执行脚本的绝对路径。\n以上说明**在主文件中执行的时候，这两种方式没什么区别。**\n\n## 非主执行文件，import其他文件，获取执行脚本路径\n```python\n# test_1.py脚本，主执行脚本\nimport sys\nimport os\nprint \"__file__    -------->%s\"%__file__\nprint \"sys.argv[0] -------->%s\"%sys.argv[0]\n\nimport test_2\ntest_2.show_path()\n\n# test_2.py脚本，供其他文件引入的脚本，非主执行文件\nimport sys\nimport os\n\ndef show_path():\n    print \"show_path:__file__    -------->%s\"%__file__\n    print \"show_path:sys.argv[0] -------->%s\"%sys.argv[0]\n\n#输出结果：\n\"\"\"\n__file__    -------->./test_1.py\nsys.argv[0] -------->./test_1.py\nshow_path:__file__    -------->/root/workspace/test_2.py\nshow_path:sys.argv[0] -------->./test_1.py\n\"\"\"\n```\n以上结果说明，**\"__file__\"**得到的不一定是主文件的执行路径，而是那个脚本中的**__file__**，则得到是那个脚本的路径，而**sys.argv[0]**得到的是永远是主执行文件的路径，这个很好理解，因为sys.argv[0]本质上就是脚本命令行的第一个参数，那么这个脚本是什么，肯定得到的第一个参数就是什么。\n\n**以上结果说明：当需要获取执行脚本的路径的时候，sys.argv[0]比__file__更靠谱一些。**\n\n[super解释非常好的博客](https://laike9m.com/blog/li-jie-python-super,70/)，感谢作者！\n","source":"_posts/Python葵花宝典.md","raw":"---\ntitle: Python葵花宝典\ndate: 2016-04-17 19:48:10\ntags: Python基础\ncategories: Python之聚石塔\ntoc: true\ncomments: true\n---\n\n基础经济决定上层建筑，扎实的基础知识是优秀工程师的基石，本文记录一些零碎的Python的基础知识。\n> * 类、元类\n> * 函数\n> * Python的编码、乱码问题\n> * Python的__call__（前后双下划线）函数\n> * 识别编码的办法\n> * super函数\n> * os模块的文件对象操作部分\n> * 文件对象的读写\n\n<!--more-->\n\n# 类\n\n## **什么是类？类的特点是什么？**\n -  **类：** 类就是一组用来描述描述如何生成对象的代码段。**类就是能创建出类实例的对象。**\n - **类的特点：**Python中的类也是对象，只要使用关键字**class**，Python的解释器执行的时候就会在内存中创建一个对象，对象名就是类名。**这个对象（类）自身拥有创建对象（类实例）的能力**，这就是为什么称这个对象为类的原因。但是Python中的类本质上还是一个对象，所以Python中类可以：\n- 将类赋给一个变量\n- 可以拷贝类\n- 可以为他增加属性\n- 可以把类作为函数参数去传递\n- 类是对象，因此可以动态的去创建类\n- 示例：\n    ```python\n    class Foo(object):\n        pass\n    Foo.new_aut = 'lingyue'\n    foo = Foo()\n\n    def myClass(name):\n        if name == 'foo':\n            class Foo():\n                pass\n            return Foo\n        else:\n            class Bar():\n                pass\n            return Bar\n    s = myClass('foo')\n    x = myClass('bar')\n    ```\n\n - 类既然也是对象，那么这个类对象是谁创建的呢？\n    -  创建类的**元类**。\n## **什么是元类？元类的特点是什么？** [解释元类个人认为最好的文章链接](http://blog.jobbole.com/21351/)\n\n - **元类：**元类就是创建类（对象）的“东西”，即**元类就是类的类，可以理解为元类就是类工厂**。\n 记录开始\n\n## **\"__metaclass__\"属性是什么？这个属性有什么作用？**\n\n - **\"__metaclass__\"**属性的怎么用？\n\n# 函数\n## 函数参数传递说明\n### 传递参数带星号**(*)**\n在传递不确定个数的参数的时候，我们可能会使用（*args，**kwargs）来传递，那么使用星号和不使用星号去给函数传递参数有什么区别？\n```python\n>>> def func(*args):\n...     print args\n...     print args[0]\n...\n>>> a = ('lingyue','jiangtao')\n>>> func(a)\n(('lingyue', 'jiangtao'),)\n('lingyue', 'jiangtao')\n>>>\n>>> func(*a)\n('lingyue', 'jiangtao')\nlingyue\n>>>\n>>> func('lingyue','jiangtao')\n('lingyue', 'jiangtao')\nlingyue\n>>>\n```\n上面举例可以看出，当不使用星号给函数传递参数的时候，你是怎么传递的，那么函数接受到的参数就是什么样子的，比如上例子中的**func(a)**，传递进来后，函数接受到的就是你所传递的参数，例子中使用的是元组的方式去传递的；那么你用list做参数，函数还是会把参数作为元组去处理，就是说*args永远接受到的是一个元组：\n```python\n>>> func(['lingyue','jiangtao'])\n(['lingyue', 'jiangtao'],)\n['lingyue', 'jiangtao']\n>>> func(*['lingyue','jiangtao'])\n('lingyue', 'jiangtao')\nlingyue\n```\n\n那么当我们使用引用传参**(func(*a))**的时候，会发生什么呢？\n由上面的例子可以看到，使用引用传参的时候，函数解析器实际会把元组给解包，解析成len（a）个参数，它会把你传进去的参数解包成一个元组，而不是原封不动的接受。\n所以：\n```python\n>>> func(*a)\n('lingyue', 'jiangtao')\nlingyue\n```\n等价于\n```python\n>>> func('lingyue','jiangtao')#表示传递两个参数\n('lingyue', 'jiangtao')\nlingyue\n```\n\n# Python的编码、乱码问题\n\n## 为什么产生编码问题？\n计算机只能处理01编码，如果要处理非数字的数据结构，只能把其他数据结构转化为01编码，计算机才能处理。美国人在最初发明计算机的时候就把自己的一些字母，如a,b,A,D,以及一些特殊字符、数字等编码到计算机中，一共是127个字母被编译进去。**这个编码就是ASCII编码，**比如大写的A是65等。但是当计算机传入中国的时候，中国语言博大精深，*（计算机在设计时采用8个比特（bit）作为一个字节（byte）*，一个字节要处理中文显然是不够的，而且还不能与ASCII编码重复，至少需要两个字节才能处理一个汉字。所以，中国人就制作了中文的编码方式，就GB2312编码，把中文编译进去。\n那么，世界上有形形色色的语言，各国可能都有自己的语言，比如日文、韩文、法文等，各国都有自己的标准，这怎么通信，就比如货币如果没有比率做等价交换，各国就无法通币了，显然没有一个标准就会有各种冲突。于是乎，unicode就产生了。unicode就是一个各国编码的一个通用的桥梁，好比现在美元就是世界通用的货币，英语就是世界通用的语言，*（谁让美国佬强大呢，再过几十年，世界通用标准说不定就中国了）*。有了unicode这个通用编码标准，世界任何国家就可以通过这个编码进行转化，进而进行交流。\n**以上就是编码问题的由来和解决办法的知识的简单普及。**\n\n## unicode、UTF-8\n我们知道unicode就是一个通用的编码标准了，有了unicode，所有的乱码问题，语言不通问题就解决了。\n但是这就万事大吉了？No，上面我们介绍了，如果只是英语，也就是字符串，ASCII是够用的，美国人就是这么用的，只不过，中文博大精深，需要更多的编码字节罢了，至少需要两个字节。我们中国人自古以来，勤俭节约，计算机中什么最珍贵？肯定是CPU和内存嘛，那么问题来了，有个学渣，语文课不好好上，写篇作文，由于大多数汉字学了后都还给老师了，此贼通篇文章绝大多数都是拼音替代，也就是字符串，只有个别是汉字。\n此时如果你都用2个或者以上的字节去编码，显然不在信息存储上、信息传输上不合算呐，大多数比特位都是填充的0，要是你真这么编码，老师一定骂你是败家子了。\n此时聪明的中国人就想办法了，出现**UTF-8**编码，**所谓的UTF-8编码就是一种可变长度的unicode编码，**\nUTF-8编码把一个unicode字符根据不同的数字大小编码成1-6个字节，比如字符就用1个字节，简单中文就用2-3个字节，只有很生僻的字符才会被编码成4-6个字节，此时如果你把有大量字符中夹杂少量汉字的作文传输给老师的时候，就能节省不少的空间，存储和传输都节省不少呢。\n\n注意：\n通常python的文件的开头会这么写：\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n```\n第一行是遥告诉Linux系统，这是一个Python的可执行程序，window会忽略这行。\n第二行注释是为了告诉Python解释器，请按照UTF-8编码来读取源码，否则你在文件中可能就会看到乱码问题。\n**以上就是Unicode编码和UTF-8编码的简单介绍。**\n\n## 编码、解码\nPython紧跟潮流，也支持Unicode编码方式。Python 2.x的默认编码方式是ASCII方式。Python 3.x默认编码方式是unicode方式。str和unicode都是basestring的子类。严格意义上说，str其实是字节串，它是unicode经过编码后的字节组成的序列。对UTF-8编码的str'汉'使用len()函数时，结果是3，因为实际上，UTF-8编码的'汉'=='\\xE6\\xB1\\x89'。\n```python\nstr  -> decode('the_coding_of_str') -> unicode\nunicode -> encode('the_coding_you_want') -> str\n\n#s是code_A的str\ns.decode('code_A').encode('code_B') #不同编码转换,使用unicode作为中间编码\n```\n**unicode才是真正意义上的字符串，由字符组成；str是经过unicode经过编码后的字节组成的一个序列。所以不要对str使用编码(encode)，不要对unicode使用解码(decode),**虽然即使你使用了也不会报错，但是不建议这么做。\n\n字符串在Python内部的表示是unicode编码，因此，**在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。** 但是，Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。也因为这个根本原因，在Python2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。\n\n### 解码（decode）：\ndecode函数的作用是将其他编码的字符串转换成unicode编码，如str1.decode('gb2312')，表示将gb2312编码的字符串str1转换成unicode编码。\n\n### 编码（encode）:\nencode函数的作用是将unicode编码转换成其他编码的字符串，如str2.encode('utf-8')，表示将unicode编码的字符串str2编码成utf-8编码。\n\nencode、decode语法：\n```python\nstr.encode(encoding='UTF-8',errors='strict') #参数\nDecoded string #返回结果\n\nStr.decode(encoding='UTF-8',errors='strict') #参数\nDecoded string # 返回结果\n```\n编码解码使用举例：\n```python\n#! /usr/bin/env python\n#! -*-coding:utf-8-*-\nStr = \"this is string example....wow!!!\"\nStr = Str.encode('base64', 'strict')\n\nprint \"Encoded String: \" + Str\nprint \"Decoded String: \" + Str.decode('base64', 'strict')\n\n\n#输出结果：\nEncoded String: dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE=\nDecoded String: this is string example....wow!!!\n```\n\n### 编码问题常见异常总结：\n\n```python\n1、SyntaxError: Non-ASCII character #Python源文件中有非ASCII字符，但是同时没有声明编码格式。\n2、UnicodeDecodeError #将其他编码格式转换成unicode编码，但是字符本身的编码格式和decode传入的不相符。如下面：\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = '中文'\ns.decode('gb2312') # UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 2-3: illegal multibyte sequence\nprint s\n3、UnicodeEncodeError # 错误的使用decode和encode方法会出现这种异常，比如：使用decode方法将Unicode字符串转化的时候，如下面：\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = u'中文'\ns.decode('utf-8') # UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\nprint s\n```\n\n### 编码问题常见处理方法总结：\n\n\n - 遵循PEP标准，声明编码格式\n\n    ```python\n    #!/usr/bin/env python\n    # -*- coding: <encoding name> -*-\n    ```\n\n - 使用u'中文'替代'中文'\n\n    ```python\n    str1 = '中文'\n    str2 = u'中文'\n\n    #以上两种字符串变量的主要不同就是字符串编码不一致，str1的编码和Python声明的编码方式是一致的；str2的编码就是unicode格式。如果你的字符串变量中存在非ASCII字符，那么最好使用str2方式，这样你就不需要使用decode解码了，可以直接encode成你所需要的编码格式了，或者直接操作字符串了，避免异常情况出现。\n    ```\n\n - 使用人为的改变文本编码方式\n    ```python\n    import sys\n    reload(sys)\n    sys.setdefaultencoding('utf-8')\n    #以上三行代码可算是解决编码问题的万能钥匙了，几乎能解决所有的编码问题，但是它会带来一些负面影响。\n    ```\n - 先解码成unicode，再编码成所需的格式，decode early, unicode everywhere, encode late\n    ```python\n    #! /usr/bin/env python\n    #! -*-coding:utf-8-*-\n    Str = \"this is string example....wow!!!\"\n    Str = Str.encode('base64', 'strict')\n\n    print \"Encoded String: \" + Str\n    print \"Decoded String: \" + Str.decode('base64', 'strict')\n    ```\n\n**[sys.setdefaultencoding('utf-8')的弊端说明的最好的文章](http://blog.ernest.me/post/python-setdefaultencoding-unicode-bytes?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)**\n\n# Python的call（前后双下划线) 函数\n\n##概念\nPython中有很多小函数，很有意思，也很有用，比如今天讲的__call__函数。\n我们知道在调用一个类型的时候，必须先实例化，然后用对象去调用。但是如果这个类型中实现了__call__函数，那么这个类型就成为可调用的了，也就说，__call__函数相当于重载了括号运算符。\n\n## 举例\n\n - 类型中不实现__call__的时候，如下：\n\n```python\nclass Func(object):\n    def __init__(self, g):\n        self.g = g\n\n    def call(self, t):\n        return (self.g * t**2) / 2\n\ne_dpm = Func(2)\nseq =  e_dpm.call(22)\n```\n\n - 类型中实现了__call__函数的时候，调用可以如下：\n\n```python\nclass Func(object):\n    def __init__(self, g):\n        self.g = g\n\n    def __call__(self, t):\n        return (self.g * t**2) / 2\n\ne_dpm = Func(2)\n#一下两种方式都可以调用\nseq =  e_dpm(22)\nseq = e_dpm.__call__(22)\n```\n\n## __call__函数总结\n\n对象通过提供__call__(slef, [,*args [,**kwargs]])方法可以模拟函数的行为，即x(arg1, arg2...) 等同于调用x.__call__(self, arg1, arg2)\n\n# 识别编码的方法\n有时候在我们没有明确被告知某个字符串、文件等的编码的时候，我们需要识别编码。使用编码方式、编码范围等判断是可行的，比如常用字表等，可惜的是识别率太低了。\n这时候我们强大的Python就出来解决全人类了。python提供了一个第三方库，**chardet库**可以用来识别编码。\n## 识别编码库chardet库\nchardet库是个Python的第三方库，下面我们就来看看用法，很简单：\n\n```python\nimport chardet\n\nwith open('/path/file.txt',r) as f:\n    data = f.read()\nprint chardet.detect(data)\n\n#输出：返回值是一个dict，一个是检测的可信度，一个是检测到的编码\n{'confidence': 0.99, 'encoding': 'utf-8'}\n\n#当然也可以直接检测字符串等容器的编码\n>>> import chardet\n>>> s = 'zhong国'\n>>> print chardet.detect(s)\n{'confidence': 0.505, 'encoding': 'utf-8'}\n```\n**备注：[chardet官网](http://chardet.readthedocs.io/en/latest/api/chardet.html#module-chardet)**\n\n# 关于print\n## print输出文本中的中文\nPython中包含一个中文字符串的列表、字典、文件等的时候，直接print的时候，会出现以下情况：\n```python\n>>> dicts = {\"asdf\": \"学习Python，我们是认真的\"}\n>>> print dicts\n{'asdf': '\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'}\n\n#显然上述信息在处理的时候很不方便，此时只需要：\n\n>>> dicts = {\"asdf\": \"学习Python，我们是认真的\"}\n>>> print dicts\n{'asdf': '\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'}\n>>> import json\n>>> print json.dumps(dicts, encoding=\"UTF-8\", ensure_ascii=False)\n{\"asdf\": \"学习Python，我们是认真的\"}\n```\n\n## print的工作原理\n类UNIX系统中有标准输出和标准错误的说法（缩写为stdout、stderr），它们是建立在Unix系统内的管道（pipe）。对于Python来讲，当你输出的时候，结果就是输出到stdout管道中；当程序出错的时候，结果会输出到stderr管道中，而且**一般来讲这两个管道都是与你正在工作的终端窗口相联。**，当然如果你是在一个基于终端的Python IDE系统上工作，stedout和stderr是**缺省窗口**。\n\n### print会干什么？\n```python\n>>> for i in range(3):\n...     print 'Python2.%d'%i\n...\nPython2.0\nPython2.1\nPython2.2\n>>>\n>>> import sys\n>>> for i in range(3):\n...     sys.stdout.write('Python2.%d'%i)\n...\nPython2.0Python2.1Python2.2>>>\n>>>\n>>> for i in range(3):\n...     sys.stderr.write('Python2.%d'%i)\n...\nPython2.0Python2.1Python2.2>>>\n>>>\n```\n由上述测试可以得出如下结论：\n\n - stdout和stderr都是一个类文件对象，调用他的write，会打印出任何给出的字符串，**并且不加换行符的输出**。\n - stdout和sterr会把他们的输出发送到同一个地方：Python IDE或者终端（如果你正在终端运行Python）\n - **print所做的工作：**它在字符串末尾加上换行符，然后调用sys.stdout.write()\n\n\n### 类文件对象是什么？有什么特点？\nstdout、stderr都是类文件对象，**类文件对象是任意一个带有read方法的对象，**这个方法带一个可选的size参数，并返回一个字符串。当不用size参数调用时，它从输入源中读出所有东西，并将所有数据作为单个字符串返回。当使用size参数调用时，它从输入源中读出size大小的数据，并返回那些数据；当再次调用时，它从余下的地方开始并返回下一块数据。\n**虽然stdout、stderr是类文件对象，但是他比较特殊，它们只有write方法而没有read方法。**但是我们可以通过将他绑定到其他的类文件对象来得到不通的输出位置，默认是输出到屏幕。\n如：\n```python\nimport sys\nsaveout = sys.stdout\nfsock = open('out.log', 'w')\nsys.stdout = fsock\nprint 'This message will be logged instead of displayed'\nsys.stdout = saveout #要把stdout恢复回去，stderr一般不用恢复\nfsock.close()\n```\n\n# super()内建函数\n\n**首先声明一点，super是针对新式类的，不适用于经典类。**，这点一定要明确了。\n\n## 经典类怎么初始化继承类？\n\n先看个代码：\n```python\nclass Base(object):\n    def __init__(self):\n        print \"Base created\"\n\nclass ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        super(ChildB, self).__init__()\n\nprint ChildA()\nprint ChildB()\n\n#输出结果\nBase created\n<__main__.ChildA object at 0x7fcca2eafbd0>\nBase created\n<__main__.ChildB object at 0x7fcca2eafbd0>\n```\n由此看出，其实super和直接使用继承类去初始化没什么区别，但是你想想，当有一天，你突然想改名父类Base(object)为Root呢，那么对于子类来说，是不是全要改一次呢，显然，如果大量子类继承这个父类的话，你的代码怎么维护。所以使用super显而易见的作用就是维护成本小，当然，这仅仅是它显而易见的作用，还有其他的作用，下面来讲。\n\n## 新式类的super\n首先，要更深入的了解super，必须要先要了解**MRO（方法解析顺序）**。\n在支持多继承的编程语言中，其方法、属性有可能是定义在当前类中，也有可能是在继承类中，那么问题来了，当有多个继承的时候，比如class Child（root_A,root_B）,那么假如父类中有重复的方法和类，到底使用那个呢？所以必须在调用该方法前先要对当前类和继承类进行搜素，以确定方法所在的位置，而这种搜索顺序就是所谓的MRO。\n\n[MRO知识普及文章推荐](http://hanjianwei.com/2013/07/25/python-mro/),感谢作者。\n\n## super到底干了什么工作？\n\nsuper本质上干的工作：\n\n```python\ndef super(cls, inst):\n    mro = inst.__class__.mro()\n    return mro[mro.index(cls) + 1]\n```\n\n上述函数解读，也是super函数的本质：\n\n - **inst 负责生成 MRO 的 list**\n - **通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1]**\n\n是不是还有点丈二和尚摸不着头脑，不要紧，接下来，将举例说明上述函数：\n\n\n```python\nclass Root(object):\n    def __init__(self):\n        print(\"this is Root\")\nclass B(Root):\n    def __init__(self):\n        print(\"enter B\")\n        super(B, self).__init__()\n        print(\"leave B\")\nclass C(Root):\n    def __init__(self):\n        print(\"enter C\")\n        super(C, self).__init__()\n        print(\"leave C\")\nclass D(B, C):\n    pass\nd = D()\nprint(d.__class__.__mro__)\n\n#输出：\nenter B\nenter C\nthis is Root\nleave C\nleave B\n(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.Root'>, <type 'object'>)\n```\n\n\n有上述结果，我们能得到如下结论：\n\n - super和父类并没有直接的关联，而是指MRO中的下一个类。因为如果直接关联的话，打印出来的结果应该是B之后就是Root类了，但是实质上是C类，因此super是mro[index + 1]。\n - super会根据MRO逐个按顺序的去找__init__(前后双下划线，下同)构造函数，所以会先找自身，发现D没有__init__，接着去找B的，再去找C，再去找Root，再去找元类type。**在MRO中，基类永远出现在派生类后面，如果有多个基类，基类的相对顺序保持不变。**\n\n备注：\n上述举例代码中，我们如果给class B()中加二个打印的print，如下：\n```python\nclass B(Root):\n    def __init__(self):\n        print self.__class__\n        print self.__class__.__mro__\n        print(\"enter B\")\n        super(B, self).__init__()\n        print(\"leave B\")\n```\n猜猜输出的是什么？\n结果输出：\n```python\n<class '__main__.D'>\n(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.Root'>, <type 'object'>)\n```\n注意：self输出的是D的instance，而不是B的instance。\n\n# sorted排序\n\n内建函数sorted()可对**可迭代序列排序**，返回一个排好序的可迭代序列。\n\n## sorted函数：\n\n### sorted原型和参数\n源函数：\n```python\nsorted(...)\n    sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list\n```\n参数解析：\n\n - iterable：是可迭代类型;\n - cmp：用于比较的函数，比较什么由key决定,有默认值，迭代集合中的一项;\n - key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;\n - reverse：排序规则. reverse = True 或者 reverse = False，默认升序；\n - 返回值：是一个经过排序的可迭代类型，与iterable一样。\n\n### sorted和sort的区别\n\n - sort仅仅是list的一个方法，其他可迭代序列无此方法；sorted对所有的可迭代序列有效。\n - sort是就地排序，排完序后list的本身也改变了；sorted是生成一个新的排好序的序列。\n\n举例说明：\n```python\n>>> lists = [5,3,2,1,4,6]\n>>> sorted(lists)\n[1, 2, 3, 4, 5, 6]\n>>> lists\n[5, 3, 2, 1, 4, 6]\n>>> lists.sort()\n>>> lists\n[1, 2, 3, 4, 5, 6]\n```\n\n## sorted函数使用方法详解\n\nlist.sort()和sorted()都支持key参数，key参数指定一个函数或者表达式等，此函数在**每个元素比较前**被调用。此函数的参数只有一个，并且返回一个值来与其他元素做比较。\nkey指定的函数可以对每个元素快速的作用，所以这个速度其实是很快的。\n\n在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数，cmp参数指定的函数用来进行元素间的比较。python3.0以后这个参数被废除。\n\n比如：\n\n 1. 不区分大小写的进行排序：\n```python\n>>> sorted(\"This is a test string from Andrew\".split(), key=str.lower)\n['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']\n```\n 2. 按照年龄排队：\n```python\n>>> student_tuples = [\n...         ('john', 'A', 15),\n...         ('jane', 'B', 12),\n...         ('dave', 'B', 10),\n... ]\n>>> sorted(student_tuples, key=lambda student: student[2])\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n>>> sorted(student_tuples, key=lambda student: student[2],reverse=True)\n[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n>>>\n```\n 3. 调用cmp函数来比较大小：\n```python\n>>> def numeric_compare(x, y):\n...     return x - y\n...\n>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)\n[1, 2, 3, 4, 5]\n>>> def numeric_compare(x, y):\n...     return y - x\n...\n>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)\n[5, 4, 3, 2, 1]\n>>>\n```\n\n### 字典排序\n\n - 按照字典的value中排序：\n```python\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_value = sorted(x.iteritems(), key=lambda e: e[1])\nprint sorted_value\nsorte_values = sorted(x.iteritems(), key=lambda e: e[1], reverse=True)\nprint sorte_values\n\n#输出\n[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]\n[(3, 4), (4, 3), (1, 2), (2, 1), (0, 0)]\n```\n\n - list的元素是dict，排序：\n```python\nx = [{'name': 'Homer', 'age': 9}, {'name': 'Bart', 'age': 10}]\nvalues = sorted(x, key=lambda x: x['name'])\nvalue = sorted(x, key=lambda x: x['age'])\nprint values\nprint value\n\n#输出\n[{'age': 10, 'name': 'Bart'}, {'age': 9, 'name': 'Homer'}]\n[{'age': 9, 'name': 'Homer'}, {'age': 10, 'name': 'Bart'}]\n```\n\n - 按照字典value的某个元素排序：\n```python\nmyDict = {'item1': [7, 1, 9], 'item2': [8, 2, 3], 'item3': [9, 3, 11]}\n\ndef sortDic(Dict, valuePostion):\n    return sorted(Dict.items(), key=lambda e: e[1][valuePostion])\n\n# 按value的第3个值排序\nprint sortDic(myDict, 2)\n[('item2', [8, 2, 3]), ('item1', [7, 1, 9]), ('item3', [9, 3, 11])]\n\n# 按value的第1个值排序\nprint sortDic(myDict, 0)\n[('item1', [7, 1, 9]), ('item2', [8, 2, 3]), ('item3', [9, 3, 11])]\n```\n\n# with上下文管理器\n\n\n# 获取脚本的执行路径问题\nPython中有两种方法能获取到执行脚本的文件路径，一种是**\"__file__\"**，一种是**\"sys.argv[0]\"**。\n## 主执行文件，获取执行脚本路径\n在主执行文件中，**\"__file__\"**和sys.argv[0]区别不大，都是根据的到执行该脚本的方式不同，而得到绝对路径或者相对路径。\n如下所示：\n```python\n#! /usr/bin/env python\n#-*-coding:utf-8-*-\n\nimport sys\n\nprint \"__file__    -------->%s\"%__file__\nprint \"sys.argv[0] -------->%s\"%sys.argv[0]\n\n#输出结果：\n\"\"\"\n[root@localhost workspace]# ./test.py\n__file__    -------->./test.py\nsys.argv[0] -------->./test.py\n[root@localhost workspace]# /root/workspace/test.py\n__file__    -------->/root/workspace/test.py\nsys.argv[0] -------->/root/workspace/test.py\n[root@localhost workspace]# ~/workspace/test.py\n__file__    -------->/root/workspace/test.py\nsys.argv[0] -------->/root/workspace/test.py\n\"\"\"\n```\n由上面的测试可以看到，此两种获取路径的方式都是由执行脚本的方式不同，而结果是相对路径或者绝对路径，可以通过**os.path.abspath()**函数来取得执行脚本的绝对路径。\n以上说明**在主文件中执行的时候，这两种方式没什么区别。**\n\n## 非主执行文件，import其他文件，获取执行脚本路径\n```python\n# test_1.py脚本，主执行脚本\nimport sys\nimport os\nprint \"__file__    -------->%s\"%__file__\nprint \"sys.argv[0] -------->%s\"%sys.argv[0]\n\nimport test_2\ntest_2.show_path()\n\n# test_2.py脚本，供其他文件引入的脚本，非主执行文件\nimport sys\nimport os\n\ndef show_path():\n    print \"show_path:__file__    -------->%s\"%__file__\n    print \"show_path:sys.argv[0] -------->%s\"%sys.argv[0]\n\n#输出结果：\n\"\"\"\n__file__    -------->./test_1.py\nsys.argv[0] -------->./test_1.py\nshow_path:__file__    -------->/root/workspace/test_2.py\nshow_path:sys.argv[0] -------->./test_1.py\n\"\"\"\n```\n以上结果说明，**\"__file__\"**得到的不一定是主文件的执行路径，而是那个脚本中的**__file__**，则得到是那个脚本的路径，而**sys.argv[0]**得到的是永远是主执行文件的路径，这个很好理解，因为sys.argv[0]本质上就是脚本命令行的第一个参数，那么这个脚本是什么，肯定得到的第一个参数就是什么。\n\n**以上结果说明：当需要获取执行脚本的路径的时候，sys.argv[0]比__file__更靠谱一些。**\n\n[super解释非常好的博客](https://laike9m.com/blog/li-jie-python-super,70/)，感谢作者！\n","slug":"Python葵花宝典","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoiron40000ta02q7pi09gl","content":"<p>基础经济决定上层建筑，扎实的基础知识是优秀工程师的基石，本文记录一些零碎的Python的基础知识。</p>\n<blockquote>\n<ul>\n<li>类、元类</li>\n<li>函数</li>\n<li>Python的编码、乱码问题</li>\n<li>Python的<strong>call</strong>（前后双下划线）函数</li>\n<li>识别编码的办法</li>\n<li>super函数</li>\n<li>os模块的文件对象操作部分</li>\n<li>文件对象的读写</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"什么是类？类的特点是什么？\"><a href=\"#什么是类？类的特点是什么？\" class=\"headerlink\" title=\"什么是类？类的特点是什么？\"></a><strong>什么是类？类的特点是什么？</strong></h2><ul>\n<li><strong>类：</strong> 类就是一组用来描述描述如何生成对象的代码段。<strong>类就是能创建出类实例的对象。</strong></li>\n<li><p><strong>类的特点：</strong>Python中的类也是对象，只要使用关键字<strong>class</strong>，Python的解释器执行的时候就会在内存中创建一个对象，对象名就是类名。<strong>这个对象（类）自身拥有创建对象（类实例）的能力</strong>，这就是为什么称这个对象为类的原因。但是Python中的类本质上还是一个对象，所以Python中类可以：</p>\n<ul>\n<li>将类赋给一个变量</li>\n<li>可以拷贝类</li>\n<li>可以为他增加属性</li>\n<li>可以把类作为函数参数去传递</li>\n<li>类是对象，因此可以动态的去创建类</li>\n<li>示例：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\">Foo.new_aut = <span class=\"string\">'lingyue'</span></div><div class=\"line\">foo = Foo()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myClass</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> name == <span class=\"string\">'foo'</span>:</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">()</span>:</span></div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\">        <span class=\"keyword\">return</span> Foo</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span><span class=\"params\">()</span>:</span></div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\">        <span class=\"keyword\">return</span> Bar</div><div class=\"line\">s = myClass(<span class=\"string\">'foo'</span>)</div><div class=\"line\">x = myClass(<span class=\"string\">'bar'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>类既然也是对象，那么这个类对象是谁创建的呢？</p>\n<ul>\n<li>创建类的<strong>元类</strong>。<h2 id=\"什么是元类？元类的特点是什么？-解释元类个人认为最好的文章链接\"><a href=\"#什么是元类？元类的特点是什么？-解释元类个人认为最好的文章链接\" class=\"headerlink\" title=\"什么是元类？元类的特点是什么？ 解释元类个人认为最好的文章链接\"></a><strong>什么是元类？元类的特点是什么？</strong> <a href=\"http://blog.jobbole.com/21351/\" target=\"_blank\" rel=\"external\">解释元类个人认为最好的文章链接</a></h2></li>\n</ul>\n</li>\n<li><p><strong>元类：</strong>元类就是创建类（对象）的“东西”，即<strong>元类就是类的类，可以理解为元类就是类工厂</strong>。<br>记录开始</p>\n</li>\n</ul>\n<h2 id=\"“metaclass“属性是什么？这个属性有什么作用？\"><a href=\"#“metaclass“属性是什么？这个属性有什么作用？\" class=\"headerlink\" title=\"“metaclass“属性是什么？这个属性有什么作用？\"></a><strong>“<strong>metaclass</strong>“属性是什么？这个属性有什么作用？</strong></h2><ul>\n<li><strong>“<strong>metaclass</strong>“</strong>属性的怎么用？</li>\n</ul>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"函数参数传递说明\"><a href=\"#函数参数传递说明\" class=\"headerlink\" title=\"函数参数传递说明\"></a>函数参数传递说明</h2><h3 id=\"传递参数带星号\"><a href=\"#传递参数带星号\" class=\"headerlink\" title=\"传递参数带星号(*)\"></a>传递参数带星号<strong>(*)</strong></h3><p>在传递不确定个数的参数的时候，我们可能会使用（<em>args，*</em>kwargs）来传递，那么使用星号和不使用星号去给函数传递参数有什么区别？<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(*args)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">print</span> args</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">print</span> args[<span class=\"number\">0</span>]</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = (<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(a)</div><div class=\"line\">((<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>),)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(*a)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<p>上面举例可以看出，当不使用星号给函数传递参数的时候，你是怎么传递的，那么函数接受到的参数就是什么样子的，比如上例子中的<strong>func(a)</strong>，传递进来后，函数接受到的就是你所传递的参数，例子中使用的是元组的方式去传递的；那么你用list做参数，函数还是会把参数作为元组去处理，就是说*args永远接受到的是一个元组：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func([<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>])</div><div class=\"line\">([<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>],)</div><div class=\"line\">[<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(*[<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>])</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div></pre></td></tr></table></figure></p>\n<p>那么当我们使用引用传参<strong>(func(*a))</strong>的时候，会发生什么呢？<br>由上面的例子可以看到，使用引用传参的时候，函数解析器实际会把元组给解包，解析成len（a）个参数，它会把你传进去的参数解包成一个元组，而不是原封不动的接受。<br>所以：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(*a)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div></pre></td></tr></table></figure></p>\n<p>等价于<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>)<span class=\"comment\">#表示传递两个参数</span></div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div></pre></td></tr></table></figure></p>\n<h1 id=\"Python的编码、乱码问题\"><a href=\"#Python的编码、乱码问题\" class=\"headerlink\" title=\"Python的编码、乱码问题\"></a>Python的编码、乱码问题</h1><h2 id=\"为什么产生编码问题？\"><a href=\"#为什么产生编码问题？\" class=\"headerlink\" title=\"为什么产生编码问题？\"></a>为什么产生编码问题？</h2><p>计算机只能处理01编码，如果要处理非数字的数据结构，只能把其他数据结构转化为01编码，计算机才能处理。美国人在最初发明计算机的时候就把自己的一些字母，如a,b,A,D,以及一些特殊字符、数字等编码到计算机中，一共是127个字母被编译进去。<strong>这个编码就是ASCII编码，</strong>比如大写的A是65等。但是当计算机传入中国的时候，中国语言博大精深，<em>（计算机在设计时采用8个比特（bit）作为一个字节（byte）</em>，一个字节要处理中文显然是不够的，而且还不能与ASCII编码重复，至少需要两个字节才能处理一个汉字。所以，中国人就制作了中文的编码方式，就GB2312编码，把中文编译进去。<br>那么，世界上有形形色色的语言，各国可能都有自己的语言，比如日文、韩文、法文等，各国都有自己的标准，这怎么通信，就比如货币如果没有比率做等价交换，各国就无法通币了，显然没有一个标准就会有各种冲突。于是乎，unicode就产生了。unicode就是一个各国编码的一个通用的桥梁，好比现在美元就是世界通用的货币，英语就是世界通用的语言，<em>（谁让美国佬强大呢，再过几十年，世界通用标准说不定就中国了）</em>。有了unicode这个通用编码标准，世界任何国家就可以通过这个编码进行转化，进而进行交流。<br><strong>以上就是编码问题的由来和解决办法的知识的简单普及。</strong></p>\n<h2 id=\"unicode、UTF-8\"><a href=\"#unicode、UTF-8\" class=\"headerlink\" title=\"unicode、UTF-8\"></a>unicode、UTF-8</h2><p>我们知道unicode就是一个通用的编码标准了，有了unicode，所有的乱码问题，语言不通问题就解决了。<br>但是这就万事大吉了？No，上面我们介绍了，如果只是英语，也就是字符串，ASCII是够用的，美国人就是这么用的，只不过，中文博大精深，需要更多的编码字节罢了，至少需要两个字节。我们中国人自古以来，勤俭节约，计算机中什么最珍贵？肯定是CPU和内存嘛，那么问题来了，有个学渣，语文课不好好上，写篇作文，由于大多数汉字学了后都还给老师了，此贼通篇文章绝大多数都是拼音替代，也就是字符串，只有个别是汉字。<br>此时如果你都用2个或者以上的字节去编码，显然不在信息存储上、信息传输上不合算呐，大多数比特位都是填充的0，要是你真这么编码，老师一定骂你是败家子了。<br>此时聪明的中国人就想办法了，出现<strong>UTF-8</strong>编码，<strong>所谓的UTF-8编码就是一种可变长度的unicode编码，</strong><br>UTF-8编码把一个unicode字符根据不同的数字大小编码成1-6个字节，比如字符就用1个字节，简单中文就用2-3个字节，只有很生僻的字符才会被编码成4-6个字节，此时如果你把有大量字符中夹杂少量汉字的作文传输给老师的时候，就能节省不少的空间，存储和传输都节省不少呢。</p>\n<p>注意：<br>通常python的文件的开头会这么写：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure></p>\n<p>第一行是遥告诉Linux系统，这是一个Python的可执行程序，window会忽略这行。<br>第二行注释是为了告诉Python解释器，请按照UTF-8编码来读取源码，否则你在文件中可能就会看到乱码问题。<br><strong>以上就是Unicode编码和UTF-8编码的简单介绍。</strong></p>\n<h2 id=\"编码、解码\"><a href=\"#编码、解码\" class=\"headerlink\" title=\"编码、解码\"></a>编码、解码</h2><p>Python紧跟潮流，也支持Unicode编码方式。Python 2.x的默认编码方式是ASCII方式。Python 3.x默认编码方式是unicode方式。str和unicode都是basestring的子类。严格意义上说，str其实是字节串，它是unicode经过编码后的字节组成的序列。对UTF-8编码的str’汉’使用len()函数时，结果是3，因为实际上，UTF-8编码的’汉’==’\\xE6\\xB1\\x89’。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">str  -&gt; decode('the_coding_of_str') -&gt; unicode</div><div class=\"line\">unicode -&gt; encode('the_coding_you_want') -&gt; str</div><div class=\"line\"></div><div class=\"line\">#s是code_A的str</div><div class=\"line\">s.decode('code_A').encode('code_B') #不同编码转换,使用unicode作为中间编码</div></pre></td></tr></table></figure></p>\n<p><strong>unicode才是真正意义上的字符串，由字符组成；str是经过unicode经过编码后的字节组成的一个序列。所以不要对str使用编码(encode)，不要对unicode使用解码(decode),</strong>虽然即使你使用了也不会报错，但是不建议这么做。</p>\n<p>字符串在Python内部的表示是unicode编码，因此，<strong>在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。</strong> 但是，Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。也因为这个根本原因，在Python2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。</p>\n<h3 id=\"解码（decode）：\"><a href=\"#解码（decode）：\" class=\"headerlink\" title=\"解码（decode）：\"></a>解码（decode）：</h3><p>decode函数的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘gb2312’)，表示将gb2312编码的字符串str1转换成unicode编码。</p>\n<h3 id=\"编码（encode）\"><a href=\"#编码（encode）\" class=\"headerlink\" title=\"编码（encode）:\"></a>编码（encode）:</h3><p>encode函数的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘utf-8’)，表示将unicode编码的字符串str2编码成utf-8编码。</p>\n<p>encode、decode语法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.encode(encoding=<span class=\"string\">'UTF-8'</span>,errors=<span class=\"string\">'strict'</span>) <span class=\"comment\">#参数</span></div><div class=\"line\">Decoded string <span class=\"comment\">#返回结果</span></div><div class=\"line\"></div><div class=\"line\">Str.decode(encoding=<span class=\"string\">'UTF-8'</span>,errors=<span class=\"string\">'strict'</span>) <span class=\"comment\">#参数</span></div><div class=\"line\">Decoded string <span class=\"comment\"># 返回结果</span></div></pre></td></tr></table></figure></p>\n<p>编码解码使用举例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#! -*-coding:utf-8-*-</span></div><div class=\"line\">Str = <span class=\"string\">\"this is string example....wow!!!\"</span></div><div class=\"line\">Str = Str.encode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Encoded String: \"</span> + Str</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Decoded String: \"</span> + Str.decode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果：</span></div><div class=\"line\">Encoded String: dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE=</div><div class=\"line\">Decoded String: this <span class=\"keyword\">is</span> string example....wow!!!</div></pre></td></tr></table></figure></p>\n<h3 id=\"编码问题常见异常总结：\"><a href=\"#编码问题常见异常总结：\" class=\"headerlink\" title=\"编码问题常见异常总结：\"></a>编码问题常见异常总结：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>、SyntaxError: Non-ASCII character <span class=\"comment\">#Python源文件中有非ASCII字符，但是同时没有声明编码格式。</span></div><div class=\"line\"><span class=\"number\">2</span>、UnicodeDecodeError <span class=\"comment\">#将其他编码格式转换成unicode编码，但是字符本身的编码格式和decode传入的不相符。如下面：</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\">s = <span class=\"string\">'中文'</span></div><div class=\"line\">s.decode(<span class=\"string\">'gb2312'</span>) <span class=\"comment\"># UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 2-3: illegal multibyte sequence</span></div><div class=\"line\"><span class=\"keyword\">print</span> s</div><div class=\"line\"><span class=\"number\">3</span>、UnicodeEncodeError <span class=\"comment\"># 错误的使用decode和encode方法会出现这种异常，比如：使用decode方法将Unicode字符串转化的时候，如下面：</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\">s = <span class=\"string\">u'中文'</span></div><div class=\"line\">s.decode(<span class=\"string\">'utf-8'</span>) <span class=\"comment\"># UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</span></div><div class=\"line\"><span class=\"keyword\">print</span> s</div></pre></td></tr></table></figure>\n<h3 id=\"编码问题常见处理方法总结：\"><a href=\"#编码问题常见处理方法总结：\" class=\"headerlink\" title=\"编码问题常见处理方法总结：\"></a>编码问题常见处理方法总结：</h3><ul>\n<li><p>遵循PEP标准，声明编码格式</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: &lt;encoding name&gt; -*-</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用u’中文’替代’中文’</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">str1 = <span class=\"string\">'中文'</span></div><div class=\"line\">str2 = <span class=\"string\">u'中文'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#以上两种字符串变量的主要不同就是字符串编码不一致，str1的编码和Python声明的编码方式是一致的；str2的编码就是unicode格式。如果你的字符串变量中存在非ASCII字符，那么最好使用str2方式，这样你就不需要使用decode解码了，可以直接encode成你所需要的编码格式了，或者直接操作字符串了，避免异常情况出现。</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用人为的改变文本编码方式</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">reload(sys)</div><div class=\"line\">sys.setdefaultencoding(<span class=\"string\">'utf-8'</span>)</div><div class=\"line\"><span class=\"comment\">#以上三行代码可算是解决编码问题的万能钥匙了，几乎能解决所有的编码问题，但是它会带来一些负面影响。</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>先解码成unicode，再编码成所需的格式，decode early, unicode everywhere, encode late</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#! -*-coding:utf-8-*-</span></div><div class=\"line\">Str = <span class=\"string\">\"this is string example....wow!!!\"</span></div><div class=\"line\">Str = Str.encode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Encoded String: \"</span> + Str</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Decoded String: \"</span> + Str.decode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong><a href=\"http://blog.ernest.me/post/python-setdefaultencoding-unicode-bytes?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"external\">sys.setdefaultencoding(‘utf-8’)的弊端说明的最好的文章</a></strong></p>\n<h1 id=\"Python的call（前后双下划线-函数\"><a href=\"#Python的call（前后双下划线-函数\" class=\"headerlink\" title=\"Python的call（前后双下划线) 函数\"></a>Python的call（前后双下划线) 函数</h1><p>##概念<br>Python中有很多小函数，很有意思，也很有用，比如今天讲的<strong>call</strong>函数。<br>我们知道在调用一个类型的时候，必须先实例化，然后用对象去调用。但是如果这个类型中实现了<strong>call</strong>函数，那么这个类型就成为可调用的了，也就说，<strong>call</strong>函数相当于重载了括号运算符。</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><ul>\n<li>类型中不实现<strong>call</strong>的时候，如下：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Func</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, g)</span>:</span></div><div class=\"line\">        self.g = g</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call</span><span class=\"params\">(self, t)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> (self.g * t**<span class=\"number\">2</span>) / <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">e_dpm = Func(<span class=\"number\">2</span>)</div><div class=\"line\">seq =  e_dpm.call(<span class=\"number\">22</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>类型中实现了<strong>call</strong>函数的时候，调用可以如下：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Func</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, g)</span>:</span></div><div class=\"line\">        self.g = g</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, t)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> (self.g * t**<span class=\"number\">2</span>) / <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">e_dpm = Func(<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">#一下两种方式都可以调用</span></div><div class=\"line\">seq =  e_dpm(<span class=\"number\">22</span>)</div><div class=\"line\">seq = e_dpm.__call__(<span class=\"number\">22</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"call函数总结\"><a href=\"#call函数总结\" class=\"headerlink\" title=\"call函数总结\"></a><strong>call</strong>函数总结</h2><p>对象通过提供<strong>call</strong>(slef, [,<em>args [,*</em>kwargs]])方法可以模拟函数的行为，即x(arg1, arg2…) 等同于调用x.<strong>call</strong>(self, arg1, arg2)</p>\n<h1 id=\"识别编码的方法\"><a href=\"#识别编码的方法\" class=\"headerlink\" title=\"识别编码的方法\"></a>识别编码的方法</h1><p>有时候在我们没有明确被告知某个字符串、文件等的编码的时候，我们需要识别编码。使用编码方式、编码范围等判断是可行的，比如常用字表等，可惜的是识别率太低了。<br>这时候我们强大的Python就出来解决全人类了。python提供了一个第三方库，<strong>chardet库</strong>可以用来识别编码。</p>\n<h2 id=\"识别编码库chardet库\"><a href=\"#识别编码库chardet库\" class=\"headerlink\" title=\"识别编码库chardet库\"></a>识别编码库chardet库</h2><p>chardet库是个Python的第三方库，下面我们就来看看用法，很简单：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> chardet</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/path/file.txt'</span>,r) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    data = f.read()</div><div class=\"line\"><span class=\"keyword\">print</span> chardet.detect(data)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出：返回值是一个dict，一个是检测的可信度，一个是检测到的编码</span></div><div class=\"line\">&#123;<span class=\"string\">'confidence'</span>: <span class=\"number\">0.99</span>, <span class=\"string\">'encoding'</span>: <span class=\"string\">'utf-8'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#当然也可以直接检测字符串等容器的编码</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> chardet</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'zhong国'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> chardet.detect(s)</div><div class=\"line\">&#123;<span class=\"string\">'confidence'</span>: <span class=\"number\">0.505</span>, <span class=\"string\">'encoding'</span>: <span class=\"string\">'utf-8'</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>备注：<a href=\"http://chardet.readthedocs.io/en/latest/api/chardet.html#module-chardet\" target=\"_blank\" rel=\"external\">chardet官网</a></strong></p>\n<h1 id=\"关于print\"><a href=\"#关于print\" class=\"headerlink\" title=\"关于print\"></a>关于print</h1><h2 id=\"print输出文本中的中文\"><a href=\"#print输出文本中的中文\" class=\"headerlink\" title=\"print输出文本中的中文\"></a>print输出文本中的中文</h2><p>Python中包含一个中文字符串的列表、字典、文件等的时候，直接print的时候，会出现以下情况：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dicts = &#123;<span class=\"string\">\"asdf\"</span>: <span class=\"string\">\"学习Python，我们是认真的\"</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> dicts</div><div class=\"line\">&#123;<span class=\"string\">'asdf'</span>: <span class=\"string\">'\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#显然上述信息在处理的时候很不方便，此时只需要：</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dicts = &#123;<span class=\"string\">\"asdf\"</span>: <span class=\"string\">\"学习Python，我们是认真的\"</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> dicts</div><div class=\"line\">&#123;<span class=\"string\">'asdf'</span>: <span class=\"string\">'\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> json.dumps(dicts, encoding=<span class=\"string\">\"UTF-8\"</span>, ensure_ascii=<span class=\"keyword\">False</span>)</div><div class=\"line\">&#123;<span class=\"string\">\"asdf\"</span>: <span class=\"string\">\"学习Python，我们是认真的\"</span>&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"print的工作原理\"><a href=\"#print的工作原理\" class=\"headerlink\" title=\"print的工作原理\"></a>print的工作原理</h2><p>类UNIX系统中有标准输出和标准错误的说法（缩写为stdout、stderr），它们是建立在Unix系统内的管道（pipe）。对于Python来讲，当你输出的时候，结果就是输出到stdout管道中；当程序出错的时候，结果会输出到stderr管道中，而且<strong>一般来讲这两个管道都是与你正在工作的终端窗口相联。</strong>，当然如果你是在一个基于终端的Python IDE系统上工作，stedout和stderr是<strong>缺省窗口</strong>。</p>\n<h3 id=\"print会干什么？\"><a href=\"#print会干什么？\" class=\"headerlink\" title=\"print会干什么？\"></a>print会干什么？</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">print</span> <span class=\"string\">'Python2.%d'</span>%i</div><div class=\"line\">...</div><div class=\"line\">Python2<span class=\"number\">.0</span></div><div class=\"line\">Python2<span class=\"number\">.1</span></div><div class=\"line\">Python2<span class=\"number\">.2</span></div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</div><div class=\"line\"><span class=\"meta\">... </span>    sys.stdout.write(<span class=\"string\">'Python2.%d'</span>%i)</div><div class=\"line\">...</div><div class=\"line\">Python2<span class=\"number\">.0</span>Python2<span class=\"number\">.1</span>Python2<span class=\"number\">.2</span>&gt;&gt;&gt;</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</div><div class=\"line\"><span class=\"meta\">... </span>    sys.stderr.write(<span class=\"string\">'Python2.%d'</span>%i)</div><div class=\"line\">...</div><div class=\"line\">Python2<span class=\"number\">.0</span>Python2<span class=\"number\">.1</span>Python2<span class=\"number\">.2</span>&gt;&gt;&gt;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<p>由上述测试可以得出如下结论：</p>\n<ul>\n<li>stdout和stderr都是一个类文件对象，调用他的write，会打印出任何给出的字符串，<strong>并且不加换行符的输出</strong>。</li>\n<li>stdout和sterr会把他们的输出发送到同一个地方：Python IDE或者终端（如果你正在终端运行Python）</li>\n<li><strong>print所做的工作：</strong>它在字符串末尾加上换行符，然后调用sys.stdout.write()</li>\n</ul>\n<h3 id=\"类文件对象是什么？有什么特点？\"><a href=\"#类文件对象是什么？有什么特点？\" class=\"headerlink\" title=\"类文件对象是什么？有什么特点？\"></a>类文件对象是什么？有什么特点？</h3><p>stdout、stderr都是类文件对象，<strong>类文件对象是任意一个带有read方法的对象，</strong>这个方法带一个可选的size参数，并返回一个字符串。当不用size参数调用时，它从输入源中读出所有东西，并将所有数据作为单个字符串返回。当使用size参数调用时，它从输入源中读出size大小的数据，并返回那些数据；当再次调用时，它从余下的地方开始并返回下一块数据。<br><strong>虽然stdout、stderr是类文件对象，但是他比较特殊，它们只有write方法而没有read方法。</strong>但是我们可以通过将他绑定到其他的类文件对象来得到不通的输出位置，默认是输出到屏幕。<br>如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">saveout = sys.stdout</div><div class=\"line\">fsock = open(<span class=\"string\">'out.log'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\">sys.stdout = fsock</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'This message will be logged instead of displayed'</span></div><div class=\"line\">sys.stdout = saveout <span class=\"comment\">#要把stdout恢复回去，stderr一般不用恢复</span></div><div class=\"line\">fsock.close()</div></pre></td></tr></table></figure></p>\n<h1 id=\"super-内建函数\"><a href=\"#super-内建函数\" class=\"headerlink\" title=\"super()内建函数\"></a>super()内建函数</h1><p><strong>首先声明一点，super是针对新式类的，不适用于经典类。</strong>，这点一定要明确了。</p>\n<h2 id=\"经典类怎么初始化继承类？\"><a href=\"#经典类怎么初始化继承类？\" class=\"headerlink\" title=\"经典类怎么初始化继承类？\"></a>经典类怎么初始化继承类？</h2><p>先看个代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Base created\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildA</span><span class=\"params\">(Base)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        Base.__init__(self)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildB</span><span class=\"params\">(Base)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(ChildB, self).__init__()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> ChildA()</div><div class=\"line\"><span class=\"keyword\">print</span> ChildB()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果</span></div><div class=\"line\">Base created</div><div class=\"line\">&lt;__main__.ChildA object at <span class=\"number\">0x7fcca2eafbd0</span>&gt;</div><div class=\"line\">Base created</div><div class=\"line\">&lt;__main__.ChildB object at <span class=\"number\">0x7fcca2eafbd0</span>&gt;</div></pre></td></tr></table></figure></p>\n<p>由此看出，其实super和直接使用继承类去初始化没什么区别，但是你想想，当有一天，你突然想改名父类Base(object)为Root呢，那么对于子类来说，是不是全要改一次呢，显然，如果大量子类继承这个父类的话，你的代码怎么维护。所以使用super显而易见的作用就是维护成本小，当然，这仅仅是它显而易见的作用，还有其他的作用，下面来讲。</p>\n<h2 id=\"新式类的super\"><a href=\"#新式类的super\" class=\"headerlink\" title=\"新式类的super\"></a>新式类的super</h2><p>首先，要更深入的了解super，必须要先要了解<strong>MRO（方法解析顺序）</strong>。<br>在支持多继承的编程语言中，其方法、属性有可能是定义在当前类中，也有可能是在继承类中，那么问题来了，当有多个继承的时候，比如class Child（root_A,root_B）,那么假如父类中有重复的方法和类，到底使用那个呢？所以必须在调用该方法前先要对当前类和继承类进行搜素，以确定方法所在的位置，而这种搜索顺序就是所谓的MRO。</p>\n<p><a href=\"http://hanjianwei.com/2013/07/25/python-mro/\" target=\"_blank\" rel=\"external\">MRO知识普及文章推荐</a>,感谢作者。</p>\n<h2 id=\"super到底干了什么工作？\"><a href=\"#super到底干了什么工作？\" class=\"headerlink\" title=\"super到底干了什么工作？\"></a>super到底干了什么工作？</h2><p>super本质上干的工作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">super</span><span class=\"params\">(cls, inst)</span>:</span></div><div class=\"line\">    mro = inst.__class__.mro()</div><div class=\"line\">    <span class=\"keyword\">return</span> mro[mro.index(cls) + <span class=\"number\">1</span>]</div></pre></td></tr></table></figure>\n<p>上述函数解读，也是super函数的本质：</p>\n<ul>\n<li><strong>inst 负责生成 MRO 的 list</strong></li>\n<li><strong>通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1]</strong></li>\n</ul>\n<p>是不是还有点丈二和尚摸不着头脑，不要紧，接下来，将举例说明上述函数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Root(object):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        print(\"this is Root\")</div><div class=\"line\">class B(Root):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        print(\"enter B\")</div><div class=\"line\">        super(B, self).__init__()</div><div class=\"line\">        print(\"leave B\")</div><div class=\"line\">class C(Root):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        print(\"enter C\")</div><div class=\"line\">        super(C, self).__init__()</div><div class=\"line\">        print(\"leave C\")</div><div class=\"line\">class D(B, C):</div><div class=\"line\">    pass</div><div class=\"line\">d = D()</div><div class=\"line\">print(d.__class__.__mro__)</div><div class=\"line\"></div><div class=\"line\">#输出：</div><div class=\"line\">enter B</div><div class=\"line\">enter C</div><div class=\"line\">this is Root</div><div class=\"line\">leave C</div><div class=\"line\">leave B</div><div class=\"line\">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure>\n<p>有上述结果，我们能得到如下结论：</p>\n<ul>\n<li>super和父类并没有直接的关联，而是指MRO中的下一个类。因为如果直接关联的话，打印出来的结果应该是B之后就是Root类了，但是实质上是C类，因此super是mro[index + 1]。</li>\n<li>super会根据MRO逐个按顺序的去找<strong>init</strong>(前后双下划线，下同)构造函数，所以会先找自身，发现D没有<strong>init</strong>，接着去找B的，再去找C，再去找Root，再去找元类type。<strong>在MRO中，基类永远出现在派生类后面，如果有多个基类，基类的相对顺序保持不变。</strong></li>\n</ul>\n<p>备注：<br>上述举例代码中，我们如果给class B()中加二个打印的print，如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(Root)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> self.__class__</div><div class=\"line\">        <span class=\"keyword\">print</span> self.__class__.__mro__</div><div class=\"line\">        print(<span class=\"string\">\"enter B\"</span>)</div><div class=\"line\">        super(B, self).__init__()</div><div class=\"line\">        print(<span class=\"string\">\"leave B\"</span>)</div></pre></td></tr></table></figure></p>\n<p>猜猜输出的是什么？<br>结果输出：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;class '__main__.D'&gt;</div><div class=\"line\">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure></p>\n<p>注意：self输出的是D的instance，而不是B的instance。</p>\n<h1 id=\"sorted排序\"><a href=\"#sorted排序\" class=\"headerlink\" title=\"sorted排序\"></a>sorted排序</h1><p>内建函数sorted()可对<strong>可迭代序列排序</strong>，返回一个排好序的可迭代序列。</p>\n<h2 id=\"sorted函数：\"><a href=\"#sorted函数：\" class=\"headerlink\" title=\"sorted函数：\"></a>sorted函数：</h2><h3 id=\"sorted原型和参数\"><a href=\"#sorted原型和参数\" class=\"headerlink\" title=\"sorted原型和参数\"></a>sorted原型和参数</h3><p>源函数：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sorted(...)</div><div class=\"line\">    sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list</div></pre></td></tr></table></figure></p>\n<p>参数解析：</p>\n<ul>\n<li>iterable：是可迭代类型;</li>\n<li>cmp：用于比较的函数，比较什么由key决定,有默认值，迭代集合中的一项;</li>\n<li>key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;</li>\n<li>reverse：排序规则. reverse = True 或者 reverse = False，默认升序；</li>\n<li>返回值：是一个经过排序的可迭代类型，与iterable一样。</li>\n</ul>\n<h3 id=\"sorted和sort的区别\"><a href=\"#sorted和sort的区别\" class=\"headerlink\" title=\"sorted和sort的区别\"></a>sorted和sort的区别</h3><ul>\n<li>sort仅仅是list的一个方法，其他可迭代序列无此方法；sorted对所有的可迭代序列有效。</li>\n<li>sort是就地排序，排完序后list的本身也改变了；sorted是生成一个新的排好序的序列。</li>\n</ul>\n<p>举例说明：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(lists)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists.sort()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</div></pre></td></tr></table></figure></p>\n<h2 id=\"sorted函数使用方法详解\"><a href=\"#sorted函数使用方法详解\" class=\"headerlink\" title=\"sorted函数使用方法详解\"></a>sorted函数使用方法详解</h2><p>list.sort()和sorted()都支持key参数，key参数指定一个函数或者表达式等，此函数在<strong>每个元素比较前</strong>被调用。此函数的参数只有一个，并且返回一个值来与其他元素做比较。<br>key指定的函数可以对每个元素快速的作用，所以这个速度其实是很快的。</p>\n<p>在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数，cmp参数指定的函数用来进行元素间的比较。python3.0以后这个参数被废除。</p>\n<p>比如：</p>\n<ol>\n<li><p>不区分大小写的进行排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(<span class=\"string\">\"This is a test string from Andrew\"</span>.split(), key=str.lower)</div><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'Andrew'</span>, <span class=\"string\">'from'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'string'</span>, <span class=\"string\">'test'</span>, <span class=\"string\">'This'</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p>按照年龄排队：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>student_tuples = [</div><div class=\"line\"><span class=\"meta\">... </span>        (<span class=\"string\">'john'</span>, <span class=\"string\">'A'</span>, <span class=\"number\">15</span>),</div><div class=\"line\"><span class=\"meta\">... </span>        (<span class=\"string\">'jane'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">12</span>),</div><div class=\"line\"><span class=\"meta\">... </span>        (<span class=\"string\">'dave'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">10</span>),</div><div class=\"line\"><span class=\"meta\">... </span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(student_tuples, key=<span class=\"keyword\">lambda</span> student: student[<span class=\"number\">2</span>])</div><div class=\"line\">[(<span class=\"string\">'dave'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">10</span>), (<span class=\"string\">'jane'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">12</span>), (<span class=\"string\">'john'</span>, <span class=\"string\">'A'</span>, <span class=\"number\">15</span>)]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(student_tuples, key=<span class=\"keyword\">lambda</span> student: student[<span class=\"number\">2</span>],reverse=<span class=\"keyword\">True</span>)</div><div class=\"line\">[(<span class=\"string\">'john'</span>, <span class=\"string\">'A'</span>, <span class=\"number\">15</span>), (<span class=\"string\">'jane'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">12</span>), (<span class=\"string\">'dave'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">10</span>)]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用cmp函数来比较大小：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numeric_compare</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> x - y</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>], cmp=numeric_compare)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numeric_compare</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> y - x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>], cmp=numeric_compare)</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"字典排序\"><a href=\"#字典排序\" class=\"headerlink\" title=\"字典排序\"></a>字典排序</h3><ul>\n<li><p>按照字典的value中排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = &#123;<span class=\"number\">1</span>: <span class=\"number\">2</span>, <span class=\"number\">3</span>: <span class=\"number\">4</span>, <span class=\"number\">4</span>: <span class=\"number\">3</span>, <span class=\"number\">2</span>: <span class=\"number\">1</span>, <span class=\"number\">0</span>: <span class=\"number\">0</span>&#125;</div><div class=\"line\">sorted_value = sorted(x.iteritems(), key=<span class=\"keyword\">lambda</span> e: e[<span class=\"number\">1</span>])</div><div class=\"line\"><span class=\"keyword\">print</span> sorted_value</div><div class=\"line\">sorte_values = sorted(x.iteritems(), key=<span class=\"keyword\">lambda</span> e: e[<span class=\"number\">1</span>], reverse=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> sorte_values</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出</span></div><div class=\"line\">[(<span class=\"number\">0</span>, <span class=\"number\">0</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">4</span>, <span class=\"number\">3</span>), (<span class=\"number\">3</span>, <span class=\"number\">4</span>)]</div><div class=\"line\">[(<span class=\"number\">3</span>, <span class=\"number\">4</span>), (<span class=\"number\">4</span>, <span class=\"number\">3</span>), (<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">0</span>, <span class=\"number\">0</span>)]</div></pre></td></tr></table></figure>\n</li>\n<li><p>list的元素是dict，排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = [&#123;<span class=\"string\">'name'</span>: <span class=\"string\">'Homer'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">9</span>&#125;, &#123;<span class=\"string\">'name'</span>: <span class=\"string\">'Bart'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">10</span>&#125;]</div><div class=\"line\">values = sorted(x, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"string\">'name'</span>])</div><div class=\"line\">value = sorted(x, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"string\">'age'</span>])</div><div class=\"line\"><span class=\"keyword\">print</span> values</div><div class=\"line\"><span class=\"keyword\">print</span> value</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出</span></div><div class=\"line\">[&#123;<span class=\"string\">'age'</span>: <span class=\"number\">10</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bart'</span>&#125;, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">9</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Homer'</span>&#125;]</div><div class=\"line\">[&#123;<span class=\"string\">'age'</span>: <span class=\"number\">9</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Homer'</span>&#125;, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">10</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bart'</span>&#125;]</div></pre></td></tr></table></figure>\n</li>\n<li><p>按照字典value的某个元素排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">myDict = &#123;<span class=\"string\">'item1'</span>: [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>], <span class=\"string\">'item2'</span>: [<span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"string\">'item3'</span>: [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>]&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortDic</span><span class=\"params\">(Dict, valuePostion)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> sorted(Dict.items(), key=<span class=\"keyword\">lambda</span> e: e[<span class=\"number\">1</span>][valuePostion])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 按value的第3个值排序</span></div><div class=\"line\"><span class=\"keyword\">print</span> sortDic(myDict, <span class=\"number\">2</span>)</div><div class=\"line\">[(<span class=\"string\">'item2'</span>, [<span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), (<span class=\"string\">'item1'</span>, [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>]), (<span class=\"string\">'item3'</span>, [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>])]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 按value的第1个值排序</span></div><div class=\"line\"><span class=\"keyword\">print</span> sortDic(myDict, <span class=\"number\">0</span>)</div><div class=\"line\">[(<span class=\"string\">'item1'</span>, [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>]), (<span class=\"string\">'item2'</span>, [<span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), (<span class=\"string\">'item3'</span>, [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>])]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"with上下文管理器\"><a href=\"#with上下文管理器\" class=\"headerlink\" title=\"with上下文管理器\"></a>with上下文管理器</h1><h1 id=\"获取脚本的执行路径问题\"><a href=\"#获取脚本的执行路径问题\" class=\"headerlink\" title=\"获取脚本的执行路径问题\"></a>获取脚本的执行路径问题</h1><p>Python中有两种方法能获取到执行脚本的文件路径，一种是<strong>“<strong>file</strong>“</strong>，一种是<strong>“sys.argv[0]”</strong>。</p>\n<h2 id=\"主执行文件，获取执行脚本路径\"><a href=\"#主执行文件，获取执行脚本路径\" class=\"headerlink\" title=\"主执行文件，获取执行脚本路径\"></a>主执行文件，获取执行脚本路径</h2><p>在主执行文件中，<strong>“<strong>file</strong>“</strong>和sys.argv[0]区别不大，都是根据的到执行该脚本的方式不同，而得到绝对路径或者相对路径。<br>如下所示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#-*-coding:utf-8-*-</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"__file__    --------&gt;%s\"</span>%__file__</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"sys.argv[0] --------&gt;%s\"</span>%sys.argv[<span class=\"number\">0</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">[root@localhost workspace]# ./test.py</div><div class=\"line\">__file__    --------&gt;./test.py</div><div class=\"line\">sys.argv[0] --------&gt;./test.py</div><div class=\"line\">[root@localhost workspace]# /root/workspace/test.py</div><div class=\"line\">__file__    --------&gt;/root/workspace/test.py</div><div class=\"line\">sys.argv[0] --------&gt;/root/workspace/test.py</div><div class=\"line\">[root@localhost workspace]# ~/workspace/test.py</div><div class=\"line\">__file__    --------&gt;/root/workspace/test.py</div><div class=\"line\">sys.argv[0] --------&gt;/root/workspace/test.py</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure></p>\n<p>由上面的测试可以看到，此两种获取路径的方式都是由执行脚本的方式不同，而结果是相对路径或者绝对路径，可以通过<strong>os.path.abspath()</strong>函数来取得执行脚本的绝对路径。<br>以上说明<strong>在主文件中执行的时候，这两种方式没什么区别。</strong></p>\n<h2 id=\"非主执行文件，import其他文件，获取执行脚本路径\"><a href=\"#非主执行文件，import其他文件，获取执行脚本路径\" class=\"headerlink\" title=\"非主执行文件，import其他文件，获取执行脚本路径\"></a>非主执行文件，import其他文件，获取执行脚本路径</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># test_1.py脚本，主执行脚本</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"__file__    --------&gt;%s\"</span>%__file__</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"sys.argv[0] --------&gt;%s\"</span>%sys.argv[<span class=\"number\">0</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> test_2</div><div class=\"line\">test_2.show_path()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># test_2.py脚本，供其他文件引入的脚本，非主执行文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">show_path</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"show_path:__file__    --------&gt;%s\"</span>%__file__</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"show_path:sys.argv[0] --------&gt;%s\"</span>%sys.argv[<span class=\"number\">0</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">__file__    --------&gt;./test_1.py</div><div class=\"line\">sys.argv[0] --------&gt;./test_1.py</div><div class=\"line\">show_path:__file__    --------&gt;/root/workspace/test_2.py</div><div class=\"line\">show_path:sys.argv[0] --------&gt;./test_1.py</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<p>以上结果说明，<strong>“<strong>file</strong>“</strong>得到的不一定是主文件的执行路径，而是那个脚本中的<strong><strong>file</strong></strong>，则得到是那个脚本的路径，而<strong>sys.argv[0]</strong>得到的是永远是主执行文件的路径，这个很好理解，因为sys.argv[0]本质上就是脚本命令行的第一个参数，那么这个脚本是什么，肯定得到的第一个参数就是什么。</p>\n<p><strong>以上结果说明：当需要获取执行脚本的路径的时候，sys.argv[0]比<strong>file</strong>更靠谱一些。</strong></p>\n<p><a href=\"https://laike9m.com/blog/li-jie-python-super,70/\" target=\"_blank\" rel=\"external\">super解释非常好的博客</a>，感谢作者！</p>\n","excerpt":"<p>基础经济决定上层建筑，扎实的基础知识是优秀工程师的基石，本文记录一些零碎的Python的基础知识。</p>\n<blockquote>\n<ul>\n<li>类、元类</li>\n<li>函数</li>\n<li>Python的编码、乱码问题</li>\n<li>Python的<strong>call</strong>（前后双下划线）函数</li>\n<li>识别编码的办法</li>\n<li>super函数</li>\n<li>os模块的文件对象操作部分</li>\n<li>文件对象的读写</li>\n</ul>\n</blockquote>","more":"<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"什么是类？类的特点是什么？\"><a href=\"#什么是类？类的特点是什么？\" class=\"headerlink\" title=\"什么是类？类的特点是什么？\"></a><strong>什么是类？类的特点是什么？</strong></h2><ul>\n<li><strong>类：</strong> 类就是一组用来描述描述如何生成对象的代码段。<strong>类就是能创建出类实例的对象。</strong></li>\n<li><p><strong>类的特点：</strong>Python中的类也是对象，只要使用关键字<strong>class</strong>，Python的解释器执行的时候就会在内存中创建一个对象，对象名就是类名。<strong>这个对象（类）自身拥有创建对象（类实例）的能力</strong>，这就是为什么称这个对象为类的原因。但是Python中的类本质上还是一个对象，所以Python中类可以：</p>\n<ul>\n<li>将类赋给一个变量</li>\n<li>可以拷贝类</li>\n<li>可以为他增加属性</li>\n<li>可以把类作为函数参数去传递</li>\n<li>类是对象，因此可以动态的去创建类</li>\n<li>示例：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\">Foo.new_aut = <span class=\"string\">'lingyue'</span></div><div class=\"line\">foo = Foo()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myClass</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> name == <span class=\"string\">'foo'</span>:</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">()</span>:</span></div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\">        <span class=\"keyword\">return</span> Foo</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span><span class=\"params\">()</span>:</span></div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\">        <span class=\"keyword\">return</span> Bar</div><div class=\"line\">s = myClass(<span class=\"string\">'foo'</span>)</div><div class=\"line\">x = myClass(<span class=\"string\">'bar'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>类既然也是对象，那么这个类对象是谁创建的呢？</p>\n<ul>\n<li>创建类的<strong>元类</strong>。<h2 id=\"什么是元类？元类的特点是什么？-解释元类个人认为最好的文章链接\"><a href=\"#什么是元类？元类的特点是什么？-解释元类个人认为最好的文章链接\" class=\"headerlink\" title=\"什么是元类？元类的特点是什么？ 解释元类个人认为最好的文章链接\"></a><strong>什么是元类？元类的特点是什么？</strong> <a href=\"http://blog.jobbole.com/21351/\">解释元类个人认为最好的文章链接</a></h2></li>\n</ul>\n</li>\n<li><p><strong>元类：</strong>元类就是创建类（对象）的“东西”，即<strong>元类就是类的类，可以理解为元类就是类工厂</strong>。<br>记录开始</p>\n</li>\n</ul>\n<h2 id=\"“metaclass“属性是什么？这个属性有什么作用？\"><a href=\"#“metaclass“属性是什么？这个属性有什么作用？\" class=\"headerlink\" title=\"“metaclass“属性是什么？这个属性有什么作用？\"></a><strong>“<strong>metaclass</strong>“属性是什么？这个属性有什么作用？</strong></h2><ul>\n<li><strong>“<strong>metaclass</strong>“</strong>属性的怎么用？</li>\n</ul>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"函数参数传递说明\"><a href=\"#函数参数传递说明\" class=\"headerlink\" title=\"函数参数传递说明\"></a>函数参数传递说明</h2><h3 id=\"传递参数带星号\"><a href=\"#传递参数带星号\" class=\"headerlink\" title=\"传递参数带星号(*)\"></a>传递参数带星号<strong>(*)</strong></h3><p>在传递不确定个数的参数的时候，我们可能会使用（<em>args，*</em>kwargs）来传递，那么使用星号和不使用星号去给函数传递参数有什么区别？<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(*args)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">print</span> args</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">print</span> args[<span class=\"number\">0</span>]</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = (<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(a)</div><div class=\"line\">((<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>),)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(*a)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<p>上面举例可以看出，当不使用星号给函数传递参数的时候，你是怎么传递的，那么函数接受到的参数就是什么样子的，比如上例子中的<strong>func(a)</strong>，传递进来后，函数接受到的就是你所传递的参数，例子中使用的是元组的方式去传递的；那么你用list做参数，函数还是会把参数作为元组去处理，就是说*args永远接受到的是一个元组：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func([<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>])</div><div class=\"line\">([<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>],)</div><div class=\"line\">[<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(*[<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>])</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div></pre></td></tr></table></figure></p>\n<p>那么当我们使用引用传参<strong>(func(*a))</strong>的时候，会发生什么呢？<br>由上面的例子可以看到，使用引用传参的时候，函数解析器实际会把元组给解包，解析成len（a）个参数，它会把你传进去的参数解包成一个元组，而不是原封不动的接受。<br>所以：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(*a)</div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div></pre></td></tr></table></figure></p>\n<p>等价于<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"string\">'lingyue'</span>,<span class=\"string\">'jiangtao'</span>)<span class=\"comment\">#表示传递两个参数</span></div><div class=\"line\">(<span class=\"string\">'lingyue'</span>, <span class=\"string\">'jiangtao'</span>)</div><div class=\"line\">lingyue</div></pre></td></tr></table></figure></p>\n<h1 id=\"Python的编码、乱码问题\"><a href=\"#Python的编码、乱码问题\" class=\"headerlink\" title=\"Python的编码、乱码问题\"></a>Python的编码、乱码问题</h1><h2 id=\"为什么产生编码问题？\"><a href=\"#为什么产生编码问题？\" class=\"headerlink\" title=\"为什么产生编码问题？\"></a>为什么产生编码问题？</h2><p>计算机只能处理01编码，如果要处理非数字的数据结构，只能把其他数据结构转化为01编码，计算机才能处理。美国人在最初发明计算机的时候就把自己的一些字母，如a,b,A,D,以及一些特殊字符、数字等编码到计算机中，一共是127个字母被编译进去。<strong>这个编码就是ASCII编码，</strong>比如大写的A是65等。但是当计算机传入中国的时候，中国语言博大精深，<em>（计算机在设计时采用8个比特（bit）作为一个字节（byte）</em>，一个字节要处理中文显然是不够的，而且还不能与ASCII编码重复，至少需要两个字节才能处理一个汉字。所以，中国人就制作了中文的编码方式，就GB2312编码，把中文编译进去。<br>那么，世界上有形形色色的语言，各国可能都有自己的语言，比如日文、韩文、法文等，各国都有自己的标准，这怎么通信，就比如货币如果没有比率做等价交换，各国就无法通币了，显然没有一个标准就会有各种冲突。于是乎，unicode就产生了。unicode就是一个各国编码的一个通用的桥梁，好比现在美元就是世界通用的货币，英语就是世界通用的语言，<em>（谁让美国佬强大呢，再过几十年，世界通用标准说不定就中国了）</em>。有了unicode这个通用编码标准，世界任何国家就可以通过这个编码进行转化，进而进行交流。<br><strong>以上就是编码问题的由来和解决办法的知识的简单普及。</strong></p>\n<h2 id=\"unicode、UTF-8\"><a href=\"#unicode、UTF-8\" class=\"headerlink\" title=\"unicode、UTF-8\"></a>unicode、UTF-8</h2><p>我们知道unicode就是一个通用的编码标准了，有了unicode，所有的乱码问题，语言不通问题就解决了。<br>但是这就万事大吉了？No，上面我们介绍了，如果只是英语，也就是字符串，ASCII是够用的，美国人就是这么用的，只不过，中文博大精深，需要更多的编码字节罢了，至少需要两个字节。我们中国人自古以来，勤俭节约，计算机中什么最珍贵？肯定是CPU和内存嘛，那么问题来了，有个学渣，语文课不好好上，写篇作文，由于大多数汉字学了后都还给老师了，此贼通篇文章绝大多数都是拼音替代，也就是字符串，只有个别是汉字。<br>此时如果你都用2个或者以上的字节去编码，显然不在信息存储上、信息传输上不合算呐，大多数比特位都是填充的0，要是你真这么编码，老师一定骂你是败家子了。<br>此时聪明的中国人就想办法了，出现<strong>UTF-8</strong>编码，<strong>所谓的UTF-8编码就是一种可变长度的unicode编码，</strong><br>UTF-8编码把一个unicode字符根据不同的数字大小编码成1-6个字节，比如字符就用1个字节，简单中文就用2-3个字节，只有很生僻的字符才会被编码成4-6个字节，此时如果你把有大量字符中夹杂少量汉字的作文传输给老师的时候，就能节省不少的空间，存储和传输都节省不少呢。</p>\n<p>注意：<br>通常python的文件的开头会这么写：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure></p>\n<p>第一行是遥告诉Linux系统，这是一个Python的可执行程序，window会忽略这行。<br>第二行注释是为了告诉Python解释器，请按照UTF-8编码来读取源码，否则你在文件中可能就会看到乱码问题。<br><strong>以上就是Unicode编码和UTF-8编码的简单介绍。</strong></p>\n<h2 id=\"编码、解码\"><a href=\"#编码、解码\" class=\"headerlink\" title=\"编码、解码\"></a>编码、解码</h2><p>Python紧跟潮流，也支持Unicode编码方式。Python 2.x的默认编码方式是ASCII方式。Python 3.x默认编码方式是unicode方式。str和unicode都是basestring的子类。严格意义上说，str其实是字节串，它是unicode经过编码后的字节组成的序列。对UTF-8编码的str’汉’使用len()函数时，结果是3，因为实际上，UTF-8编码的’汉’==’\\xE6\\xB1\\x89’。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">str  -&gt; decode('the_coding_of_str') -&gt; unicode</div><div class=\"line\">unicode -&gt; encode('the_coding_you_want') -&gt; str</div><div class=\"line\"></div><div class=\"line\">#s是code_A的str</div><div class=\"line\">s.decode('code_A').encode('code_B') #不同编码转换,使用unicode作为中间编码</div></pre></td></tr></table></figure></p>\n<p><strong>unicode才是真正意义上的字符串，由字符组成；str是经过unicode经过编码后的字节组成的一个序列。所以不要对str使用编码(encode)，不要对unicode使用解码(decode),</strong>虽然即使你使用了也不会报错，但是不建议这么做。</p>\n<p>字符串在Python内部的表示是unicode编码，因此，<strong>在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。</strong> 但是，Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。也因为这个根本原因，在Python2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。</p>\n<h3 id=\"解码（decode）：\"><a href=\"#解码（decode）：\" class=\"headerlink\" title=\"解码（decode）：\"></a>解码（decode）：</h3><p>decode函数的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘gb2312’)，表示将gb2312编码的字符串str1转换成unicode编码。</p>\n<h3 id=\"编码（encode）\"><a href=\"#编码（encode）\" class=\"headerlink\" title=\"编码（encode）:\"></a>编码（encode）:</h3><p>encode函数的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘utf-8’)，表示将unicode编码的字符串str2编码成utf-8编码。</p>\n<p>encode、decode语法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.encode(encoding=<span class=\"string\">'UTF-8'</span>,errors=<span class=\"string\">'strict'</span>) <span class=\"comment\">#参数</span></div><div class=\"line\">Decoded string <span class=\"comment\">#返回结果</span></div><div class=\"line\"></div><div class=\"line\">Str.decode(encoding=<span class=\"string\">'UTF-8'</span>,errors=<span class=\"string\">'strict'</span>) <span class=\"comment\">#参数</span></div><div class=\"line\">Decoded string <span class=\"comment\"># 返回结果</span></div></pre></td></tr></table></figure></p>\n<p>编码解码使用举例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#! -*-coding:utf-8-*-</span></div><div class=\"line\">Str = <span class=\"string\">\"this is string example....wow!!!\"</span></div><div class=\"line\">Str = Str.encode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Encoded String: \"</span> + Str</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Decoded String: \"</span> + Str.decode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果：</span></div><div class=\"line\">Encoded String: dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE=</div><div class=\"line\">Decoded String: this <span class=\"keyword\">is</span> string example....wow!!!</div></pre></td></tr></table></figure></p>\n<h3 id=\"编码问题常见异常总结：\"><a href=\"#编码问题常见异常总结：\" class=\"headerlink\" title=\"编码问题常见异常总结：\"></a>编码问题常见异常总结：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>、SyntaxError: Non-ASCII character <span class=\"comment\">#Python源文件中有非ASCII字符，但是同时没有声明编码格式。</span></div><div class=\"line\"><span class=\"number\">2</span>、UnicodeDecodeError <span class=\"comment\">#将其他编码格式转换成unicode编码，但是字符本身的编码格式和decode传入的不相符。如下面：</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\">s = <span class=\"string\">'中文'</span></div><div class=\"line\">s.decode(<span class=\"string\">'gb2312'</span>) <span class=\"comment\"># UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 2-3: illegal multibyte sequence</span></div><div class=\"line\"><span class=\"keyword\">print</span> s</div><div class=\"line\"><span class=\"number\">3</span>、UnicodeEncodeError <span class=\"comment\"># 错误的使用decode和encode方法会出现这种异常，比如：使用decode方法将Unicode字符串转化的时候，如下面：</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\">s = <span class=\"string\">u'中文'</span></div><div class=\"line\">s.decode(<span class=\"string\">'utf-8'</span>) <span class=\"comment\"># UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</span></div><div class=\"line\"><span class=\"keyword\">print</span> s</div></pre></td></tr></table></figure>\n<h3 id=\"编码问题常见处理方法总结：\"><a href=\"#编码问题常见处理方法总结：\" class=\"headerlink\" title=\"编码问题常见处理方法总结：\"></a>编码问题常见处理方法总结：</h3><ul>\n<li><p>遵循PEP标准，声明编码格式</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: &lt;encoding name&gt; -*-</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用u’中文’替代’中文’</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">str1 = <span class=\"string\">'中文'</span></div><div class=\"line\">str2 = <span class=\"string\">u'中文'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#以上两种字符串变量的主要不同就是字符串编码不一致，str1的编码和Python声明的编码方式是一致的；str2的编码就是unicode格式。如果你的字符串变量中存在非ASCII字符，那么最好使用str2方式，这样你就不需要使用decode解码了，可以直接encode成你所需要的编码格式了，或者直接操作字符串了，避免异常情况出现。</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用人为的改变文本编码方式</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">reload(sys)</div><div class=\"line\">sys.setdefaultencoding(<span class=\"string\">'utf-8'</span>)</div><div class=\"line\"><span class=\"comment\">#以上三行代码可算是解决编码问题的万能钥匙了，几乎能解决所有的编码问题，但是它会带来一些负面影响。</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>先解码成unicode，再编码成所需的格式，decode early, unicode everywhere, encode late</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#! -*-coding:utf-8-*-</span></div><div class=\"line\">Str = <span class=\"string\">\"this is string example....wow!!!\"</span></div><div class=\"line\">Str = Str.encode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Encoded String: \"</span> + Str</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Decoded String: \"</span> + Str.decode(<span class=\"string\">'base64'</span>, <span class=\"string\">'strict'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong><a href=\"http://blog.ernest.me/post/python-setdefaultencoding-unicode-bytes?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\">sys.setdefaultencoding(‘utf-8’)的弊端说明的最好的文章</a></strong></p>\n<h1 id=\"Python的call（前后双下划线-函数\"><a href=\"#Python的call（前后双下划线-函数\" class=\"headerlink\" title=\"Python的call（前后双下划线) 函数\"></a>Python的call（前后双下划线) 函数</h1><p>##概念<br>Python中有很多小函数，很有意思，也很有用，比如今天讲的<strong>call</strong>函数。<br>我们知道在调用一个类型的时候，必须先实例化，然后用对象去调用。但是如果这个类型中实现了<strong>call</strong>函数，那么这个类型就成为可调用的了，也就说，<strong>call</strong>函数相当于重载了括号运算符。</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><ul>\n<li>类型中不实现<strong>call</strong>的时候，如下：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Func</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, g)</span>:</span></div><div class=\"line\">        self.g = g</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call</span><span class=\"params\">(self, t)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> (self.g * t**<span class=\"number\">2</span>) / <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">e_dpm = Func(<span class=\"number\">2</span>)</div><div class=\"line\">seq =  e_dpm.call(<span class=\"number\">22</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>类型中实现了<strong>call</strong>函数的时候，调用可以如下：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Func</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, g)</span>:</span></div><div class=\"line\">        self.g = g</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, t)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> (self.g * t**<span class=\"number\">2</span>) / <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">e_dpm = Func(<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">#一下两种方式都可以调用</span></div><div class=\"line\">seq =  e_dpm(<span class=\"number\">22</span>)</div><div class=\"line\">seq = e_dpm.__call__(<span class=\"number\">22</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"call函数总结\"><a href=\"#call函数总结\" class=\"headerlink\" title=\"call函数总结\"></a><strong>call</strong>函数总结</h2><p>对象通过提供<strong>call</strong>(slef, [,<em>args [,*</em>kwargs]])方法可以模拟函数的行为，即x(arg1, arg2…) 等同于调用x.<strong>call</strong>(self, arg1, arg2)</p>\n<h1 id=\"识别编码的方法\"><a href=\"#识别编码的方法\" class=\"headerlink\" title=\"识别编码的方法\"></a>识别编码的方法</h1><p>有时候在我们没有明确被告知某个字符串、文件等的编码的时候，我们需要识别编码。使用编码方式、编码范围等判断是可行的，比如常用字表等，可惜的是识别率太低了。<br>这时候我们强大的Python就出来解决全人类了。python提供了一个第三方库，<strong>chardet库</strong>可以用来识别编码。</p>\n<h2 id=\"识别编码库chardet库\"><a href=\"#识别编码库chardet库\" class=\"headerlink\" title=\"识别编码库chardet库\"></a>识别编码库chardet库</h2><p>chardet库是个Python的第三方库，下面我们就来看看用法，很简单：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> chardet</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/path/file.txt'</span>,r) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    data = f.read()</div><div class=\"line\"><span class=\"keyword\">print</span> chardet.detect(data)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出：返回值是一个dict，一个是检测的可信度，一个是检测到的编码</span></div><div class=\"line\">&#123;<span class=\"string\">'confidence'</span>: <span class=\"number\">0.99</span>, <span class=\"string\">'encoding'</span>: <span class=\"string\">'utf-8'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#当然也可以直接检测字符串等容器的编码</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> chardet</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'zhong国'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> chardet.detect(s)</div><div class=\"line\">&#123;<span class=\"string\">'confidence'</span>: <span class=\"number\">0.505</span>, <span class=\"string\">'encoding'</span>: <span class=\"string\">'utf-8'</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>备注：<a href=\"http://chardet.readthedocs.io/en/latest/api/chardet.html#module-chardet\">chardet官网</a></strong></p>\n<h1 id=\"关于print\"><a href=\"#关于print\" class=\"headerlink\" title=\"关于print\"></a>关于print</h1><h2 id=\"print输出文本中的中文\"><a href=\"#print输出文本中的中文\" class=\"headerlink\" title=\"print输出文本中的中文\"></a>print输出文本中的中文</h2><p>Python中包含一个中文字符串的列表、字典、文件等的时候，直接print的时候，会出现以下情况：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dicts = &#123;<span class=\"string\">\"asdf\"</span>: <span class=\"string\">\"学习Python，我们是认真的\"</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> dicts</div><div class=\"line\">&#123;<span class=\"string\">'asdf'</span>: <span class=\"string\">'\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#显然上述信息在处理的时候很不方便，此时只需要：</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dicts = &#123;<span class=\"string\">\"asdf\"</span>: <span class=\"string\">\"学习Python，我们是认真的\"</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> dicts</div><div class=\"line\">&#123;<span class=\"string\">'asdf'</span>: <span class=\"string\">'\\xe5\\xad\\xa6\\xe4\\xb9\\xa0Python\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe4\\xbb\\xac\\xe6\\x98\\xaf\\xe8\\xae\\xa4\\xe7\\x9c\\x9f\\xe7\\x9a\\x84'</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> json.dumps(dicts, encoding=<span class=\"string\">\"UTF-8\"</span>, ensure_ascii=<span class=\"keyword\">False</span>)</div><div class=\"line\">&#123;<span class=\"string\">\"asdf\"</span>: <span class=\"string\">\"学习Python，我们是认真的\"</span>&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"print的工作原理\"><a href=\"#print的工作原理\" class=\"headerlink\" title=\"print的工作原理\"></a>print的工作原理</h2><p>类UNIX系统中有标准输出和标准错误的说法（缩写为stdout、stderr），它们是建立在Unix系统内的管道（pipe）。对于Python来讲，当你输出的时候，结果就是输出到stdout管道中；当程序出错的时候，结果会输出到stderr管道中，而且<strong>一般来讲这两个管道都是与你正在工作的终端窗口相联。</strong>，当然如果你是在一个基于终端的Python IDE系统上工作，stedout和stderr是<strong>缺省窗口</strong>。</p>\n<h3 id=\"print会干什么？\"><a href=\"#print会干什么？\" class=\"headerlink\" title=\"print会干什么？\"></a>print会干什么？</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">print</span> <span class=\"string\">'Python2.%d'</span>%i</div><div class=\"line\">...</div><div class=\"line\">Python2<span class=\"number\">.0</span></div><div class=\"line\">Python2<span class=\"number\">.1</span></div><div class=\"line\">Python2<span class=\"number\">.2</span></div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</div><div class=\"line\"><span class=\"meta\">... </span>    sys.stdout.write(<span class=\"string\">'Python2.%d'</span>%i)</div><div class=\"line\">...</div><div class=\"line\">Python2<span class=\"number\">.0</span>Python2<span class=\"number\">.1</span>Python2<span class=\"number\">.2</span>&gt;&gt;&gt;</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</div><div class=\"line\"><span class=\"meta\">... </span>    sys.stderr.write(<span class=\"string\">'Python2.%d'</span>%i)</div><div class=\"line\">...</div><div class=\"line\">Python2<span class=\"number\">.0</span>Python2<span class=\"number\">.1</span>Python2<span class=\"number\">.2</span>&gt;&gt;&gt;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<p>由上述测试可以得出如下结论：</p>\n<ul>\n<li>stdout和stderr都是一个类文件对象，调用他的write，会打印出任何给出的字符串，<strong>并且不加换行符的输出</strong>。</li>\n<li>stdout和sterr会把他们的输出发送到同一个地方：Python IDE或者终端（如果你正在终端运行Python）</li>\n<li><strong>print所做的工作：</strong>它在字符串末尾加上换行符，然后调用sys.stdout.write()</li>\n</ul>\n<h3 id=\"类文件对象是什么？有什么特点？\"><a href=\"#类文件对象是什么？有什么特点？\" class=\"headerlink\" title=\"类文件对象是什么？有什么特点？\"></a>类文件对象是什么？有什么特点？</h3><p>stdout、stderr都是类文件对象，<strong>类文件对象是任意一个带有read方法的对象，</strong>这个方法带一个可选的size参数，并返回一个字符串。当不用size参数调用时，它从输入源中读出所有东西，并将所有数据作为单个字符串返回。当使用size参数调用时，它从输入源中读出size大小的数据，并返回那些数据；当再次调用时，它从余下的地方开始并返回下一块数据。<br><strong>虽然stdout、stderr是类文件对象，但是他比较特殊，它们只有write方法而没有read方法。</strong>但是我们可以通过将他绑定到其他的类文件对象来得到不通的输出位置，默认是输出到屏幕。<br>如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">saveout = sys.stdout</div><div class=\"line\">fsock = open(<span class=\"string\">'out.log'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\">sys.stdout = fsock</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'This message will be logged instead of displayed'</span></div><div class=\"line\">sys.stdout = saveout <span class=\"comment\">#要把stdout恢复回去，stderr一般不用恢复</span></div><div class=\"line\">fsock.close()</div></pre></td></tr></table></figure></p>\n<h1 id=\"super-内建函数\"><a href=\"#super-内建函数\" class=\"headerlink\" title=\"super()内建函数\"></a>super()内建函数</h1><p><strong>首先声明一点，super是针对新式类的，不适用于经典类。</strong>，这点一定要明确了。</p>\n<h2 id=\"经典类怎么初始化继承类？\"><a href=\"#经典类怎么初始化继承类？\" class=\"headerlink\" title=\"经典类怎么初始化继承类？\"></a>经典类怎么初始化继承类？</h2><p>先看个代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Base created\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildA</span><span class=\"params\">(Base)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        Base.__init__(self)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildB</span><span class=\"params\">(Base)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(ChildB, self).__init__()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> ChildA()</div><div class=\"line\"><span class=\"keyword\">print</span> ChildB()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果</span></div><div class=\"line\">Base created</div><div class=\"line\">&lt;__main__.ChildA object at <span class=\"number\">0x7fcca2eafbd0</span>&gt;</div><div class=\"line\">Base created</div><div class=\"line\">&lt;__main__.ChildB object at <span class=\"number\">0x7fcca2eafbd0</span>&gt;</div></pre></td></tr></table></figure></p>\n<p>由此看出，其实super和直接使用继承类去初始化没什么区别，但是你想想，当有一天，你突然想改名父类Base(object)为Root呢，那么对于子类来说，是不是全要改一次呢，显然，如果大量子类继承这个父类的话，你的代码怎么维护。所以使用super显而易见的作用就是维护成本小，当然，这仅仅是它显而易见的作用，还有其他的作用，下面来讲。</p>\n<h2 id=\"新式类的super\"><a href=\"#新式类的super\" class=\"headerlink\" title=\"新式类的super\"></a>新式类的super</h2><p>首先，要更深入的了解super，必须要先要了解<strong>MRO（方法解析顺序）</strong>。<br>在支持多继承的编程语言中，其方法、属性有可能是定义在当前类中，也有可能是在继承类中，那么问题来了，当有多个继承的时候，比如class Child（root_A,root_B）,那么假如父类中有重复的方法和类，到底使用那个呢？所以必须在调用该方法前先要对当前类和继承类进行搜素，以确定方法所在的位置，而这种搜索顺序就是所谓的MRO。</p>\n<p><a href=\"http://hanjianwei.com/2013/07/25/python-mro/\">MRO知识普及文章推荐</a>,感谢作者。</p>\n<h2 id=\"super到底干了什么工作？\"><a href=\"#super到底干了什么工作？\" class=\"headerlink\" title=\"super到底干了什么工作？\"></a>super到底干了什么工作？</h2><p>super本质上干的工作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">super</span><span class=\"params\">(cls, inst)</span>:</span></div><div class=\"line\">    mro = inst.__class__.mro()</div><div class=\"line\">    <span class=\"keyword\">return</span> mro[mro.index(cls) + <span class=\"number\">1</span>]</div></pre></td></tr></table></figure>\n<p>上述函数解读，也是super函数的本质：</p>\n<ul>\n<li><strong>inst 负责生成 MRO 的 list</strong></li>\n<li><strong>通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1]</strong></li>\n</ul>\n<p>是不是还有点丈二和尚摸不着头脑，不要紧，接下来，将举例说明上述函数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Root(object):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        print(\"this is Root\")</div><div class=\"line\">class B(Root):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        print(\"enter B\")</div><div class=\"line\">        super(B, self).__init__()</div><div class=\"line\">        print(\"leave B\")</div><div class=\"line\">class C(Root):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        print(\"enter C\")</div><div class=\"line\">        super(C, self).__init__()</div><div class=\"line\">        print(\"leave C\")</div><div class=\"line\">class D(B, C):</div><div class=\"line\">    pass</div><div class=\"line\">d = D()</div><div class=\"line\">print(d.__class__.__mro__)</div><div class=\"line\"></div><div class=\"line\">#输出：</div><div class=\"line\">enter B</div><div class=\"line\">enter C</div><div class=\"line\">this is Root</div><div class=\"line\">leave C</div><div class=\"line\">leave B</div><div class=\"line\">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure>\n<p>有上述结果，我们能得到如下结论：</p>\n<ul>\n<li>super和父类并没有直接的关联，而是指MRO中的下一个类。因为如果直接关联的话，打印出来的结果应该是B之后就是Root类了，但是实质上是C类，因此super是mro[index + 1]。</li>\n<li>super会根据MRO逐个按顺序的去找<strong>init</strong>(前后双下划线，下同)构造函数，所以会先找自身，发现D没有<strong>init</strong>，接着去找B的，再去找C，再去找Root，再去找元类type。<strong>在MRO中，基类永远出现在派生类后面，如果有多个基类，基类的相对顺序保持不变。</strong></li>\n</ul>\n<p>备注：<br>上述举例代码中，我们如果给class B()中加二个打印的print，如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(Root)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> self.__class__</div><div class=\"line\">        <span class=\"keyword\">print</span> self.__class__.__mro__</div><div class=\"line\">        print(<span class=\"string\">\"enter B\"</span>)</div><div class=\"line\">        super(B, self).__init__()</div><div class=\"line\">        print(<span class=\"string\">\"leave B\"</span>)</div></pre></td></tr></table></figure></p>\n<p>猜猜输出的是什么？<br>结果输出：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;class '__main__.D'&gt;</div><div class=\"line\">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure></p>\n<p>注意：self输出的是D的instance，而不是B的instance。</p>\n<h1 id=\"sorted排序\"><a href=\"#sorted排序\" class=\"headerlink\" title=\"sorted排序\"></a>sorted排序</h1><p>内建函数sorted()可对<strong>可迭代序列排序</strong>，返回一个排好序的可迭代序列。</p>\n<h2 id=\"sorted函数：\"><a href=\"#sorted函数：\" class=\"headerlink\" title=\"sorted函数：\"></a>sorted函数：</h2><h3 id=\"sorted原型和参数\"><a href=\"#sorted原型和参数\" class=\"headerlink\" title=\"sorted原型和参数\"></a>sorted原型和参数</h3><p>源函数：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sorted(...)</div><div class=\"line\">    sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list</div></pre></td></tr></table></figure></p>\n<p>参数解析：</p>\n<ul>\n<li>iterable：是可迭代类型;</li>\n<li>cmp：用于比较的函数，比较什么由key决定,有默认值，迭代集合中的一项;</li>\n<li>key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;</li>\n<li>reverse：排序规则. reverse = True 或者 reverse = False，默认升序；</li>\n<li>返回值：是一个经过排序的可迭代类型，与iterable一样。</li>\n</ul>\n<h3 id=\"sorted和sort的区别\"><a href=\"#sorted和sort的区别\" class=\"headerlink\" title=\"sorted和sort的区别\"></a>sorted和sort的区别</h3><ul>\n<li>sort仅仅是list的一个方法，其他可迭代序列无此方法；sorted对所有的可迭代序列有效。</li>\n<li>sort是就地排序，排完序后list的本身也改变了；sorted是生成一个新的排好序的序列。</li>\n</ul>\n<p>举例说明：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(lists)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists.sort()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lists</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</div></pre></td></tr></table></figure></p>\n<h2 id=\"sorted函数使用方法详解\"><a href=\"#sorted函数使用方法详解\" class=\"headerlink\" title=\"sorted函数使用方法详解\"></a>sorted函数使用方法详解</h2><p>list.sort()和sorted()都支持key参数，key参数指定一个函数或者表达式等，此函数在<strong>每个元素比较前</strong>被调用。此函数的参数只有一个，并且返回一个值来与其他元素做比较。<br>key指定的函数可以对每个元素快速的作用，所以这个速度其实是很快的。</p>\n<p>在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数，cmp参数指定的函数用来进行元素间的比较。python3.0以后这个参数被废除。</p>\n<p>比如：</p>\n<ol>\n<li><p>不区分大小写的进行排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(<span class=\"string\">\"This is a test string from Andrew\"</span>.split(), key=str.lower)</div><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'Andrew'</span>, <span class=\"string\">'from'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'string'</span>, <span class=\"string\">'test'</span>, <span class=\"string\">'This'</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p>按照年龄排队：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>student_tuples = [</div><div class=\"line\"><span class=\"meta\">... </span>        (<span class=\"string\">'john'</span>, <span class=\"string\">'A'</span>, <span class=\"number\">15</span>),</div><div class=\"line\"><span class=\"meta\">... </span>        (<span class=\"string\">'jane'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">12</span>),</div><div class=\"line\"><span class=\"meta\">... </span>        (<span class=\"string\">'dave'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">10</span>),</div><div class=\"line\"><span class=\"meta\">... </span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(student_tuples, key=<span class=\"keyword\">lambda</span> student: student[<span class=\"number\">2</span>])</div><div class=\"line\">[(<span class=\"string\">'dave'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">10</span>), (<span class=\"string\">'jane'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">12</span>), (<span class=\"string\">'john'</span>, <span class=\"string\">'A'</span>, <span class=\"number\">15</span>)]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted(student_tuples, key=<span class=\"keyword\">lambda</span> student: student[<span class=\"number\">2</span>],reverse=<span class=\"keyword\">True</span>)</div><div class=\"line\">[(<span class=\"string\">'john'</span>, <span class=\"string\">'A'</span>, <span class=\"number\">15</span>), (<span class=\"string\">'jane'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">12</span>), (<span class=\"string\">'dave'</span>, <span class=\"string\">'B'</span>, <span class=\"number\">10</span>)]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用cmp函数来比较大小：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numeric_compare</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> x - y</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>], cmp=numeric_compare)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numeric_compare</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> y - x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>], cmp=numeric_compare)</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"字典排序\"><a href=\"#字典排序\" class=\"headerlink\" title=\"字典排序\"></a>字典排序</h3><ul>\n<li><p>按照字典的value中排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = &#123;<span class=\"number\">1</span>: <span class=\"number\">2</span>, <span class=\"number\">3</span>: <span class=\"number\">4</span>, <span class=\"number\">4</span>: <span class=\"number\">3</span>, <span class=\"number\">2</span>: <span class=\"number\">1</span>, <span class=\"number\">0</span>: <span class=\"number\">0</span>&#125;</div><div class=\"line\">sorted_value = sorted(x.iteritems(), key=<span class=\"keyword\">lambda</span> e: e[<span class=\"number\">1</span>])</div><div class=\"line\"><span class=\"keyword\">print</span> sorted_value</div><div class=\"line\">sorte_values = sorted(x.iteritems(), key=<span class=\"keyword\">lambda</span> e: e[<span class=\"number\">1</span>], reverse=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> sorte_values</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出</span></div><div class=\"line\">[(<span class=\"number\">0</span>, <span class=\"number\">0</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">4</span>, <span class=\"number\">3</span>), (<span class=\"number\">3</span>, <span class=\"number\">4</span>)]</div><div class=\"line\">[(<span class=\"number\">3</span>, <span class=\"number\">4</span>), (<span class=\"number\">4</span>, <span class=\"number\">3</span>), (<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">0</span>, <span class=\"number\">0</span>)]</div></pre></td></tr></table></figure>\n</li>\n<li><p>list的元素是dict，排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = [&#123;<span class=\"string\">'name'</span>: <span class=\"string\">'Homer'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">9</span>&#125;, &#123;<span class=\"string\">'name'</span>: <span class=\"string\">'Bart'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">10</span>&#125;]</div><div class=\"line\">values = sorted(x, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"string\">'name'</span>])</div><div class=\"line\">value = sorted(x, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"string\">'age'</span>])</div><div class=\"line\"><span class=\"keyword\">print</span> values</div><div class=\"line\"><span class=\"keyword\">print</span> value</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出</span></div><div class=\"line\">[&#123;<span class=\"string\">'age'</span>: <span class=\"number\">10</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bart'</span>&#125;, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">9</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Homer'</span>&#125;]</div><div class=\"line\">[&#123;<span class=\"string\">'age'</span>: <span class=\"number\">9</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Homer'</span>&#125;, &#123;<span class=\"string\">'age'</span>: <span class=\"number\">10</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bart'</span>&#125;]</div></pre></td></tr></table></figure>\n</li>\n<li><p>按照字典value的某个元素排序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">myDict = &#123;<span class=\"string\">'item1'</span>: [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>], <span class=\"string\">'item2'</span>: [<span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"string\">'item3'</span>: [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>]&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortDic</span><span class=\"params\">(Dict, valuePostion)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> sorted(Dict.items(), key=<span class=\"keyword\">lambda</span> e: e[<span class=\"number\">1</span>][valuePostion])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 按value的第3个值排序</span></div><div class=\"line\"><span class=\"keyword\">print</span> sortDic(myDict, <span class=\"number\">2</span>)</div><div class=\"line\">[(<span class=\"string\">'item2'</span>, [<span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), (<span class=\"string\">'item1'</span>, [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>]), (<span class=\"string\">'item3'</span>, [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>])]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 按value的第1个值排序</span></div><div class=\"line\"><span class=\"keyword\">print</span> sortDic(myDict, <span class=\"number\">0</span>)</div><div class=\"line\">[(<span class=\"string\">'item1'</span>, [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>]), (<span class=\"string\">'item2'</span>, [<span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), (<span class=\"string\">'item3'</span>, [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>])]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"with上下文管理器\"><a href=\"#with上下文管理器\" class=\"headerlink\" title=\"with上下文管理器\"></a>with上下文管理器</h1><h1 id=\"获取脚本的执行路径问题\"><a href=\"#获取脚本的执行路径问题\" class=\"headerlink\" title=\"获取脚本的执行路径问题\"></a>获取脚本的执行路径问题</h1><p>Python中有两种方法能获取到执行脚本的文件路径，一种是<strong>“<strong>file</strong>“</strong>，一种是<strong>“sys.argv[0]”</strong>。</p>\n<h2 id=\"主执行文件，获取执行脚本路径\"><a href=\"#主执行文件，获取执行脚本路径\" class=\"headerlink\" title=\"主执行文件，获取执行脚本路径\"></a>主执行文件，获取执行脚本路径</h2><p>在主执行文件中，<strong>“<strong>file</strong>“</strong>和sys.argv[0]区别不大，都是根据的到执行该脚本的方式不同，而得到绝对路径或者相对路径。<br>如下所示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#-*-coding:utf-8-*-</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"__file__    --------&gt;%s\"</span>%__file__</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"sys.argv[0] --------&gt;%s\"</span>%sys.argv[<span class=\"number\">0</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</div><div class=\"line\">[root@localhost workspace]# ./test.py</div><div class=\"line\">__file__    --------&gt;./test.py</div><div class=\"line\">sys.argv[0] --------&gt;./test.py</div><div class=\"line\">[root@localhost workspace]# /root/workspace/test.py</div><div class=\"line\">__file__    --------&gt;/root/workspace/test.py</div><div class=\"line\">sys.argv[0] --------&gt;/root/workspace/test.py</div><div class=\"line\">[root@localhost workspace]# ~/workspace/test.py</div><div class=\"line\">__file__    --------&gt;/root/workspace/test.py</div><div class=\"line\">sys.argv[0] --------&gt;/root/workspace/test.py</div><div class=\"line\">\"\"\"</span></div></pre></td></tr></table></figure></p>\n<p>由上面的测试可以看到，此两种获取路径的方式都是由执行脚本的方式不同，而结果是相对路径或者绝对路径，可以通过<strong>os.path.abspath()</strong>函数来取得执行脚本的绝对路径。<br>以上说明<strong>在主文件中执行的时候，这两种方式没什么区别。</strong></p>\n<h2 id=\"非主执行文件，import其他文件，获取执行脚本路径\"><a href=\"#非主执行文件，import其他文件，获取执行脚本路径\" class=\"headerlink\" title=\"非主执行文件，import其他文件，获取执行脚本路径\"></a>非主执行文件，import其他文件，获取执行脚本路径</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># test_1.py脚本，主执行脚本</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"__file__    --------&gt;%s\"</span>%__file__</div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"sys.argv[0] --------&gt;%s\"</span>%sys.argv[<span class=\"number\">0</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> test_2</div><div class=\"line\">test_2.show_path()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># test_2.py脚本，供其他文件引入的脚本，非主执行文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">show_path</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"show_path:__file__    --------&gt;%s\"</span>%__file__</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"show_path:sys.argv[0] --------&gt;%s\"</span>%sys.argv[<span class=\"number\">0</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出结果：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</div><div class=\"line\">__file__    --------&gt;./test_1.py</div><div class=\"line\">sys.argv[0] --------&gt;./test_1.py</div><div class=\"line\">show_path:__file__    --------&gt;/root/workspace/test_2.py</div><div class=\"line\">show_path:sys.argv[0] --------&gt;./test_1.py</div><div class=\"line\">\"\"\"</span></div></pre></td></tr></table></figure>\n<p>以上结果说明，<strong>“<strong>file</strong>“</strong>得到的不一定是主文件的执行路径，而是那个脚本中的<strong><strong>file</strong></strong>，则得到是那个脚本的路径，而<strong>sys.argv[0]</strong>得到的是永远是主执行文件的路径，这个很好理解，因为sys.argv[0]本质上就是脚本命令行的第一个参数，那么这个脚本是什么，肯定得到的第一个参数就是什么。</p>\n<p><strong>以上结果说明：当需要获取执行脚本的路径的时候，sys.argv[0]比<strong>file</strong>更靠谱一些。</strong></p>\n<p><a href=\"https://laike9m.com/blog/li-jie-python-super,70/\">super解释非常好的博客</a>，感谢作者！</p>"},{"title":"Python命令行解析详解","date":"2016-04-19T11:05:22.000Z","toc":true,"comments":1,"_content":"\nPython的内建的标准库中提供了一些模块，用于编写用户友好式的命令行接口。本文试图总结Python主流的命令行解析标准库。\n\n> * argparse模块\n> * sys.argv\n> * getopt模块\n\n<!-- more -->\n# argparse模块\n**arpgarse**是Python中最强大的一个命令行解析的内建的标准库。程序负责定义好要求的参数，然后**argparse**将从**sys.argv**列表中去解析这些参数。\n## 创建解析器\nargparse的第一步首先是创建一个解析器，即先创建一个**ArgumentParser**对象，这个对象将用于保存把命令行解析成Python的数据类型所需要的所有的信息。\n```python\n>>> import argparse\n>>> parser = argparse.ArgumentParser(description=\"Get the baseline data\")\n>>> print parser\nArgumentParser(prog='', usage=None, description='Get the baseline data', version=None, formatter_class=<class 'argparse.HelpFormatter'>, conflict_handler='error', add_help=True)\n```\n## 给解析器添加参数\n```python\n>>> import argparse\n>>> parser = argparse.ArgumentParser(description=\"Get the baseline data\")\n>>> parser.add_argument('-f', '--file', help='file path')\n>>> parser.add_argument('--sum', dest='accumulate', action='store_const',const=sum, default=max,help='sum the integers (default: find the max)')\n>>>\n\"\"\"\n输出：\n>>> parser.add_argument('-f', '--file', help='file path')\n_StoreAction(option_strings=['-f', '--file'], dest='file', nargs=None, const=None, default=None, type=None, choices=None, help='file path', metavar=None)\n>>> parser.add_argument('--sum', dest='accumulate', action='store_const',const=sum, default=max,help='sum the integers (default: find the max)')\n_StoreConstAction(option_strings=['--sum'], dest='accumulate', nargs=0, const=<built-in function sum>, default=<built-in function max>, type=None, choices=None, help='sum the integers (default: find the max)', metavar=None)\n\"\"\"\n```\n给解析器添加参数后，接下来解析参数的时候，解析参数的函数返回的对象中将带有两个属性。\n## 解析参数\n```python\n>>> parser.parse_args()\nNamespace(accumulate=<built-in function max>, file=None)\n```\nArgumentParser用方法**parse_args()**解析参数，这个函数会检查命令行，把每个参数转换成Python的数据类型，并采取相应的action。绝大部分情况下，解析函数从命令行解析出来的属性建一个简单的**NameSpace**对象。\n在脚本中，**parse_args()**的调用一般不带参数，**ArgumentParser**将根据**sys.argv**来自动确定命令行参数。\n\n\n## 模块的主要对象和主要函数介绍\n### ArgumentParser对象的说明\n```python\n#类原型\nclass argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True)\n\n#创建一个新的ArgumentParser对象。所有的参数应该以关键字参数传递。下面对参数做简单的介绍，它们是：\n\"\"\"\nprog - 程序的名字（默认：sys.argv[0]），一般根据sys.argv[0]来决定在帮助信息中如何显示程序的名字.\nusage - 描述程序用法的字符串（默认：从解析器的参数生成）\ndescription - 参数帮助信息之前的文本（默认：空）\nepilog - 参数帮助信息之后的文本（默认：空）,就是帮助信息完了后输出的字符串\nparents - ArgumentParser 对象的一个列表，这些对象的参数添加到正在构建的ArgumentParser对象\nformatter_class - 定制化帮助信息的类，丰富了帮助信息\nprefix_chars - 可选参数的前缀字符集（默认：'-'），就是\"-f/--foo\"，有些参数可能是'+f'，此时用该参数去指定。\nfromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None）\nargument_default - 参数的全局默认值（默认：None）\nconflict_handler - 解决冲突的可选参数的策略（通常没有必要）\nadd_help - 给解析器添加-h/–help 选项（默认：True）\n\"\"\"\n```\n### add_argument()方法说明\n```python\n#函数原型\nArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])\n\n#定义应该如何解析一个命令行参数。下面每个参数的简单介绍：\n\"\"\"\nname or flags - 选项字符串的名字或者列表，例如foo 或者-f, --foo。\naction - 在命令行遇到该参数时采取的基本动作类型。默认为'store',即保存参数的值。含有计算参数出现的次数，保存参数列表等\nnargs - 应该读取的命令行参数数目。\nconst - 某些action和nargs选项要求的常数值。\ndefault - 如果命令行中没有出现该参数时的默认值。\ntype - 命令行参数应该被转换成的类型。默认是字符串方式读入命令行参数，有时候可能需要解析成整数，浮点数等类型\nchoices - 参数可允许的值的一个容器。\nrequired - 该命令行选项是否可以省略（只针对可选参数）。\nhelp - 参数的简短描述。\nmetavar - 参数在帮助信息中的名字。\ndest - 给parse_args()返回的对象要添加的属性名称。\n\"\"\"\n```\n### Namespace对象\n```python\nclass argparse.Namespace\n```\n**parse_args()方法**使用**Namespace**类，用于创建一个保存属性的对象并返回该对象。\n这个类设计的很简单，只是**object**这个类的一个可读可打印的字符串的子类。也可以用Python的内建语句**vars()**来以字典的方式查看其属性。\n```python\n>>> parser = argparse.ArgumentParser()\n>>> parser.add_argument('-foo')\n>>> args = parser.parse_args(['-foo','BAR'])\n>>> vars(args)\n{'foo': 'BAR'}\n```\n\n# getopt模块\ngetopt模块用于抽出命令行参数和选，是一个命令行参数解析器。兼容C语言的getopt函数。\n## 模块的主要对象和主要函数介绍\n### getopt.getopt()函数说明\n```python\n#函数原型\ngetopt.getopt(args, options[, long_options])\n#参数定义：\n\"\"\"\nargs：命令行参数列表\noptions： 短格式参数（string），如：'abc:o'\nlong_options: 长格式参数（list）,如： ['condition=', 'output-file=', 'testing']\n#注解\n当args中出现短格式参数或者长格式参数列表没有的参数的时候；或者当短格式参数和长格式参数中定义了必须有的参数，即含有\":\"或者\"=\"的时候，但是args中没出现该参数的时候，均会报错，异常类为：getopt.GetoptError: option -x not recognized。\n\"\"\"\n```\n**getopt.getopt()**函数解析方法：\n\n - 短格式参数：当字母后面带有\":\"的时候，表示整个参数是需要带参数的，函数在解析的时候，会把这个命令行参数中紧随-o后面的参数解析为-o的参数。字符后面不带\":\"的表明该字符是不需要参数的，即不会把紧随这个字符后面的参数解析为该短格式字符的参数。\n - 长格式参数列表：当列表中某个元素的后面后面有\"=\"的时候，表明这个字符串必须有参数，不带参数会报错，getopt会把紧随这个字符串后面的参数解析为这个字符串的参数；如果没有不带\"=\"的参数表明这个字符串是没有参数的，即不会解析紧随这个字符串后面的字符串串为参数。\n\n**getopt.getopt()**函数返回值（返回两个list）：\n\n - 第一个参数opts：list的元素是每个参数选项和其value的元组\n - 第二个参数args：除了有用参数外的其他命令行的输入，也是一个list\n\n**示例**\n短格式参数：\n```python\n>>> import getopt\n>>> args = '-a -b -cfoo -d bar a1 a2'.split()\n>>> args\n['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']\n>>> opts, args = getopt.getopt(args,'abc:d:')\n>>> opts\n[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]\n>>> args\n['a1', 'a2']\n```\n长格式参数：\n```python\n>>> import getopt\n>>> args = '--condition=foo --testing --output-file abc.def -x a1 a2'.split()\n>>> args\n['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']\n>>> optlist, args = getopt.getopt(args, 'x', [\n...     'condition=', 'output-file=', 'testing'])\n>>> optlist\n[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x', '')]\n>>> args\n['a1', 'a2']\n```\n程序中使用该模块举例：\n```python\nimport getopt\nimport sys\n\ndef usage():\n    print(\"Usage:%s [-h|-o|-v] [--help|--output] args....\" %sys.argv[0]);\n\ndef main():\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", \"output=\"])\n    except getopt.GetoptError as err:\n        print str(err)\n        usage()\n        sys.exit(2)\n    output = None\n    verbose = False\n    for o , a in opts:\n        if o == '-v':\n            verbose = True\n        elif o in (\"-h\", \"--help\"):\n            usage()\n            sys.exit()\n        else:\n            assert False, 'unhandled option'\n\nif __name__ == \"__main__\":\n    main()\n```\n\n[argparse模块](http://python.usyiyi.cn/python_278/library/argparse.html)\n","source":"_posts/Python命令行解析详解.md","raw":"---\ntitle: Python命令行解析详解\ndate: 2016-04-19 19:05:22\ntags: Python命令行解析\ncategories: Python之聚石塔\ntoc: true\ncomments: true\n---\n\nPython的内建的标准库中提供了一些模块，用于编写用户友好式的命令行接口。本文试图总结Python主流的命令行解析标准库。\n\n> * argparse模块\n> * sys.argv\n> * getopt模块\n\n<!-- more -->\n# argparse模块\n**arpgarse**是Python中最强大的一个命令行解析的内建的标准库。程序负责定义好要求的参数，然后**argparse**将从**sys.argv**列表中去解析这些参数。\n## 创建解析器\nargparse的第一步首先是创建一个解析器，即先创建一个**ArgumentParser**对象，这个对象将用于保存把命令行解析成Python的数据类型所需要的所有的信息。\n```python\n>>> import argparse\n>>> parser = argparse.ArgumentParser(description=\"Get the baseline data\")\n>>> print parser\nArgumentParser(prog='', usage=None, description='Get the baseline data', version=None, formatter_class=<class 'argparse.HelpFormatter'>, conflict_handler='error', add_help=True)\n```\n## 给解析器添加参数\n```python\n>>> import argparse\n>>> parser = argparse.ArgumentParser(description=\"Get the baseline data\")\n>>> parser.add_argument('-f', '--file', help='file path')\n>>> parser.add_argument('--sum', dest='accumulate', action='store_const',const=sum, default=max,help='sum the integers (default: find the max)')\n>>>\n\"\"\"\n输出：\n>>> parser.add_argument('-f', '--file', help='file path')\n_StoreAction(option_strings=['-f', '--file'], dest='file', nargs=None, const=None, default=None, type=None, choices=None, help='file path', metavar=None)\n>>> parser.add_argument('--sum', dest='accumulate', action='store_const',const=sum, default=max,help='sum the integers (default: find the max)')\n_StoreConstAction(option_strings=['--sum'], dest='accumulate', nargs=0, const=<built-in function sum>, default=<built-in function max>, type=None, choices=None, help='sum the integers (default: find the max)', metavar=None)\n\"\"\"\n```\n给解析器添加参数后，接下来解析参数的时候，解析参数的函数返回的对象中将带有两个属性。\n## 解析参数\n```python\n>>> parser.parse_args()\nNamespace(accumulate=<built-in function max>, file=None)\n```\nArgumentParser用方法**parse_args()**解析参数，这个函数会检查命令行，把每个参数转换成Python的数据类型，并采取相应的action。绝大部分情况下，解析函数从命令行解析出来的属性建一个简单的**NameSpace**对象。\n在脚本中，**parse_args()**的调用一般不带参数，**ArgumentParser**将根据**sys.argv**来自动确定命令行参数。\n\n\n## 模块的主要对象和主要函数介绍\n### ArgumentParser对象的说明\n```python\n#类原型\nclass argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True)\n\n#创建一个新的ArgumentParser对象。所有的参数应该以关键字参数传递。下面对参数做简单的介绍，它们是：\n\"\"\"\nprog - 程序的名字（默认：sys.argv[0]），一般根据sys.argv[0]来决定在帮助信息中如何显示程序的名字.\nusage - 描述程序用法的字符串（默认：从解析器的参数生成）\ndescription - 参数帮助信息之前的文本（默认：空）\nepilog - 参数帮助信息之后的文本（默认：空）,就是帮助信息完了后输出的字符串\nparents - ArgumentParser 对象的一个列表，这些对象的参数添加到正在构建的ArgumentParser对象\nformatter_class - 定制化帮助信息的类，丰富了帮助信息\nprefix_chars - 可选参数的前缀字符集（默认：'-'），就是\"-f/--foo\"，有些参数可能是'+f'，此时用该参数去指定。\nfromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None）\nargument_default - 参数的全局默认值（默认：None）\nconflict_handler - 解决冲突的可选参数的策略（通常没有必要）\nadd_help - 给解析器添加-h/–help 选项（默认：True）\n\"\"\"\n```\n### add_argument()方法说明\n```python\n#函数原型\nArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])\n\n#定义应该如何解析一个命令行参数。下面每个参数的简单介绍：\n\"\"\"\nname or flags - 选项字符串的名字或者列表，例如foo 或者-f, --foo。\naction - 在命令行遇到该参数时采取的基本动作类型。默认为'store',即保存参数的值。含有计算参数出现的次数，保存参数列表等\nnargs - 应该读取的命令行参数数目。\nconst - 某些action和nargs选项要求的常数值。\ndefault - 如果命令行中没有出现该参数时的默认值。\ntype - 命令行参数应该被转换成的类型。默认是字符串方式读入命令行参数，有时候可能需要解析成整数，浮点数等类型\nchoices - 参数可允许的值的一个容器。\nrequired - 该命令行选项是否可以省略（只针对可选参数）。\nhelp - 参数的简短描述。\nmetavar - 参数在帮助信息中的名字。\ndest - 给parse_args()返回的对象要添加的属性名称。\n\"\"\"\n```\n### Namespace对象\n```python\nclass argparse.Namespace\n```\n**parse_args()方法**使用**Namespace**类，用于创建一个保存属性的对象并返回该对象。\n这个类设计的很简单，只是**object**这个类的一个可读可打印的字符串的子类。也可以用Python的内建语句**vars()**来以字典的方式查看其属性。\n```python\n>>> parser = argparse.ArgumentParser()\n>>> parser.add_argument('-foo')\n>>> args = parser.parse_args(['-foo','BAR'])\n>>> vars(args)\n{'foo': 'BAR'}\n```\n\n# getopt模块\ngetopt模块用于抽出命令行参数和选，是一个命令行参数解析器。兼容C语言的getopt函数。\n## 模块的主要对象和主要函数介绍\n### getopt.getopt()函数说明\n```python\n#函数原型\ngetopt.getopt(args, options[, long_options])\n#参数定义：\n\"\"\"\nargs：命令行参数列表\noptions： 短格式参数（string），如：'abc:o'\nlong_options: 长格式参数（list）,如： ['condition=', 'output-file=', 'testing']\n#注解\n当args中出现短格式参数或者长格式参数列表没有的参数的时候；或者当短格式参数和长格式参数中定义了必须有的参数，即含有\":\"或者\"=\"的时候，但是args中没出现该参数的时候，均会报错，异常类为：getopt.GetoptError: option -x not recognized。\n\"\"\"\n```\n**getopt.getopt()**函数解析方法：\n\n - 短格式参数：当字母后面带有\":\"的时候，表示整个参数是需要带参数的，函数在解析的时候，会把这个命令行参数中紧随-o后面的参数解析为-o的参数。字符后面不带\":\"的表明该字符是不需要参数的，即不会把紧随这个字符后面的参数解析为该短格式字符的参数。\n - 长格式参数列表：当列表中某个元素的后面后面有\"=\"的时候，表明这个字符串必须有参数，不带参数会报错，getopt会把紧随这个字符串后面的参数解析为这个字符串的参数；如果没有不带\"=\"的参数表明这个字符串是没有参数的，即不会解析紧随这个字符串后面的字符串串为参数。\n\n**getopt.getopt()**函数返回值（返回两个list）：\n\n - 第一个参数opts：list的元素是每个参数选项和其value的元组\n - 第二个参数args：除了有用参数外的其他命令行的输入，也是一个list\n\n**示例**\n短格式参数：\n```python\n>>> import getopt\n>>> args = '-a -b -cfoo -d bar a1 a2'.split()\n>>> args\n['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']\n>>> opts, args = getopt.getopt(args,'abc:d:')\n>>> opts\n[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]\n>>> args\n['a1', 'a2']\n```\n长格式参数：\n```python\n>>> import getopt\n>>> args = '--condition=foo --testing --output-file abc.def -x a1 a2'.split()\n>>> args\n['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']\n>>> optlist, args = getopt.getopt(args, 'x', [\n...     'condition=', 'output-file=', 'testing'])\n>>> optlist\n[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x', '')]\n>>> args\n['a1', 'a2']\n```\n程序中使用该模块举例：\n```python\nimport getopt\nimport sys\n\ndef usage():\n    print(\"Usage:%s [-h|-o|-v] [--help|--output] args....\" %sys.argv[0]);\n\ndef main():\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", \"output=\"])\n    except getopt.GetoptError as err:\n        print str(err)\n        usage()\n        sys.exit(2)\n    output = None\n    verbose = False\n    for o , a in opts:\n        if o == '-v':\n            verbose = True\n        elif o in (\"-h\", \"--help\"):\n            usage()\n            sys.exit()\n        else:\n            assert False, 'unhandled option'\n\nif __name__ == \"__main__\":\n    main()\n```\n\n[argparse模块](http://python.usyiyi.cn/python_278/library/argparse.html)\n","slug":"Python命令行解析详解","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoironc0002ta024uxmmttl","content":"<p>Python的内建的标准库中提供了一些模块，用于编写用户友好式的命令行接口。本文试图总结Python主流的命令行解析标准库。</p>\n<blockquote>\n<ul>\n<li>argparse模块</li>\n<li>sys.argv</li>\n<li>getopt模块</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"argparse模块\"><a href=\"#argparse模块\" class=\"headerlink\" title=\"argparse模块\"></a>argparse模块</h1><p><strong>arpgarse</strong>是Python中最强大的一个命令行解析的内建的标准库。程序负责定义好要求的参数，然后<strong>argparse</strong>将从<strong>sys.argv</strong>列表中去解析这些参数。</p>\n<h2 id=\"创建解析器\"><a href=\"#创建解析器\" class=\"headerlink\" title=\"创建解析器\"></a>创建解析器</h2><p>argparse的第一步首先是创建一个解析器，即先创建一个<strong>ArgumentParser</strong>对象，这个对象将用于保存把命令行解析成Python的数据类型所需要的所有的信息。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; import argparse</div><div class=\"line\">&gt;&gt;&gt; parser = argparse.ArgumentParser(description=\"Get the baseline data\")</div><div class=\"line\">&gt;&gt;&gt; print parser</div><div class=\"line\">ArgumentParser(prog='', usage=None, description='Get the baseline data', version=None, formatter_class=&lt;class 'argparse.HelpFormatter'&gt;, conflict_handler='error', add_help=True)</div></pre></td></tr></table></figure></p>\n<h2 id=\"给解析器添加参数\"><a href=\"#给解析器添加参数\" class=\"headerlink\" title=\"给解析器添加参数\"></a>给解析器添加参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> argparse</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(description=<span class=\"string\">\"Get the baseline data\"</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--file'</span>, help=<span class=\"string\">'file path'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument(<span class=\"string\">'--sum'</span>, dest=<span class=\"string\">'accumulate'</span>, action=<span class=\"string\">'store_const'</span>,const=sum, default=max,help=<span class=\"string\">'sum the integers (default: find the max)'</span>)</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">输出：</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument('-f', '--file', help='file path')</div><div class=\"line\">_StoreAction(option_strings=['-f', '--file'], dest='file', nargs=None, const=None, default=None, type=None, choices=None, help='file path', metavar=None)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument('--sum', dest='accumulate', action='store_const',const=sum, default=max,help='sum the integers (default: find the max)')</div><div class=\"line\">_StoreConstAction(option_strings=['--sum'], dest='accumulate', nargs=0, const=&lt;built-in function sum&gt;, default=&lt;built-in function max&gt;, type=None, choices=None, help='sum the integers (default: find the max)', metavar=None)</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<p>给解析器添加参数后，接下来解析参数的时候，解析参数的函数返回的对象中将带有两个属性。</p>\n<h2 id=\"解析参数\"><a href=\"#解析参数\" class=\"headerlink\" title=\"解析参数\"></a>解析参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.parse_args()</div><div class=\"line\">Namespace(accumulate=&lt;built-<span class=\"keyword\">in</span> function max&gt;, file=<span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>\n<p>ArgumentParser用方法<strong>parse_args()</strong>解析参数，这个函数会检查命令行，把每个参数转换成Python的数据类型，并采取相应的action。绝大部分情况下，解析函数从命令行解析出来的属性建一个简单的<strong>NameSpace</strong>对象。<br>在脚本中，<strong>parse_args()</strong>的调用一般不带参数，<strong>ArgumentParser</strong>将根据<strong>sys.argv</strong>来自动确定命令行参数。</p>\n<h2 id=\"模块的主要对象和主要函数介绍\"><a href=\"#模块的主要对象和主要函数介绍\" class=\"headerlink\" title=\"模块的主要对象和主要函数介绍\"></a>模块的主要对象和主要函数介绍</h2><h3 id=\"ArgumentParser对象的说明\"><a href=\"#ArgumentParser对象的说明\" class=\"headerlink\" title=\"ArgumentParser对象的说明\"></a>ArgumentParser对象的说明</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#类原型</div><div class=\"line\">class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True)</div><div class=\"line\"></div><div class=\"line\">#创建一个新的ArgumentParser对象。所有的参数应该以关键字参数传递。下面对参数做简单的介绍，它们是：</div><div class=\"line\">\"\"\"</div><div class=\"line\">prog - 程序的名字（默认：sys.argv[0]），一般根据sys.argv[0]来决定在帮助信息中如何显示程序的名字.</div><div class=\"line\">usage - 描述程序用法的字符串（默认：从解析器的参数生成）</div><div class=\"line\">description - 参数帮助信息之前的文本（默认：空）</div><div class=\"line\">epilog - 参数帮助信息之后的文本（默认：空）,就是帮助信息完了后输出的字符串</div><div class=\"line\">parents - ArgumentParser 对象的一个列表，这些对象的参数添加到正在构建的ArgumentParser对象</div><div class=\"line\">formatter_class - 定制化帮助信息的类，丰富了帮助信息</div><div class=\"line\">prefix_chars - 可选参数的前缀字符集（默认：'-'），就是\"-f/--foo\"，有些参数可能是'+f'，此时用该参数去指定。</div><div class=\"line\">fromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None）</div><div class=\"line\">argument_default - 参数的全局默认值（默认：None）</div><div class=\"line\">conflict_handler - 解决冲突的可选参数的策略（通常没有必要）</div><div class=\"line\">add_help - 给解析器添加-h/–help 选项（默认：True）</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<h3 id=\"add-argument-方法说明\"><a href=\"#add-argument-方法说明\" class=\"headerlink\" title=\"add_argument()方法说明\"></a>add_argument()方法说明</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#函数原型</span></div><div class=\"line\">ArgumentParser.add_argument(name <span class=\"keyword\">or</span> flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#定义应该如何解析一个命令行参数。下面每个参数的简单介绍：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">name or flags - 选项字符串的名字或者列表，例如foo 或者-f, --foo。</div><div class=\"line\">action - 在命令行遇到该参数时采取的基本动作类型。默认为'store',即保存参数的值。含有计算参数出现的次数，保存参数列表等</div><div class=\"line\">nargs - 应该读取的命令行参数数目。</div><div class=\"line\">const - 某些action和nargs选项要求的常数值。</div><div class=\"line\">default - 如果命令行中没有出现该参数时的默认值。</div><div class=\"line\">type - 命令行参数应该被转换成的类型。默认是字符串方式读入命令行参数，有时候可能需要解析成整数，浮点数等类型</div><div class=\"line\">choices - 参数可允许的值的一个容器。</div><div class=\"line\">required - 该命令行选项是否可以省略（只针对可选参数）。</div><div class=\"line\">help - 参数的简短描述。</div><div class=\"line\">metavar - 参数在帮助信息中的名字。</div><div class=\"line\">dest - 给parse_args()返回的对象要添加的属性名称。</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<h3 id=\"Namespace对象\"><a href=\"#Namespace对象\" class=\"headerlink\" title=\"Namespace对象\"></a>Namespace对象</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">argparse</span>.<span class=\"title\">Namespace</span></span></div></pre></td></tr></table></figure>\n<p><strong>parse_args()方法</strong>使用<strong>Namespace</strong>类，用于创建一个保存属性的对象并返回该对象。<br>这个类设计的很简单，只是<strong>object</strong>这个类的一个可读可打印的字符串的子类。也可以用Python的内建语句<strong>vars()</strong>来以字典的方式查看其属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument(<span class=\"string\">'-foo'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args = parser.parse_args([<span class=\"string\">'-foo'</span>,<span class=\"string\">'BAR'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>vars(args)</div><div class=\"line\">&#123;<span class=\"string\">'foo'</span>: <span class=\"string\">'BAR'</span>&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"getopt模块\"><a href=\"#getopt模块\" class=\"headerlink\" title=\"getopt模块\"></a>getopt模块</h1><p>getopt模块用于抽出命令行参数和选，是一个命令行参数解析器。兼容C语言的getopt函数。</p>\n<h2 id=\"模块的主要对象和主要函数介绍-1\"><a href=\"#模块的主要对象和主要函数介绍-1\" class=\"headerlink\" title=\"模块的主要对象和主要函数介绍\"></a>模块的主要对象和主要函数介绍</h2><h3 id=\"getopt-getopt-函数说明\"><a href=\"#getopt-getopt-函数说明\" class=\"headerlink\" title=\"getopt.getopt()函数说明\"></a>getopt.getopt()函数说明</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#函数原型</span></div><div class=\"line\">getopt.getopt(args, options[, long_options])</div><div class=\"line\"><span class=\"comment\">#参数定义：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">args：命令行参数列表</div><div class=\"line\">options： 短格式参数（string），如：'abc:o'</div><div class=\"line\">long_options: 长格式参数（list）,如： ['condition=', 'output-file=', 'testing']</div><div class=\"line\">#注解</div><div class=\"line\">当args中出现短格式参数或者长格式参数列表没有的参数的时候；或者当短格式参数和长格式参数中定义了必须有的参数，即含有\":\"或者\"=\"的时候，但是args中没出现该参数的时候，均会报错，异常类为：getopt.GetoptError: option -x not recognized。</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<p><strong>getopt.getopt()</strong>函数解析方法：</p>\n<ul>\n<li>短格式参数：当字母后面带有”:”的时候，表示整个参数是需要带参数的，函数在解析的时候，会把这个命令行参数中紧随-o后面的参数解析为-o的参数。字符后面不带”:”的表明该字符是不需要参数的，即不会把紧随这个字符后面的参数解析为该短格式字符的参数。</li>\n<li>长格式参数列表：当列表中某个元素的后面后面有”=”的时候，表明这个字符串必须有参数，不带参数会报错，getopt会把紧随这个字符串后面的参数解析为这个字符串的参数；如果没有不带”=”的参数表明这个字符串是没有参数的，即不会解析紧随这个字符串后面的字符串串为参数。</li>\n</ul>\n<p><strong>getopt.getopt()</strong>函数返回值（返回两个list）：</p>\n<ul>\n<li>第一个参数opts：list的元素是每个参数选项和其value的元组</li>\n<li>第二个参数args：除了有用参数外的其他命令行的输入，也是一个list</li>\n</ul>\n<p><strong>示例</strong><br>短格式参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> getopt</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args = <span class=\"string\">'-a -b -cfoo -d bar a1 a2'</span>.split()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'-a'</span>, <span class=\"string\">'-b'</span>, <span class=\"string\">'-cfoo'</span>, <span class=\"string\">'-d'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>opts, args = getopt.getopt(args,<span class=\"string\">'abc:d:'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>opts</div><div class=\"line\">[(<span class=\"string\">'-a'</span>, <span class=\"string\">''</span>), (<span class=\"string\">'-b'</span>, <span class=\"string\">''</span>), (<span class=\"string\">'-c'</span>, <span class=\"string\">'foo'</span>), (<span class=\"string\">'-d'</span>, <span class=\"string\">'bar'</span>)]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div></pre></td></tr></table></figure></p>\n<p>长格式参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> getopt</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args = <span class=\"string\">'--condition=foo --testing --output-file abc.def -x a1 a2'</span>.split()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'--condition=foo'</span>, <span class=\"string\">'--testing'</span>, <span class=\"string\">'--output-file'</span>, <span class=\"string\">'abc.def'</span>, <span class=\"string\">'-x'</span>, <span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>optlist, args = getopt.getopt(args, <span class=\"string\">'x'</span>, [</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'condition='</span>, <span class=\"string\">'output-file='</span>, <span class=\"string\">'testing'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>optlist</div><div class=\"line\">[(<span class=\"string\">'--condition'</span>, <span class=\"string\">'foo'</span>), (<span class=\"string\">'--testing'</span>, <span class=\"string\">''</span>), (<span class=\"string\">'--output-file'</span>, <span class=\"string\">'abc.def'</span>), (<span class=\"string\">'-x'</span>, <span class=\"string\">''</span>)]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div></pre></td></tr></table></figure></p>\n<p>程序中使用该模块举例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> getopt</div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">usage</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"Usage:%s [-h|-o|-v] [--help|--output] args....\"</span> %sys.argv[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        opts, args = getopt.getopt(sys.argv[<span class=\"number\">1</span>:], <span class=\"string\">\"ho:v\"</span>, [<span class=\"string\">\"help\"</span>, <span class=\"string\">\"output=\"</span>])</div><div class=\"line\">    <span class=\"keyword\">except</span> getopt.GetoptError <span class=\"keyword\">as</span> err:</div><div class=\"line\">        <span class=\"keyword\">print</span> str(err)</div><div class=\"line\">        usage()</div><div class=\"line\">        sys.exit(<span class=\"number\">2</span>)</div><div class=\"line\">    output = <span class=\"keyword\">None</span></div><div class=\"line\">    verbose = <span class=\"keyword\">False</span></div><div class=\"line\">    <span class=\"keyword\">for</span> o , a <span class=\"keyword\">in</span> opts:</div><div class=\"line\">        <span class=\"keyword\">if</span> o == <span class=\"string\">'-v'</span>:</div><div class=\"line\">            verbose = <span class=\"keyword\">True</span></div><div class=\"line\">        <span class=\"keyword\">elif</span> o <span class=\"keyword\">in</span> (<span class=\"string\">\"-h\"</span>, <span class=\"string\">\"--help\"</span>):</div><div class=\"line\">            usage()</div><div class=\"line\">            sys.exit()</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            <span class=\"keyword\">assert</span> <span class=\"keyword\">False</span>, <span class=\"string\">'unhandled option'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure></p>\n<p><a href=\"http://python.usyiyi.cn/python_278/library/argparse.html\" target=\"_blank\" rel=\"external\">argparse模块</a></p>\n","excerpt":"<p>Python的内建的标准库中提供了一些模块，用于编写用户友好式的命令行接口。本文试图总结Python主流的命令行解析标准库。</p>\n<blockquote>\n<ul>\n<li>argparse模块</li>\n<li>sys.argv</li>\n<li>getopt模块</li>\n</ul>\n</blockquote>","more":"<h1 id=\"argparse模块\"><a href=\"#argparse模块\" class=\"headerlink\" title=\"argparse模块\"></a>argparse模块</h1><p><strong>arpgarse</strong>是Python中最强大的一个命令行解析的内建的标准库。程序负责定义好要求的参数，然后<strong>argparse</strong>将从<strong>sys.argv</strong>列表中去解析这些参数。</p>\n<h2 id=\"创建解析器\"><a href=\"#创建解析器\" class=\"headerlink\" title=\"创建解析器\"></a>创建解析器</h2><p>argparse的第一步首先是创建一个解析器，即先创建一个<strong>ArgumentParser</strong>对象，这个对象将用于保存把命令行解析成Python的数据类型所需要的所有的信息。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; import argparse</div><div class=\"line\">&gt;&gt;&gt; parser = argparse.ArgumentParser(description=\"Get the baseline data\")</div><div class=\"line\">&gt;&gt;&gt; print parser</div><div class=\"line\">ArgumentParser(prog='', usage=None, description='Get the baseline data', version=None, formatter_class=&lt;class 'argparse.HelpFormatter'&gt;, conflict_handler='error', add_help=True)</div></pre></td></tr></table></figure></p>\n<h2 id=\"给解析器添加参数\"><a href=\"#给解析器添加参数\" class=\"headerlink\" title=\"给解析器添加参数\"></a>给解析器添加参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> argparse</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(description=<span class=\"string\">\"Get the baseline data\"</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--file'</span>, help=<span class=\"string\">'file path'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument(<span class=\"string\">'--sum'</span>, dest=<span class=\"string\">'accumulate'</span>, action=<span class=\"string\">'store_const'</span>,const=sum, default=max,help=<span class=\"string\">'sum the integers (default: find the max)'</span>)</div><div class=\"line\">&gt;&gt;&gt;</div><div class=\"line\"><span class=\"string\">\"\"\"</div><div class=\"line\">输出：</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument('-f', '--file', help='file path')</div><div class=\"line\">_StoreAction(option_strings=['-f', '--file'], dest='file', nargs=None, const=None, default=None, type=None, choices=None, help='file path', metavar=None)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument('--sum', dest='accumulate', action='store_const',const=sum, default=max,help='sum the integers (default: find the max)')</div><div class=\"line\">_StoreConstAction(option_strings=['--sum'], dest='accumulate', nargs=0, const=&lt;built-in function sum&gt;, default=&lt;built-in function max&gt;, type=None, choices=None, help='sum the integers (default: find the max)', metavar=None)</div><div class=\"line\">\"\"\"</span></div></pre></td></tr></table></figure>\n<p>给解析器添加参数后，接下来解析参数的时候，解析参数的函数返回的对象中将带有两个属性。</p>\n<h2 id=\"解析参数\"><a href=\"#解析参数\" class=\"headerlink\" title=\"解析参数\"></a>解析参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.parse_args()</div><div class=\"line\">Namespace(accumulate=&lt;built-<span class=\"keyword\">in</span> function max&gt;, file=<span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>\n<p>ArgumentParser用方法<strong>parse_args()</strong>解析参数，这个函数会检查命令行，把每个参数转换成Python的数据类型，并采取相应的action。绝大部分情况下，解析函数从命令行解析出来的属性建一个简单的<strong>NameSpace</strong>对象。<br>在脚本中，<strong>parse_args()</strong>的调用一般不带参数，<strong>ArgumentParser</strong>将根据<strong>sys.argv</strong>来自动确定命令行参数。</p>\n<h2 id=\"模块的主要对象和主要函数介绍\"><a href=\"#模块的主要对象和主要函数介绍\" class=\"headerlink\" title=\"模块的主要对象和主要函数介绍\"></a>模块的主要对象和主要函数介绍</h2><h3 id=\"ArgumentParser对象的说明\"><a href=\"#ArgumentParser对象的说明\" class=\"headerlink\" title=\"ArgumentParser对象的说明\"></a>ArgumentParser对象的说明</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#类原型</div><div class=\"line\">class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True)</div><div class=\"line\"></div><div class=\"line\">#创建一个新的ArgumentParser对象。所有的参数应该以关键字参数传递。下面对参数做简单的介绍，它们是：</div><div class=\"line\">\"\"\"</div><div class=\"line\">prog - 程序的名字（默认：sys.argv[0]），一般根据sys.argv[0]来决定在帮助信息中如何显示程序的名字.</div><div class=\"line\">usage - 描述程序用法的字符串（默认：从解析器的参数生成）</div><div class=\"line\">description - 参数帮助信息之前的文本（默认：空）</div><div class=\"line\">epilog - 参数帮助信息之后的文本（默认：空）,就是帮助信息完了后输出的字符串</div><div class=\"line\">parents - ArgumentParser 对象的一个列表，这些对象的参数添加到正在构建的ArgumentParser对象</div><div class=\"line\">formatter_class - 定制化帮助信息的类，丰富了帮助信息</div><div class=\"line\">prefix_chars - 可选参数的前缀字符集（默认：'-'），就是\"-f/--foo\"，有些参数可能是'+f'，此时用该参数去指定。</div><div class=\"line\">fromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None）</div><div class=\"line\">argument_default - 参数的全局默认值（默认：None）</div><div class=\"line\">conflict_handler - 解决冲突的可选参数的策略（通常没有必要）</div><div class=\"line\">add_help - 给解析器添加-h/–help 选项（默认：True）</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<h3 id=\"add-argument-方法说明\"><a href=\"#add-argument-方法说明\" class=\"headerlink\" title=\"add_argument()方法说明\"></a>add_argument()方法说明</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#函数原型</span></div><div class=\"line\">ArgumentParser.add_argument(name <span class=\"keyword\">or</span> flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#定义应该如何解析一个命令行参数。下面每个参数的简单介绍：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</div><div class=\"line\">name or flags - 选项字符串的名字或者列表，例如foo 或者-f, --foo。</div><div class=\"line\">action - 在命令行遇到该参数时采取的基本动作类型。默认为'store',即保存参数的值。含有计算参数出现的次数，保存参数列表等</div><div class=\"line\">nargs - 应该读取的命令行参数数目。</div><div class=\"line\">const - 某些action和nargs选项要求的常数值。</div><div class=\"line\">default - 如果命令行中没有出现该参数时的默认值。</div><div class=\"line\">type - 命令行参数应该被转换成的类型。默认是字符串方式读入命令行参数，有时候可能需要解析成整数，浮点数等类型</div><div class=\"line\">choices - 参数可允许的值的一个容器。</div><div class=\"line\">required - 该命令行选项是否可以省略（只针对可选参数）。</div><div class=\"line\">help - 参数的简短描述。</div><div class=\"line\">metavar - 参数在帮助信息中的名字。</div><div class=\"line\">dest - 给parse_args()返回的对象要添加的属性名称。</div><div class=\"line\">\"\"\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"Namespace对象\"><a href=\"#Namespace对象\" class=\"headerlink\" title=\"Namespace对象\"></a>Namespace对象</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">argparse</span>.<span class=\"title\">Namespace</span></span></div></pre></td></tr></table></figure>\n<p><strong>parse_args()方法</strong>使用<strong>Namespace</strong>类，用于创建一个保存属性的对象并返回该对象。<br>这个类设计的很简单，只是<strong>object</strong>这个类的一个可读可打印的字符串的子类。也可以用Python的内建语句<strong>vars()</strong>来以字典的方式查看其属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parser.add_argument(<span class=\"string\">'-foo'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args = parser.parse_args([<span class=\"string\">'-foo'</span>,<span class=\"string\">'BAR'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>vars(args)</div><div class=\"line\">&#123;<span class=\"string\">'foo'</span>: <span class=\"string\">'BAR'</span>&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"getopt模块\"><a href=\"#getopt模块\" class=\"headerlink\" title=\"getopt模块\"></a>getopt模块</h1><p>getopt模块用于抽出命令行参数和选，是一个命令行参数解析器。兼容C语言的getopt函数。</p>\n<h2 id=\"模块的主要对象和主要函数介绍-1\"><a href=\"#模块的主要对象和主要函数介绍-1\" class=\"headerlink\" title=\"模块的主要对象和主要函数介绍\"></a>模块的主要对象和主要函数介绍</h2><h3 id=\"getopt-getopt-函数说明\"><a href=\"#getopt-getopt-函数说明\" class=\"headerlink\" title=\"getopt.getopt()函数说明\"></a>getopt.getopt()函数说明</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#函数原型</span></div><div class=\"line\">getopt.getopt(args, options[, long_options])</div><div class=\"line\"><span class=\"comment\">#参数定义：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</div><div class=\"line\">args：命令行参数列表</div><div class=\"line\">options： 短格式参数（string），如：'abc:o'</div><div class=\"line\">long_options: 长格式参数（list）,如： ['condition=', 'output-file=', 'testing']</div><div class=\"line\">#注解</div><div class=\"line\">当args中出现短格式参数或者长格式参数列表没有的参数的时候；或者当短格式参数和长格式参数中定义了必须有的参数，即含有\":\"或者\"=\"的时候，但是args中没出现该参数的时候，均会报错，异常类为：getopt.GetoptError: option -x not recognized。</div><div class=\"line\">\"\"\"</span></div></pre></td></tr></table></figure>\n<p><strong>getopt.getopt()</strong>函数解析方法：</p>\n<ul>\n<li>短格式参数：当字母后面带有”:”的时候，表示整个参数是需要带参数的，函数在解析的时候，会把这个命令行参数中紧随-o后面的参数解析为-o的参数。字符后面不带”:”的表明该字符是不需要参数的，即不会把紧随这个字符后面的参数解析为该短格式字符的参数。</li>\n<li>长格式参数列表：当列表中某个元素的后面后面有”=”的时候，表明这个字符串必须有参数，不带参数会报错，getopt会把紧随这个字符串后面的参数解析为这个字符串的参数；如果没有不带”=”的参数表明这个字符串是没有参数的，即不会解析紧随这个字符串后面的字符串串为参数。</li>\n</ul>\n<p><strong>getopt.getopt()</strong>函数返回值（返回两个list）：</p>\n<ul>\n<li>第一个参数opts：list的元素是每个参数选项和其value的元组</li>\n<li>第二个参数args：除了有用参数外的其他命令行的输入，也是一个list</li>\n</ul>\n<p><strong>示例</strong><br>短格式参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> getopt</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args = <span class=\"string\">'-a -b -cfoo -d bar a1 a2'</span>.split()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'-a'</span>, <span class=\"string\">'-b'</span>, <span class=\"string\">'-cfoo'</span>, <span class=\"string\">'-d'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>opts, args = getopt.getopt(args,<span class=\"string\">'abc:d:'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>opts</div><div class=\"line\">[(<span class=\"string\">'-a'</span>, <span class=\"string\">''</span>), (<span class=\"string\">'-b'</span>, <span class=\"string\">''</span>), (<span class=\"string\">'-c'</span>, <span class=\"string\">'foo'</span>), (<span class=\"string\">'-d'</span>, <span class=\"string\">'bar'</span>)]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div></pre></td></tr></table></figure></p>\n<p>长格式参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> getopt</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args = <span class=\"string\">'--condition=foo --testing --output-file abc.def -x a1 a2'</span>.split()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'--condition=foo'</span>, <span class=\"string\">'--testing'</span>, <span class=\"string\">'--output-file'</span>, <span class=\"string\">'abc.def'</span>, <span class=\"string\">'-x'</span>, <span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>optlist, args = getopt.getopt(args, <span class=\"string\">'x'</span>, [</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'condition='</span>, <span class=\"string\">'output-file='</span>, <span class=\"string\">'testing'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>optlist</div><div class=\"line\">[(<span class=\"string\">'--condition'</span>, <span class=\"string\">'foo'</span>), (<span class=\"string\">'--testing'</span>, <span class=\"string\">''</span>), (<span class=\"string\">'--output-file'</span>, <span class=\"string\">'abc.def'</span>), (<span class=\"string\">'-x'</span>, <span class=\"string\">''</span>)]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args</div><div class=\"line\">[<span class=\"string\">'a1'</span>, <span class=\"string\">'a2'</span>]</div></pre></td></tr></table></figure></p>\n<p>程序中使用该模块举例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> getopt</div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">usage</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"Usage:%s [-h|-o|-v] [--help|--output] args....\"</span> %sys.argv[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        opts, args = getopt.getopt(sys.argv[<span class=\"number\">1</span>:], <span class=\"string\">\"ho:v\"</span>, [<span class=\"string\">\"help\"</span>, <span class=\"string\">\"output=\"</span>])</div><div class=\"line\">    <span class=\"keyword\">except</span> getopt.GetoptError <span class=\"keyword\">as</span> err:</div><div class=\"line\">        <span class=\"keyword\">print</span> str(err)</div><div class=\"line\">        usage()</div><div class=\"line\">        sys.exit(<span class=\"number\">2</span>)</div><div class=\"line\">    output = <span class=\"keyword\">None</span></div><div class=\"line\">    verbose = <span class=\"keyword\">False</span></div><div class=\"line\">    <span class=\"keyword\">for</span> o , a <span class=\"keyword\">in</span> opts:</div><div class=\"line\">        <span class=\"keyword\">if</span> o == <span class=\"string\">'-v'</span>:</div><div class=\"line\">            verbose = <span class=\"keyword\">True</span></div><div class=\"line\">        <span class=\"keyword\">elif</span> o <span class=\"keyword\">in</span> (<span class=\"string\">\"-h\"</span>, <span class=\"string\">\"--help\"</span>):</div><div class=\"line\">            usage()</div><div class=\"line\">            sys.exit()</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            <span class=\"keyword\">assert</span> <span class=\"keyword\">False</span>, <span class=\"string\">'unhandled option'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure></p>\n<p><a href=\"http://python.usyiyi.cn/python_278/library/argparse.html\">argparse模块</a></p>"},{"title":"Tornado之web服务器的网络知识了解","date":"2016-05-11T04:17:58.000Z","toc":true,"comments":1,"_content":"\n\n在详解Tornado的HTTP Server架构模型之前，先简单的聊聊web服务器的网络知识。首先了解一下，网络中的数据是怎么流动的。\n<!-- more -->\n\n\n![](Tornado之web服务器的网络知识了解/tornado_000.png)\n\n用户请求数据给服务器的时候，与上图类似。其实网络数据和自来水管的水是一样的，哪里有道就朝哪里流。所以要让数据流动起来，当然是搭桥修路了。科技如此发达，搭桥修路的方法当然会各种各样。但是不管怎么样变，他们的目标就是搭桥修路，那么就有一些共同的特点。www上所谓的搭桥修路就是web server是比较重要的一种方式，下面看看web server。\n\ntornado也是一个web server，那么必然要遵循web server的三部曲。\n\n# web server的三部曲\n\n 1. 服务器bind到一个端口，然后开始在该端口listen。\n 2. 客户端connect到该端口，将请求发送给服务端。\n 3. 服务端处理完响应的逻辑，数据write给client。\n \n![](Tornado之web服务器的网络知识了解/2013_10_14_03.gif)\n\n由上面的图就可以清楚地看到，**web服务器的三部曲，serverbind后就开始listen，接受client连接，client在发起连接后，server在接受到这个connect后，accept后建立与client一个socket连接，这样server端的client soceket就可以和client端的socketin进行通信了，包括接受数据，回写数据等。client发给server的request请求后，server接受到这个请求后把请求的内容转给处理这个请求的handler，handler按照相应逻辑处理后，把处理的数据通过socket连接回写给client，作为reponse，这样一个请求（client与server的交互）就完成了。若是短连接，则需要关闭连接；若是长连接，需要维护这个长连接，保持socket，使client与server的通道畅通无阻。**\n\n上面是一个简单的处理一个请求的，那如果client有上千呢，上万呢，即连接有成千上万的时候，那问题就复杂多了，这样就会出现所谓的C10K问题。\n## C10K问题\n### C10K定义：\nC10K问题是指当网络服务在处理成千上万的客户端连接的时候，往往出现效率底下甚至完全瘫痪。当然这是在互联网还没有普及的情况下是C10K，在web2.0时代，可能是C100K，C5000K等，但是意思和C10K是一样的。\n### C10K的本质：\n最早的时候服务器都是基于进程/线程模型来实现的，新来一个TCP链接，就需要分配一个进程/线程，但是进程/线程是操作系统最昂贵的，一台机器允许创建的进程数量有限的，况且进程在创建的比较多的时候，OS在调度、切换进程就需要耗费很多资源，效率低下。这种情况下，如果是C10K链接，那么就要创建1w的进程，那么OS根本是无法承受的，要继续服务，只能采用分布式，不断的加机器，但是加机器成本太大，一般公司的财力根本无法承受。这就是C10K问题出现的本质。\n\n*实际上web1.0时代，也有异步模式，如select/poll等，但是这些技术都有一定的缺点，比如select最大不能超过1024，这是每个进程限制监听的最大打开的文件描述符数量；poll虽然没这个限制，可是每次接受到读写事件都需要遍历一次每个连接查看那个连接有数据请求，消耗较大。*\n\n## C10K问题的一般选择的解决办法\n**C10K问题解决一般使用Linux支持的epoll模型，epoll是异步非阻塞的，Nginx等都是epoll的产物.**\n\n既然要聊C10K这类网络问题，那么肯定要了解一下基础的网络模型和一些基础概念，比如select/poll/epoll，异步、同步I/O、阻塞、非阻塞等，下面就来讨论上述概念。\n\n# 异步、同步、阻塞、非阻塞\n## 同步、异步\n所谓的**同步、异步是基于消息通知机制角度，是针对应用程序与内核的交互**来说的。\n\n - **同步I/O**是应用程序发出一个功能调用后，死等结果，没有结果，该调用不会返回的；\n - **异步IO**是应用程序发出一个功能调用后，应用程序不会等待调用执行结果的，该调用该功能完成后，自己给应用程序通知去。\n下面用一张图来说明：\n![](Tornado之web服务器的网络知识了解/tornado_002.png)\n\n举一个现实场景来说明上述图，比如我去银行去办理存钱业务，有两种方式去等待：\n\n - 排队等待\n - 选择抽取一个号码，等到开始办理这个号码的时候，工作人员会在喇叭喊我或者打电话给我，通知我轮到我办理业务。\n\n其中前者就是同步等待消息通知，就是说一直在等待银行办理业务；后者就是等到银行通知，就是说异步等待消息通知，当事件发生后就触发回调机制去通知我。\n**同步IO与异步IO的区别在于：应用程序调用是否会立即返回。**\n\n## 阻塞、非阻塞\n所谓**阻塞与非阻塞是从程序在等待消息通知（无所谓同步异步）时的状态**而言的，就是消息通知到的时候，如果调用的程序的数据还未准备好，此时时立即返回还是等待数据准备完成再返回。\n\n - **阻塞IO**是指执行这个函数的线程会在程序调用返回之前，一直挂起当前线程，该线程一直处于等待消息通知，不能够执行其他业务，直到函数在拿到调用结果后才返回，线程恢复执行。\n - **非阻塞IO**是指程序调用中函数不等结果，立即返回，该函数不会阻塞线程，线程不会挂起，线程继续执行其他的任务。\n\n简单理解阻塞和非阻塞就是函数能不能立即返回，如果不能立即返回，需要等待，那么就是阻塞了；否则就是非阻塞了。\n![](Tornado之web服务器的网络知识了解/tornado_003.png)\n\n继续举例银行这个场景来说明上述问题，当你无论是排队等待办理业务，还是等待通知再去办理业务，等待期间，你有两种方式去消耗等待时间：\n\n - 一心一意等待，即一心一意的去排队，或者一心一意的等待叫你的号码，这期间除了等待消息之外，你什么都不能做，只是傻等。表现在程序中就是该函数调用之处不能继续朝下执行，阻塞了。\n - 等待的时候和老婆发微信聊天，刷朋友圈，直到排队到你办理业务，或者银行工作人员叫你号去办理业务。这就是说你没阻塞在等待排队到你或者等待叫你号这个消息通知上，你是在做自己的事，自己边玩边等。\n \n上述两种方式其实就是阻塞与非阻塞的区别。前者显然是阻塞，除了等待，你什么都不能做，无论什么方式的等待都阻塞了；后者当然就是非阻塞了，你可以在等待期间，做自己的事情。看起来后者的效率高，你即完成了老婆交代办理银行业务的事情，又陪老婆聊天了，但是等待办理业务的是你，和老婆聊天的是你，你需要看看到你没，不断在低头和老婆聊天。在两种方式之间不断切换，一心不可二用，在切换频率过高，或者切换干的事情过多的时候，这个切换的消耗非常大，这个平衡点需要把握。\n\n**阻塞和非阻塞的区别在于：数据拷贝的时候，进程是否阻塞！**\n\n## 同步/异步-阻塞/非阻塞的组合解释\n**阻塞调用和同步调用不是一回事，**不要混淆，对于同步调用来说，很多时候线程可能还是激活状态，并没有挂起，只是从逻辑上来说当时的函数还没有返回，但是此时线程可能也会处理别的事情。比如上述银行例子，同步调用只是在等待，但是这个等待调用可以是阻塞，也可以是非阻塞，也就是你可以一边等待一边刷微信和老婆聊天，也可以什么都不干一心一意的等到到你办理业务。\n\n通过上面的同步/异步和阻塞/非阻塞的介绍，既然这四种形式是从不同的角度划分的，那么就可以分为**同步阻塞**，**同步非阻塞**，**异步阻塞**，**异步非阻塞**四种了。\n\n - **同步阻塞：**即消息通知是同步的，而且会等待数据返回，不仅通知到还要拿到数据结果再返回来。比如上面银行的例子，同步阻塞的意思就是你只能专心排队等待，什么事情都不能做的。\n - **异步阻塞：**采用异步的方式等待消息被触发，也就是说你在银行办业务的时候，拿到纸条后，只能呆呆的坐在大厅等候叫你，不能离开银行，或者不能刷朋友圈，你就被阻塞在这个事情上了，哪里也去不了了。**异步操作是可以被阻塞住的，只不过它不是在消息通知时阻塞，而是在等待消息通知这个事情上阻塞了。**\n - **同步非阻塞：**即消息通知是同步的，但是你可以不等待调用程序的数据准备好就返回。比如你一边在排队，一边在和老婆刷微信，只是你需要不断的在刷微信和抬头看你快排到了没这两种方式之间不停的来回切换。\n - **异步非阻塞：**消息通知到，而且不等待数据就直接返回了。比如你拿到号后，在大厅座位上等待的时候可以刷微信，或者你突然口渴想去超市买水，此时你告诉大堂经理，到你号的时候，打电话叫你一下（注册回调函数）。此时你并没有阻塞在银行办理业务这个事情上，这就是异步+非阻塞的方式，显然这种方式要高一些。程序也没有在两个不同的操作之间来回切换，因为给打电话是大堂经理的事情（消息触发机制），你只需要等待就好，触发了则通知你。\n\n综上所述，同步/异步关注的是消息的通知机制，阻塞/非阻塞所关注的时候是程序（线程）等待消息通知期间的状态。\n\n## 再次举例说明同步、异步、阻塞、非阻塞\n上面已经明确说明，**同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态。**，下面在举例一个场景，以小明下载文件为例，从这两个关注点来再次说明这两组概念。\n\n - 同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。\n\n> 同步体现在：等待下载完成通知；\n> 阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；\n\n - 同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到100% 就完成。 \n\n> 同步体现在：等待下载完成通知；\n> 非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】\n\n - 异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音。\n\n> 异步体现在：下载完成“叮”一声通知； \n> 阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；\n\n - 异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。\n\n> 异步体现在：下载完成“叮”一声通知；\n> 非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】\n\n**也就是说，同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）。**\n\n# Linux下五种IO模型\n网络IO的本质其实就是socket的读取，因为在Linux中socket被抽象成**流**，所以网络IO可以理解为对流的操作。\n对于一次IO访问，数据先会被copy到os内核缓冲区，然后再从操作系统内核缓冲区copy到进程缓冲区。同理，对于sockt的IO而言，也要经历两步：\n\n - 等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。\n - 把数据从内核缓冲区，复制到进程的缓冲区中。\n \n**下面着重介绍Linux的五种常用的IO模型**：\n\n - 同步阻塞IO\n - 同步非阻塞IO\n - IO复用(select和poll、epoll)---其实也是同步的\n - 异步非阻塞IO\n - 信号驱动IO\n\n其中前四种比较常用，尤其是IO复用，是现在网络编程的重点。下面重点介绍前四种。讲使用上面的银行柜台办理业务举例说明这几种模型。\n\n## 同步阻塞IO\n\n> 我在银行办理业务，人爆满，所以我不知道什么时候能轮到我办理业务，但是我又不能离开，我只能等待，等待轮到我办理，这等待期间我不能出去抽烟，更不能先回家女朋友，所有的事情都被办理业务这个事情阻塞着。这就是一个典型的同步阻塞IO。\n\n同步阻塞IO是最常见的一种IO模型，也是最简单的一种模型，默认情况下都是同步阻塞IO模型。\n**在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费CPU而只是简单等待响应的状态。**\n下图是在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_004.png)\n\n同步阻塞IO的特点就是在数据准备和数据拷贝的两个阶段都被block了。\n\n## 同步非阻塞IO\n\n> 我一直在银行傻等着办理业务，又不是阿甘能等到苹果公司的股票，况且旁边就是优衣库，我肯定不甘心这么浪费我的青春年华，所以我决定出去转转，看看能不能给老婆淘点宝回去。可是我的第一要务是办理银行业务，所以我不得不一会跑回来看看快到我没，一会又去优衣库，来回的切换，这就是典型的同步非阻塞IO，但是来来回回折腾，太累人了。\n> 所以同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。\n\n由以上例子我们就可以看出：\n**非阻塞IO也会进行recvform系统调用，检查数据是否准备好。只是非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。**\n\n下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_005.png)\n\n同步非阻塞IO的特点是用户进程需要不断的主动询问数据好了没有，需要轮询\n\n## IO复用(select和poll、epoll)\n\n> 此类型和同步阻塞差不多，银行在大堂装有大屏幕，这样我就不用每次回去问那个一脸我欠她几百万的样子的阿姨了，我直接看大屏幕就好了，但是还是要轮询去看。\n\nIO复用就是同步非阻塞的2.0版，比如我不仅仅是办理银行业务，可能我还办理电话卡业务等，也就是说后台有多个任务在等待，我需要不断的在这好多个等待的进程中去切换，太累了，此时我老婆嫌我太累，来帮我看一半的业务，我来看一半，好了就通知我去办理，那么此时我老婆和我合起来就是所谓的**IO复用**，那么在Linux界，我老婆就相等于select、poll、epoll。\n\n可以看出IO复用其实也是要轮询多个socket的，只不过使用select\\poll\\epoll来轮询的，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。\n\n下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_006.png)\n\n多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。\n\n*IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。*\n\n## 异步非阻塞IO\n\n> 我在银行办理业务的时候，恰好碰见我一朋友，我朋友见我心不在焉，就说让我可以先回家，等到到我的时候，他给我打电话。于是我就吃着火锅唱着歌回家等待我朋友电话通知了。这就是异步非阻塞。\n\n异步非阻塞IO中，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。\n\n下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_007.png)\n\n上面这个看起来是很理想的情况，可是越理想，实现起来越麻烦，主要是操作系统实现API比较困难，有些os根本就不支持异步IO，而且异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。\n\n\n## 五种IO类型的对比图\n\n![](Tornado之web服务器的网络知识了解/tornado_008.png)\n\n\n# select、poll、epoll\n\n## epoll\n\n### 流\n要了解epoll等时间必须先了解流的概念。流在上面我们已经介绍过了，在Linux中，文件、socket、pipe等等可以进行IO操作的内核对象，都可以看做一个流。\n\n### 缓冲区\n再来了解一个概念，缓冲区：缓冲区的引入是为了减少频繁IO操作而引起的频繁的系统调用（很慢，很重），当你操作一个流的时候，更多的是以缓冲区为单位进行操作的，当然这是相对于用户而言的。对于内核而言，也有自己的缓冲区。所以缓冲区又分为用户缓冲区和内核缓冲区。\n### 阻塞IO缺点\n上面我们详细的介绍了阻塞与非阻塞，我们知道阻塞IO的典型缺点是，在此模式下，一个线程/进程只能处理一个流的IO事件，所以要处理很多的流的IO事件，唯有开多个线程或者进程，很显然这种办法很笨，而且效率不高，处理的流有限。\n### 非阻塞IO\n那么要处理高并发，就只剩下非阻塞IO了，既然是非阻塞的IO，那么就不是实时的，肯定就需要忙轮询，不断的去检查那个流可以进行读写了，一遍遍检查。\n```python\nwhile True {\n    for i in starteam[];{\n        if i has data:\n            read until unavailable\n    }\n}\n```\n上述代码，我们看到我们需要不断的去轮询整个流，从而处理多流的情况。但是这样明显若是没有事件发生，就会白白浪费宝贵的CPU资源。为了避免无效的CPU轮询，就引入了一个代理，select代理，poll代理。\n### select 、poll\n select、poll可以同时观察多个流的IO事件，他们本质上是一致的。在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）\n```python\nwhile True {\n    select/poll(streams[])\n    for i in starteam[];{\n        if i has data:\n            read until unavailable\n    }\n}\n```\n此时没有IO事件发生的时候，程序就阻塞在select以外，但是这时候他的缺点也暴露出来了。当流发生IO事件后，却不知道是那个流可以读数据或者写数据了，我们只能**无差别的轮询**一遍所有的流，找出能读数据或者写数据的流，对他们进行操作。\n**因此使用select的时候，我们又O(n)的无差别的轮询复杂度，显然同时处理的流越多，每一次轮询所花费的轮询时间越长。**\n终于epoll大牛出现了。\n\n### epoll介绍\n\n**epoll可以理解为event poll，它不同于忙轮询和无差别的轮询，epoll会把那个流发生了什么样的IO事件通知我们，因此我们每次的对这些流的操作都是有意义的。复杂度瞬间降低到了O(k),K是发生的IO事件的流的个数，也有人认为是O(1)，显然效率和上述各种模型不在一个档次了，**男神啊简直是。\n```python\nwhile true {\n    active_stream[] = epoll_wait(epollfd)\n    for i in active_stream[] {\n        read or write till unavailable\n    }\n}\n```\n即工作情形大致是：\n\n - epoll_create 创建一个epoll对象，一般epollfd = epoll_create() \n - epoll_ctl（epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件。比如epoll_ctl(epollfd, EPOLL_CTL_ADD,socket,EPOLLIN);//有缓冲区内有数据时epoll_wait返回，epoll_ctl(epollfd, EPOLL_CTL_DEL,socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回\n - epoll_wait(epollfd,...)等待直到注册的事件发生。\n\n\n\n到此为止，本文就详细的聊了网络编程中一些基础概念，了解这些概念后，我们下一步就详细的剖析Tornado的源码，和高手过招，一定很刺激。\n\n学Python，我们是认真的。\n \n[比较好的讲解的博客推荐](http://blog.jobbole.com/99905/)\n","source":"_posts/Tornado之web服务器的网络知识了解.md","raw":"---\ntitle: Tornado之web服务器的网络知识了解\ndate: 2016-05-11 12:17:58\ntags: Tornado源码分析\ncategories: Tornado系列\ntoc: true\ncomments: true\n---\n\n\n在详解Tornado的HTTP Server架构模型之前，先简单的聊聊web服务器的网络知识。首先了解一下，网络中的数据是怎么流动的。\n<!-- more -->\n\n\n![](Tornado之web服务器的网络知识了解/tornado_000.png)\n\n用户请求数据给服务器的时候，与上图类似。其实网络数据和自来水管的水是一样的，哪里有道就朝哪里流。所以要让数据流动起来，当然是搭桥修路了。科技如此发达，搭桥修路的方法当然会各种各样。但是不管怎么样变，他们的目标就是搭桥修路，那么就有一些共同的特点。www上所谓的搭桥修路就是web server是比较重要的一种方式，下面看看web server。\n\ntornado也是一个web server，那么必然要遵循web server的三部曲。\n\n# web server的三部曲\n\n 1. 服务器bind到一个端口，然后开始在该端口listen。\n 2. 客户端connect到该端口，将请求发送给服务端。\n 3. 服务端处理完响应的逻辑，数据write给client。\n \n![](Tornado之web服务器的网络知识了解/2013_10_14_03.gif)\n\n由上面的图就可以清楚地看到，**web服务器的三部曲，serverbind后就开始listen，接受client连接，client在发起连接后，server在接受到这个connect后，accept后建立与client一个socket连接，这样server端的client soceket就可以和client端的socketin进行通信了，包括接受数据，回写数据等。client发给server的request请求后，server接受到这个请求后把请求的内容转给处理这个请求的handler，handler按照相应逻辑处理后，把处理的数据通过socket连接回写给client，作为reponse，这样一个请求（client与server的交互）就完成了。若是短连接，则需要关闭连接；若是长连接，需要维护这个长连接，保持socket，使client与server的通道畅通无阻。**\n\n上面是一个简单的处理一个请求的，那如果client有上千呢，上万呢，即连接有成千上万的时候，那问题就复杂多了，这样就会出现所谓的C10K问题。\n## C10K问题\n### C10K定义：\nC10K问题是指当网络服务在处理成千上万的客户端连接的时候，往往出现效率底下甚至完全瘫痪。当然这是在互联网还没有普及的情况下是C10K，在web2.0时代，可能是C100K，C5000K等，但是意思和C10K是一样的。\n### C10K的本质：\n最早的时候服务器都是基于进程/线程模型来实现的，新来一个TCP链接，就需要分配一个进程/线程，但是进程/线程是操作系统最昂贵的，一台机器允许创建的进程数量有限的，况且进程在创建的比较多的时候，OS在调度、切换进程就需要耗费很多资源，效率低下。这种情况下，如果是C10K链接，那么就要创建1w的进程，那么OS根本是无法承受的，要继续服务，只能采用分布式，不断的加机器，但是加机器成本太大，一般公司的财力根本无法承受。这就是C10K问题出现的本质。\n\n*实际上web1.0时代，也有异步模式，如select/poll等，但是这些技术都有一定的缺点，比如select最大不能超过1024，这是每个进程限制监听的最大打开的文件描述符数量；poll虽然没这个限制，可是每次接受到读写事件都需要遍历一次每个连接查看那个连接有数据请求，消耗较大。*\n\n## C10K问题的一般选择的解决办法\n**C10K问题解决一般使用Linux支持的epoll模型，epoll是异步非阻塞的，Nginx等都是epoll的产物.**\n\n既然要聊C10K这类网络问题，那么肯定要了解一下基础的网络模型和一些基础概念，比如select/poll/epoll，异步、同步I/O、阻塞、非阻塞等，下面就来讨论上述概念。\n\n# 异步、同步、阻塞、非阻塞\n## 同步、异步\n所谓的**同步、异步是基于消息通知机制角度，是针对应用程序与内核的交互**来说的。\n\n - **同步I/O**是应用程序发出一个功能调用后，死等结果，没有结果，该调用不会返回的；\n - **异步IO**是应用程序发出一个功能调用后，应用程序不会等待调用执行结果的，该调用该功能完成后，自己给应用程序通知去。\n下面用一张图来说明：\n![](Tornado之web服务器的网络知识了解/tornado_002.png)\n\n举一个现实场景来说明上述图，比如我去银行去办理存钱业务，有两种方式去等待：\n\n - 排队等待\n - 选择抽取一个号码，等到开始办理这个号码的时候，工作人员会在喇叭喊我或者打电话给我，通知我轮到我办理业务。\n\n其中前者就是同步等待消息通知，就是说一直在等待银行办理业务；后者就是等到银行通知，就是说异步等待消息通知，当事件发生后就触发回调机制去通知我。\n**同步IO与异步IO的区别在于：应用程序调用是否会立即返回。**\n\n## 阻塞、非阻塞\n所谓**阻塞与非阻塞是从程序在等待消息通知（无所谓同步异步）时的状态**而言的，就是消息通知到的时候，如果调用的程序的数据还未准备好，此时时立即返回还是等待数据准备完成再返回。\n\n - **阻塞IO**是指执行这个函数的线程会在程序调用返回之前，一直挂起当前线程，该线程一直处于等待消息通知，不能够执行其他业务，直到函数在拿到调用结果后才返回，线程恢复执行。\n - **非阻塞IO**是指程序调用中函数不等结果，立即返回，该函数不会阻塞线程，线程不会挂起，线程继续执行其他的任务。\n\n简单理解阻塞和非阻塞就是函数能不能立即返回，如果不能立即返回，需要等待，那么就是阻塞了；否则就是非阻塞了。\n![](Tornado之web服务器的网络知识了解/tornado_003.png)\n\n继续举例银行这个场景来说明上述问题，当你无论是排队等待办理业务，还是等待通知再去办理业务，等待期间，你有两种方式去消耗等待时间：\n\n - 一心一意等待，即一心一意的去排队，或者一心一意的等待叫你的号码，这期间除了等待消息之外，你什么都不能做，只是傻等。表现在程序中就是该函数调用之处不能继续朝下执行，阻塞了。\n - 等待的时候和老婆发微信聊天，刷朋友圈，直到排队到你办理业务，或者银行工作人员叫你号去办理业务。这就是说你没阻塞在等待排队到你或者等待叫你号这个消息通知上，你是在做自己的事，自己边玩边等。\n \n上述两种方式其实就是阻塞与非阻塞的区别。前者显然是阻塞，除了等待，你什么都不能做，无论什么方式的等待都阻塞了；后者当然就是非阻塞了，你可以在等待期间，做自己的事情。看起来后者的效率高，你即完成了老婆交代办理银行业务的事情，又陪老婆聊天了，但是等待办理业务的是你，和老婆聊天的是你，你需要看看到你没，不断在低头和老婆聊天。在两种方式之间不断切换，一心不可二用，在切换频率过高，或者切换干的事情过多的时候，这个切换的消耗非常大，这个平衡点需要把握。\n\n**阻塞和非阻塞的区别在于：数据拷贝的时候，进程是否阻塞！**\n\n## 同步/异步-阻塞/非阻塞的组合解释\n**阻塞调用和同步调用不是一回事，**不要混淆，对于同步调用来说，很多时候线程可能还是激活状态，并没有挂起，只是从逻辑上来说当时的函数还没有返回，但是此时线程可能也会处理别的事情。比如上述银行例子，同步调用只是在等待，但是这个等待调用可以是阻塞，也可以是非阻塞，也就是你可以一边等待一边刷微信和老婆聊天，也可以什么都不干一心一意的等到到你办理业务。\n\n通过上面的同步/异步和阻塞/非阻塞的介绍，既然这四种形式是从不同的角度划分的，那么就可以分为**同步阻塞**，**同步非阻塞**，**异步阻塞**，**异步非阻塞**四种了。\n\n - **同步阻塞：**即消息通知是同步的，而且会等待数据返回，不仅通知到还要拿到数据结果再返回来。比如上面银行的例子，同步阻塞的意思就是你只能专心排队等待，什么事情都不能做的。\n - **异步阻塞：**采用异步的方式等待消息被触发，也就是说你在银行办业务的时候，拿到纸条后，只能呆呆的坐在大厅等候叫你，不能离开银行，或者不能刷朋友圈，你就被阻塞在这个事情上了，哪里也去不了了。**异步操作是可以被阻塞住的，只不过它不是在消息通知时阻塞，而是在等待消息通知这个事情上阻塞了。**\n - **同步非阻塞：**即消息通知是同步的，但是你可以不等待调用程序的数据准备好就返回。比如你一边在排队，一边在和老婆刷微信，只是你需要不断的在刷微信和抬头看你快排到了没这两种方式之间不停的来回切换。\n - **异步非阻塞：**消息通知到，而且不等待数据就直接返回了。比如你拿到号后，在大厅座位上等待的时候可以刷微信，或者你突然口渴想去超市买水，此时你告诉大堂经理，到你号的时候，打电话叫你一下（注册回调函数）。此时你并没有阻塞在银行办理业务这个事情上，这就是异步+非阻塞的方式，显然这种方式要高一些。程序也没有在两个不同的操作之间来回切换，因为给打电话是大堂经理的事情（消息触发机制），你只需要等待就好，触发了则通知你。\n\n综上所述，同步/异步关注的是消息的通知机制，阻塞/非阻塞所关注的时候是程序（线程）等待消息通知期间的状态。\n\n## 再次举例说明同步、异步、阻塞、非阻塞\n上面已经明确说明，**同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态。**，下面在举例一个场景，以小明下载文件为例，从这两个关注点来再次说明这两组概念。\n\n - 同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。\n\n> 同步体现在：等待下载完成通知；\n> 阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；\n\n - 同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到100% 就完成。 \n\n> 同步体现在：等待下载完成通知；\n> 非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】\n\n - 异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音。\n\n> 异步体现在：下载完成“叮”一声通知； \n> 阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；\n\n - 异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。\n\n> 异步体现在：下载完成“叮”一声通知；\n> 非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】\n\n**也就是说，同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）。**\n\n# Linux下五种IO模型\n网络IO的本质其实就是socket的读取，因为在Linux中socket被抽象成**流**，所以网络IO可以理解为对流的操作。\n对于一次IO访问，数据先会被copy到os内核缓冲区，然后再从操作系统内核缓冲区copy到进程缓冲区。同理，对于sockt的IO而言，也要经历两步：\n\n - 等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。\n - 把数据从内核缓冲区，复制到进程的缓冲区中。\n \n**下面着重介绍Linux的五种常用的IO模型**：\n\n - 同步阻塞IO\n - 同步非阻塞IO\n - IO复用(select和poll、epoll)---其实也是同步的\n - 异步非阻塞IO\n - 信号驱动IO\n\n其中前四种比较常用，尤其是IO复用，是现在网络编程的重点。下面重点介绍前四种。讲使用上面的银行柜台办理业务举例说明这几种模型。\n\n## 同步阻塞IO\n\n> 我在银行办理业务，人爆满，所以我不知道什么时候能轮到我办理业务，但是我又不能离开，我只能等待，等待轮到我办理，这等待期间我不能出去抽烟，更不能先回家女朋友，所有的事情都被办理业务这个事情阻塞着。这就是一个典型的同步阻塞IO。\n\n同步阻塞IO是最常见的一种IO模型，也是最简单的一种模型，默认情况下都是同步阻塞IO模型。\n**在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费CPU而只是简单等待响应的状态。**\n下图是在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_004.png)\n\n同步阻塞IO的特点就是在数据准备和数据拷贝的两个阶段都被block了。\n\n## 同步非阻塞IO\n\n> 我一直在银行傻等着办理业务，又不是阿甘能等到苹果公司的股票，况且旁边就是优衣库，我肯定不甘心这么浪费我的青春年华，所以我决定出去转转，看看能不能给老婆淘点宝回去。可是我的第一要务是办理银行业务，所以我不得不一会跑回来看看快到我没，一会又去优衣库，来回的切换，这就是典型的同步非阻塞IO，但是来来回回折腾，太累人了。\n> 所以同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。\n\n由以上例子我们就可以看出：\n**非阻塞IO也会进行recvform系统调用，检查数据是否准备好。只是非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。**\n\n下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_005.png)\n\n同步非阻塞IO的特点是用户进程需要不断的主动询问数据好了没有，需要轮询\n\n## IO复用(select和poll、epoll)\n\n> 此类型和同步阻塞差不多，银行在大堂装有大屏幕，这样我就不用每次回去问那个一脸我欠她几百万的样子的阿姨了，我直接看大屏幕就好了，但是还是要轮询去看。\n\nIO复用就是同步非阻塞的2.0版，比如我不仅仅是办理银行业务，可能我还办理电话卡业务等，也就是说后台有多个任务在等待，我需要不断的在这好多个等待的进程中去切换，太累了，此时我老婆嫌我太累，来帮我看一半的业务，我来看一半，好了就通知我去办理，那么此时我老婆和我合起来就是所谓的**IO复用**，那么在Linux界，我老婆就相等于select、poll、epoll。\n\n可以看出IO复用其实也是要轮询多个socket的，只不过使用select\\poll\\epoll来轮询的，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。\n\n下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_006.png)\n\n多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。\n\n*IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。*\n\n## 异步非阻塞IO\n\n> 我在银行办理业务的时候，恰好碰见我一朋友，我朋友见我心不在焉，就说让我可以先回家，等到到我的时候，他给我打电话。于是我就吃着火锅唱着歌回家等待我朋友电话通知了。这就是异步非阻塞。\n\n异步非阻塞IO中，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。\n\n下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：\n\n![](Tornado之web服务器的网络知识了解/tornado_007.png)\n\n上面这个看起来是很理想的情况，可是越理想，实现起来越麻烦，主要是操作系统实现API比较困难，有些os根本就不支持异步IO，而且异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。\n\n\n## 五种IO类型的对比图\n\n![](Tornado之web服务器的网络知识了解/tornado_008.png)\n\n\n# select、poll、epoll\n\n## epoll\n\n### 流\n要了解epoll等时间必须先了解流的概念。流在上面我们已经介绍过了，在Linux中，文件、socket、pipe等等可以进行IO操作的内核对象，都可以看做一个流。\n\n### 缓冲区\n再来了解一个概念，缓冲区：缓冲区的引入是为了减少频繁IO操作而引起的频繁的系统调用（很慢，很重），当你操作一个流的时候，更多的是以缓冲区为单位进行操作的，当然这是相对于用户而言的。对于内核而言，也有自己的缓冲区。所以缓冲区又分为用户缓冲区和内核缓冲区。\n### 阻塞IO缺点\n上面我们详细的介绍了阻塞与非阻塞，我们知道阻塞IO的典型缺点是，在此模式下，一个线程/进程只能处理一个流的IO事件，所以要处理很多的流的IO事件，唯有开多个线程或者进程，很显然这种办法很笨，而且效率不高，处理的流有限。\n### 非阻塞IO\n那么要处理高并发，就只剩下非阻塞IO了，既然是非阻塞的IO，那么就不是实时的，肯定就需要忙轮询，不断的去检查那个流可以进行读写了，一遍遍检查。\n```python\nwhile True {\n    for i in starteam[];{\n        if i has data:\n            read until unavailable\n    }\n}\n```\n上述代码，我们看到我们需要不断的去轮询整个流，从而处理多流的情况。但是这样明显若是没有事件发生，就会白白浪费宝贵的CPU资源。为了避免无效的CPU轮询，就引入了一个代理，select代理，poll代理。\n### select 、poll\n select、poll可以同时观察多个流的IO事件，他们本质上是一致的。在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）\n```python\nwhile True {\n    select/poll(streams[])\n    for i in starteam[];{\n        if i has data:\n            read until unavailable\n    }\n}\n```\n此时没有IO事件发生的时候，程序就阻塞在select以外，但是这时候他的缺点也暴露出来了。当流发生IO事件后，却不知道是那个流可以读数据或者写数据了，我们只能**无差别的轮询**一遍所有的流，找出能读数据或者写数据的流，对他们进行操作。\n**因此使用select的时候，我们又O(n)的无差别的轮询复杂度，显然同时处理的流越多，每一次轮询所花费的轮询时间越长。**\n终于epoll大牛出现了。\n\n### epoll介绍\n\n**epoll可以理解为event poll，它不同于忙轮询和无差别的轮询，epoll会把那个流发生了什么样的IO事件通知我们，因此我们每次的对这些流的操作都是有意义的。复杂度瞬间降低到了O(k),K是发生的IO事件的流的个数，也有人认为是O(1)，显然效率和上述各种模型不在一个档次了，**男神啊简直是。\n```python\nwhile true {\n    active_stream[] = epoll_wait(epollfd)\n    for i in active_stream[] {\n        read or write till unavailable\n    }\n}\n```\n即工作情形大致是：\n\n - epoll_create 创建一个epoll对象，一般epollfd = epoll_create() \n - epoll_ctl（epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件。比如epoll_ctl(epollfd, EPOLL_CTL_ADD,socket,EPOLLIN);//有缓冲区内有数据时epoll_wait返回，epoll_ctl(epollfd, EPOLL_CTL_DEL,socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回\n - epoll_wait(epollfd,...)等待直到注册的事件发生。\n\n\n\n到此为止，本文就详细的聊了网络编程中一些基础概念，了解这些概念后，我们下一步就详细的剖析Tornado的源码，和高手过招，一定很刺激。\n\n学Python，我们是认真的。\n \n[比较好的讲解的博客推荐](http://blog.jobbole.com/99905/)\n","slug":"Tornado之web服务器的网络知识了解","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoirono0006ta02io7de0xx","content":"<p>在详解Tornado的HTTP Server架构模型之前，先简单的聊聊web服务器的网络知识。首先了解一下，网络中的数据是怎么流动的。<br><a id=\"more\"></a></p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_000.png\" alt=\"\"></p>\n<p>用户请求数据给服务器的时候，与上图类似。其实网络数据和自来水管的水是一样的，哪里有道就朝哪里流。所以要让数据流动起来，当然是搭桥修路了。科技如此发达，搭桥修路的方法当然会各种各样。但是不管怎么样变，他们的目标就是搭桥修路，那么就有一些共同的特点。www上所谓的搭桥修路就是web server是比较重要的一种方式，下面看看web server。</p>\n<p>tornado也是一个web server，那么必然要遵循web server的三部曲。</p>\n<h1 id=\"web-server的三部曲\"><a href=\"#web-server的三部曲\" class=\"headerlink\" title=\"web server的三部曲\"></a>web server的三部曲</h1><ol>\n<li>服务器bind到一个端口，然后开始在该端口listen。</li>\n<li>客户端connect到该端口，将请求发送给服务端。</li>\n<li>服务端处理完响应的逻辑，数据write给client。</li>\n</ol>\n<p><img src=\"Tornado之web服务器的网络知识了解/2013_10_14_03.gif\" alt=\"\"></p>\n<p>由上面的图就可以清楚地看到，<strong>web服务器的三部曲，serverbind后就开始listen，接受client连接，client在发起连接后，server在接受到这个connect后，accept后建立与client一个socket连接，这样server端的client soceket就可以和client端的socketin进行通信了，包括接受数据，回写数据等。client发给server的request请求后，server接受到这个请求后把请求的内容转给处理这个请求的handler，handler按照相应逻辑处理后，把处理的数据通过socket连接回写给client，作为reponse，这样一个请求（client与server的交互）就完成了。若是短连接，则需要关闭连接；若是长连接，需要维护这个长连接，保持socket，使client与server的通道畅通无阻。</strong></p>\n<p>上面是一个简单的处理一个请求的，那如果client有上千呢，上万呢，即连接有成千上万的时候，那问题就复杂多了，这样就会出现所谓的C10K问题。</p>\n<h2 id=\"C10K问题\"><a href=\"#C10K问题\" class=\"headerlink\" title=\"C10K问题\"></a>C10K问题</h2><h3 id=\"C10K定义：\"><a href=\"#C10K定义：\" class=\"headerlink\" title=\"C10K定义：\"></a>C10K定义：</h3><p>C10K问题是指当网络服务在处理成千上万的客户端连接的时候，往往出现效率底下甚至完全瘫痪。当然这是在互联网还没有普及的情况下是C10K，在web2.0时代，可能是C100K，C5000K等，但是意思和C10K是一样的。</p>\n<h3 id=\"C10K的本质：\"><a href=\"#C10K的本质：\" class=\"headerlink\" title=\"C10K的本质：\"></a>C10K的本质：</h3><p>最早的时候服务器都是基于进程/线程模型来实现的，新来一个TCP链接，就需要分配一个进程/线程，但是进程/线程是操作系统最昂贵的，一台机器允许创建的进程数量有限的，况且进程在创建的比较多的时候，OS在调度、切换进程就需要耗费很多资源，效率低下。这种情况下，如果是C10K链接，那么就要创建1w的进程，那么OS根本是无法承受的，要继续服务，只能采用分布式，不断的加机器，但是加机器成本太大，一般公司的财力根本无法承受。这就是C10K问题出现的本质。</p>\n<p><em>实际上web1.0时代，也有异步模式，如select/poll等，但是这些技术都有一定的缺点，比如select最大不能超过1024，这是每个进程限制监听的最大打开的文件描述符数量；poll虽然没这个限制，可是每次接受到读写事件都需要遍历一次每个连接查看那个连接有数据请求，消耗较大。</em></p>\n<h2 id=\"C10K问题的一般选择的解决办法\"><a href=\"#C10K问题的一般选择的解决办法\" class=\"headerlink\" title=\"C10K问题的一般选择的解决办法\"></a>C10K问题的一般选择的解决办法</h2><p><strong>C10K问题解决一般使用Linux支持的epoll模型，epoll是异步非阻塞的，Nginx等都是epoll的产物.</strong></p>\n<p>既然要聊C10K这类网络问题，那么肯定要了解一下基础的网络模型和一些基础概念，比如select/poll/epoll，异步、同步I/O、阻塞、非阻塞等，下面就来讨论上述概念。</p>\n<h1 id=\"异步、同步、阻塞、非阻塞\"><a href=\"#异步、同步、阻塞、非阻塞\" class=\"headerlink\" title=\"异步、同步、阻塞、非阻塞\"></a>异步、同步、阻塞、非阻塞</h1><h2 id=\"同步、异步\"><a href=\"#同步、异步\" class=\"headerlink\" title=\"同步、异步\"></a>同步、异步</h2><p>所谓的<strong>同步、异步是基于消息通知机制角度，是针对应用程序与内核的交互</strong>来说的。</p>\n<ul>\n<li><strong>同步I/O</strong>是应用程序发出一个功能调用后，死等结果，没有结果，该调用不会返回的；</li>\n<li><strong>异步IO</strong>是应用程序发出一个功能调用后，应用程序不会等待调用执行结果的，该调用该功能完成后，自己给应用程序通知去。<br>下面用一张图来说明：<br><img src=\"Tornado之web服务器的网络知识了解/tornado_002.png\" alt=\"\"></li>\n</ul>\n<p>举一个现实场景来说明上述图，比如我去银行去办理存钱业务，有两种方式去等待：</p>\n<ul>\n<li>排队等待</li>\n<li>选择抽取一个号码，等到开始办理这个号码的时候，工作人员会在喇叭喊我或者打电话给我，通知我轮到我办理业务。</li>\n</ul>\n<p>其中前者就是同步等待消息通知，就是说一直在等待银行办理业务；后者就是等到银行通知，就是说异步等待消息通知，当事件发生后就触发回调机制去通知我。<br><strong>同步IO与异步IO的区别在于：应用程序调用是否会立即返回。</strong></p>\n<h2 id=\"阻塞、非阻塞\"><a href=\"#阻塞、非阻塞\" class=\"headerlink\" title=\"阻塞、非阻塞\"></a>阻塞、非阻塞</h2><p>所谓<strong>阻塞与非阻塞是从程序在等待消息通知（无所谓同步异步）时的状态</strong>而言的，就是消息通知到的时候，如果调用的程序的数据还未准备好，此时时立即返回还是等待数据准备完成再返回。</p>\n<ul>\n<li><strong>阻塞IO</strong>是指执行这个函数的线程会在程序调用返回之前，一直挂起当前线程，该线程一直处于等待消息通知，不能够执行其他业务，直到函数在拿到调用结果后才返回，线程恢复执行。</li>\n<li><strong>非阻塞IO</strong>是指程序调用中函数不等结果，立即返回，该函数不会阻塞线程，线程不会挂起，线程继续执行其他的任务。</li>\n</ul>\n<p>简单理解阻塞和非阻塞就是函数能不能立即返回，如果不能立即返回，需要等待，那么就是阻塞了；否则就是非阻塞了。<br><img src=\"Tornado之web服务器的网络知识了解/tornado_003.png\" alt=\"\"></p>\n<p>继续举例银行这个场景来说明上述问题，当你无论是排队等待办理业务，还是等待通知再去办理业务，等待期间，你有两种方式去消耗等待时间：</p>\n<ul>\n<li>一心一意等待，即一心一意的去排队，或者一心一意的等待叫你的号码，这期间除了等待消息之外，你什么都不能做，只是傻等。表现在程序中就是该函数调用之处不能继续朝下执行，阻塞了。</li>\n<li>等待的时候和老婆发微信聊天，刷朋友圈，直到排队到你办理业务，或者银行工作人员叫你号去办理业务。这就是说你没阻塞在等待排队到你或者等待叫你号这个消息通知上，你是在做自己的事，自己边玩边等。</li>\n</ul>\n<p>上述两种方式其实就是阻塞与非阻塞的区别。前者显然是阻塞，除了等待，你什么都不能做，无论什么方式的等待都阻塞了；后者当然就是非阻塞了，你可以在等待期间，做自己的事情。看起来后者的效率高，你即完成了老婆交代办理银行业务的事情，又陪老婆聊天了，但是等待办理业务的是你，和老婆聊天的是你，你需要看看到你没，不断在低头和老婆聊天。在两种方式之间不断切换，一心不可二用，在切换频率过高，或者切换干的事情过多的时候，这个切换的消耗非常大，这个平衡点需要把握。</p>\n<p><strong>阻塞和非阻塞的区别在于：数据拷贝的时候，进程是否阻塞！</strong></p>\n<h2 id=\"同步-异步-阻塞-非阻塞的组合解释\"><a href=\"#同步-异步-阻塞-非阻塞的组合解释\" class=\"headerlink\" title=\"同步/异步-阻塞/非阻塞的组合解释\"></a>同步/异步-阻塞/非阻塞的组合解释</h2><p><strong>阻塞调用和同步调用不是一回事，</strong>不要混淆，对于同步调用来说，很多时候线程可能还是激活状态，并没有挂起，只是从逻辑上来说当时的函数还没有返回，但是此时线程可能也会处理别的事情。比如上述银行例子，同步调用只是在等待，但是这个等待调用可以是阻塞，也可以是非阻塞，也就是你可以一边等待一边刷微信和老婆聊天，也可以什么都不干一心一意的等到到你办理业务。</p>\n<p>通过上面的同步/异步和阻塞/非阻塞的介绍，既然这四种形式是从不同的角度划分的，那么就可以分为<strong>同步阻塞</strong>，<strong>同步非阻塞</strong>，<strong>异步阻塞</strong>，<strong>异步非阻塞</strong>四种了。</p>\n<ul>\n<li><strong>同步阻塞：</strong>即消息通知是同步的，而且会等待数据返回，不仅通知到还要拿到数据结果再返回来。比如上面银行的例子，同步阻塞的意思就是你只能专心排队等待，什么事情都不能做的。</li>\n<li><strong>异步阻塞：</strong>采用异步的方式等待消息被触发，也就是说你在银行办业务的时候，拿到纸条后，只能呆呆的坐在大厅等候叫你，不能离开银行，或者不能刷朋友圈，你就被阻塞在这个事情上了，哪里也去不了了。<strong>异步操作是可以被阻塞住的，只不过它不是在消息通知时阻塞，而是在等待消息通知这个事情上阻塞了。</strong></li>\n<li><strong>同步非阻塞：</strong>即消息通知是同步的，但是你可以不等待调用程序的数据准备好就返回。比如你一边在排队，一边在和老婆刷微信，只是你需要不断的在刷微信和抬头看你快排到了没这两种方式之间不停的来回切换。</li>\n<li><strong>异步非阻塞：</strong>消息通知到，而且不等待数据就直接返回了。比如你拿到号后，在大厅座位上等待的时候可以刷微信，或者你突然口渴想去超市买水，此时你告诉大堂经理，到你号的时候，打电话叫你一下（注册回调函数）。此时你并没有阻塞在银行办理业务这个事情上，这就是异步+非阻塞的方式，显然这种方式要高一些。程序也没有在两个不同的操作之间来回切换，因为给打电话是大堂经理的事情（消息触发机制），你只需要等待就好，触发了则通知你。</li>\n</ul>\n<p>综上所述，同步/异步关注的是消息的通知机制，阻塞/非阻塞所关注的时候是程序（线程）等待消息通知期间的状态。</p>\n<h2 id=\"再次举例说明同步、异步、阻塞、非阻塞\"><a href=\"#再次举例说明同步、异步、阻塞、非阻塞\" class=\"headerlink\" title=\"再次举例说明同步、异步、阻塞、非阻塞\"></a>再次举例说明同步、异步、阻塞、非阻塞</h2><p>上面已经明确说明，<strong>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态。</strong>，下面在举例一个场景，以小明下载文件为例，从这两个关注点来再次说明这两组概念。</p>\n<ul>\n<li>同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。</li>\n</ul>\n<blockquote>\n<p>同步体现在：等待下载完成通知；<br>阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；</p>\n</blockquote>\n<ul>\n<li>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到100% 就完成。 </li>\n</ul>\n<blockquote>\n<p>同步体现在：等待下载完成通知；<br>非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】</p>\n</blockquote>\n<ul>\n<li>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音。</li>\n</ul>\n<blockquote>\n<p>异步体现在：下载完成“叮”一声通知；<br>阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；</p>\n</blockquote>\n<ul>\n<li>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</li>\n</ul>\n<blockquote>\n<p>异步体现在：下载完成“叮”一声通知；<br>非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>\n</blockquote>\n<p><strong>也就是说，同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）。</strong></p>\n<h1 id=\"Linux下五种IO模型\"><a href=\"#Linux下五种IO模型\" class=\"headerlink\" title=\"Linux下五种IO模型\"></a>Linux下五种IO模型</h1><p>网络IO的本质其实就是socket的读取，因为在Linux中socket被抽象成<strong>流</strong>，所以网络IO可以理解为对流的操作。<br>对于一次IO访问，数据先会被copy到os内核缓冲区，然后再从操作系统内核缓冲区copy到进程缓冲区。同理，对于sockt的IO而言，也要经历两步：</p>\n<ul>\n<li>等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li>\n<li>把数据从内核缓冲区，复制到进程的缓冲区中。</li>\n</ul>\n<p><strong>下面着重介绍Linux的五种常用的IO模型</strong>：</p>\n<ul>\n<li>同步阻塞IO</li>\n<li>同步非阻塞IO</li>\n<li>IO复用(select和poll、epoll)—其实也是同步的</li>\n<li>异步非阻塞IO</li>\n<li>信号驱动IO</li>\n</ul>\n<p>其中前四种比较常用，尤其是IO复用，是现在网络编程的重点。下面重点介绍前四种。讲使用上面的银行柜台办理业务举例说明这几种模型。</p>\n<h2 id=\"同步阻塞IO\"><a href=\"#同步阻塞IO\" class=\"headerlink\" title=\"同步阻塞IO\"></a>同步阻塞IO</h2><blockquote>\n<p>我在银行办理业务，人爆满，所以我不知道什么时候能轮到我办理业务，但是我又不能离开，我只能等待，等待轮到我办理，这等待期间我不能出去抽烟，更不能先回家女朋友，所有的事情都被办理业务这个事情阻塞着。这就是一个典型的同步阻塞IO。</p>\n</blockquote>\n<p>同步阻塞IO是最常见的一种IO模型，也是最简单的一种模型，默认情况下都是同步阻塞IO模型。<br><strong>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费CPU而只是简单等待响应的状态。</strong><br>下图是在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_004.png\" alt=\"\"></p>\n<p>同步阻塞IO的特点就是在数据准备和数据拷贝的两个阶段都被block了。</p>\n<h2 id=\"同步非阻塞IO\"><a href=\"#同步非阻塞IO\" class=\"headerlink\" title=\"同步非阻塞IO\"></a>同步非阻塞IO</h2><blockquote>\n<p>我一直在银行傻等着办理业务，又不是阿甘能等到苹果公司的股票，况且旁边就是优衣库，我肯定不甘心这么浪费我的青春年华，所以我决定出去转转，看看能不能给老婆淘点宝回去。可是我的第一要务是办理银行业务，所以我不得不一会跑回来看看快到我没，一会又去优衣库，来回的切换，这就是典型的同步非阻塞IO，但是来来回回折腾，太累人了。<br>所以同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。</p>\n</blockquote>\n<p>由以上例子我们就可以看出：<br><strong>非阻塞IO也会进行recvform系统调用，检查数据是否准备好。只是非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</strong></p>\n<p>下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_005.png\" alt=\"\"></p>\n<p>同步非阻塞IO的特点是用户进程需要不断的主动询问数据好了没有，需要轮询</p>\n<h2 id=\"IO复用-select和poll、epoll\"><a href=\"#IO复用-select和poll、epoll\" class=\"headerlink\" title=\"IO复用(select和poll、epoll)\"></a>IO复用(select和poll、epoll)</h2><blockquote>\n<p>此类型和同步阻塞差不多，银行在大堂装有大屏幕，这样我就不用每次回去问那个一脸我欠她几百万的样子的阿姨了，我直接看大屏幕就好了，但是还是要轮询去看。</p>\n</blockquote>\n<p>IO复用就是同步非阻塞的2.0版，比如我不仅仅是办理银行业务，可能我还办理电话卡业务等，也就是说后台有多个任务在等待，我需要不断的在这好多个等待的进程中去切换，太累了，此时我老婆嫌我太累，来帮我看一半的业务，我来看一半，好了就通知我去办理，那么此时我老婆和我合起来就是所谓的<strong>IO复用</strong>，那么在Linux界，我老婆就相等于select、poll、epoll。</p>\n<p>可以看出IO复用其实也是要轮询多个socket的，只不过使用select\\poll\\epoll来轮询的，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p>\n<p>下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_006.png\" alt=\"\"></p>\n<p>多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p>\n<p><em>IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。</em></p>\n<h2 id=\"异步非阻塞IO\"><a href=\"#异步非阻塞IO\" class=\"headerlink\" title=\"异步非阻塞IO\"></a>异步非阻塞IO</h2><blockquote>\n<p>我在银行办理业务的时候，恰好碰见我一朋友，我朋友见我心不在焉，就说让我可以先回家，等到到我的时候，他给我打电话。于是我就吃着火锅唱着歌回家等待我朋友电话通知了。这就是异步非阻塞。</p>\n</blockquote>\n<p>异步非阻塞IO中，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p>\n<p>下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_007.png\" alt=\"\"></p>\n<p>上面这个看起来是很理想的情况，可是越理想，实现起来越麻烦，主要是操作系统实现API比较困难，有些os根本就不支持异步IO，而且异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。</p>\n<h2 id=\"五种IO类型的对比图\"><a href=\"#五种IO类型的对比图\" class=\"headerlink\" title=\"五种IO类型的对比图\"></a>五种IO类型的对比图</h2><p><img src=\"Tornado之web服务器的网络知识了解/tornado_008.png\" alt=\"\"></p>\n<h1 id=\"select、poll、epoll\"><a href=\"#select、poll、epoll\" class=\"headerlink\" title=\"select、poll、epoll\"></a>select、poll、epoll</h1><h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><h3 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h3><p>要了解epoll等时间必须先了解流的概念。流在上面我们已经介绍过了，在Linux中，文件、socket、pipe等等可以进行IO操作的内核对象，都可以看做一个流。</p>\n<h3 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h3><p>再来了解一个概念，缓冲区：缓冲区的引入是为了减少频繁IO操作而引起的频繁的系统调用（很慢，很重），当你操作一个流的时候，更多的是以缓冲区为单位进行操作的，当然这是相对于用户而言的。对于内核而言，也有自己的缓冲区。所以缓冲区又分为用户缓冲区和内核缓冲区。</p>\n<h3 id=\"阻塞IO缺点\"><a href=\"#阻塞IO缺点\" class=\"headerlink\" title=\"阻塞IO缺点\"></a>阻塞IO缺点</h3><p>上面我们详细的介绍了阻塞与非阻塞，我们知道阻塞IO的典型缺点是，在此模式下，一个线程/进程只能处理一个流的IO事件，所以要处理很多的流的IO事件，唯有开多个线程或者进程，很显然这种办法很笨，而且效率不高，处理的流有限。</p>\n<h3 id=\"非阻塞IO\"><a href=\"#非阻塞IO\" class=\"headerlink\" title=\"非阻塞IO\"></a>非阻塞IO</h3><p>那么要处理高并发，就只剩下非阻塞IO了，既然是非阻塞的IO，那么就不是实时的，肯定就需要忙轮询，不断的去检查那个流可以进行读写了，一遍遍检查。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> starteam[];&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> i has data:</div><div class=\"line\">            read until unavailable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述代码，我们看到我们需要不断的去轮询整个流，从而处理多流的情况。但是这样明显若是没有事件发生，就会白白浪费宝贵的CPU资源。为了避免无效的CPU轮询，就引入了一个代理，select代理，poll代理。</p>\n<h3 id=\"select-、poll\"><a href=\"#select-、poll\" class=\"headerlink\" title=\"select 、poll\"></a>select 、poll</h3><p> select、poll可以同时观察多个流的IO事件，他们本质上是一致的。在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span> &#123;</div><div class=\"line\">    select/poll(streams[])</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> starteam[];&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> i has data:</div><div class=\"line\">            read until unavailable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此时没有IO事件发生的时候，程序就阻塞在select以外，但是这时候他的缺点也暴露出来了。当流发生IO事件后，却不知道是那个流可以读数据或者写数据了，我们只能<strong>无差别的轮询</strong>一遍所有的流，找出能读数据或者写数据的流，对他们进行操作。<br><strong>因此使用select的时候，我们又O(n)的无差别的轮询复杂度，显然同时处理的流越多，每一次轮询所花费的轮询时间越长。</strong><br>终于epoll大牛出现了。</p>\n<h3 id=\"epoll介绍\"><a href=\"#epoll介绍\" class=\"headerlink\" title=\"epoll介绍\"></a>epoll介绍</h3><p><strong>epoll可以理解为event poll，它不同于忙轮询和无差别的轮询，epoll会把那个流发生了什么样的IO事件通知我们，因此我们每次的对这些流的操作都是有意义的。复杂度瞬间降低到了O(k),K是发生的IO事件的流的个数，也有人认为是O(1)，显然效率和上述各种模型不在一个档次了，</strong>男神啊简直是。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> true &#123;</div><div class=\"line\">    active_stream[] = epoll_wait(epollfd)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> active_stream[] &#123;</div><div class=\"line\">        read <span class=\"keyword\">or</span> write till unavailable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>即工作情形大致是：</p>\n<ul>\n<li>epoll_create 创建一个epoll对象，一般epollfd = epoll_create() </li>\n<li>epoll_ctl（epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件。比如epoll_ctl(epollfd, EPOLL_CTL_ADD,socket,EPOLLIN);//有缓冲区内有数据时epoll_wait返回，epoll_ctl(epollfd, EPOLL_CTL_DEL,socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回</li>\n<li>epoll_wait(epollfd,…)等待直到注册的事件发生。</li>\n</ul>\n<p>到此为止，本文就详细的聊了网络编程中一些基础概念，了解这些概念后，我们下一步就详细的剖析Tornado的源码，和高手过招，一定很刺激。</p>\n<p>学Python，我们是认真的。</p>\n<p><a href=\"http://blog.jobbole.com/99905/\" target=\"_blank\" rel=\"external\">比较好的讲解的博客推荐</a></p>\n","excerpt":"<p>在详解Tornado的HTTP Server架构模型之前，先简单的聊聊web服务器的网络知识。首先了解一下，网络中的数据是怎么流动的。<br>","more":"</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_000.png\" alt=\"\"></p>\n<p>用户请求数据给服务器的时候，与上图类似。其实网络数据和自来水管的水是一样的，哪里有道就朝哪里流。所以要让数据流动起来，当然是搭桥修路了。科技如此发达，搭桥修路的方法当然会各种各样。但是不管怎么样变，他们的目标就是搭桥修路，那么就有一些共同的特点。www上所谓的搭桥修路就是web server是比较重要的一种方式，下面看看web server。</p>\n<p>tornado也是一个web server，那么必然要遵循web server的三部曲。</p>\n<h1 id=\"web-server的三部曲\"><a href=\"#web-server的三部曲\" class=\"headerlink\" title=\"web server的三部曲\"></a>web server的三部曲</h1><ol>\n<li>服务器bind到一个端口，然后开始在该端口listen。</li>\n<li>客户端connect到该端口，将请求发送给服务端。</li>\n<li>服务端处理完响应的逻辑，数据write给client。</li>\n</ol>\n<p><img src=\"Tornado之web服务器的网络知识了解/2013_10_14_03.gif\" alt=\"\"></p>\n<p>由上面的图就可以清楚地看到，<strong>web服务器的三部曲，serverbind后就开始listen，接受client连接，client在发起连接后，server在接受到这个connect后，accept后建立与client一个socket连接，这样server端的client soceket就可以和client端的socketin进行通信了，包括接受数据，回写数据等。client发给server的request请求后，server接受到这个请求后把请求的内容转给处理这个请求的handler，handler按照相应逻辑处理后，把处理的数据通过socket连接回写给client，作为reponse，这样一个请求（client与server的交互）就完成了。若是短连接，则需要关闭连接；若是长连接，需要维护这个长连接，保持socket，使client与server的通道畅通无阻。</strong></p>\n<p>上面是一个简单的处理一个请求的，那如果client有上千呢，上万呢，即连接有成千上万的时候，那问题就复杂多了，这样就会出现所谓的C10K问题。</p>\n<h2 id=\"C10K问题\"><a href=\"#C10K问题\" class=\"headerlink\" title=\"C10K问题\"></a>C10K问题</h2><h3 id=\"C10K定义：\"><a href=\"#C10K定义：\" class=\"headerlink\" title=\"C10K定义：\"></a>C10K定义：</h3><p>C10K问题是指当网络服务在处理成千上万的客户端连接的时候，往往出现效率底下甚至完全瘫痪。当然这是在互联网还没有普及的情况下是C10K，在web2.0时代，可能是C100K，C5000K等，但是意思和C10K是一样的。</p>\n<h3 id=\"C10K的本质：\"><a href=\"#C10K的本质：\" class=\"headerlink\" title=\"C10K的本质：\"></a>C10K的本质：</h3><p>最早的时候服务器都是基于进程/线程模型来实现的，新来一个TCP链接，就需要分配一个进程/线程，但是进程/线程是操作系统最昂贵的，一台机器允许创建的进程数量有限的，况且进程在创建的比较多的时候，OS在调度、切换进程就需要耗费很多资源，效率低下。这种情况下，如果是C10K链接，那么就要创建1w的进程，那么OS根本是无法承受的，要继续服务，只能采用分布式，不断的加机器，但是加机器成本太大，一般公司的财力根本无法承受。这就是C10K问题出现的本质。</p>\n<p><em>实际上web1.0时代，也有异步模式，如select/poll等，但是这些技术都有一定的缺点，比如select最大不能超过1024，这是每个进程限制监听的最大打开的文件描述符数量；poll虽然没这个限制，可是每次接受到读写事件都需要遍历一次每个连接查看那个连接有数据请求，消耗较大。</em></p>\n<h2 id=\"C10K问题的一般选择的解决办法\"><a href=\"#C10K问题的一般选择的解决办法\" class=\"headerlink\" title=\"C10K问题的一般选择的解决办法\"></a>C10K问题的一般选择的解决办法</h2><p><strong>C10K问题解决一般使用Linux支持的epoll模型，epoll是异步非阻塞的，Nginx等都是epoll的产物.</strong></p>\n<p>既然要聊C10K这类网络问题，那么肯定要了解一下基础的网络模型和一些基础概念，比如select/poll/epoll，异步、同步I/O、阻塞、非阻塞等，下面就来讨论上述概念。</p>\n<h1 id=\"异步、同步、阻塞、非阻塞\"><a href=\"#异步、同步、阻塞、非阻塞\" class=\"headerlink\" title=\"异步、同步、阻塞、非阻塞\"></a>异步、同步、阻塞、非阻塞</h1><h2 id=\"同步、异步\"><a href=\"#同步、异步\" class=\"headerlink\" title=\"同步、异步\"></a>同步、异步</h2><p>所谓的<strong>同步、异步是基于消息通知机制角度，是针对应用程序与内核的交互</strong>来说的。</p>\n<ul>\n<li><strong>同步I/O</strong>是应用程序发出一个功能调用后，死等结果，没有结果，该调用不会返回的；</li>\n<li><strong>异步IO</strong>是应用程序发出一个功能调用后，应用程序不会等待调用执行结果的，该调用该功能完成后，自己给应用程序通知去。<br>下面用一张图来说明：<br><img src=\"Tornado之web服务器的网络知识了解/tornado_002.png\" alt=\"\"></li>\n</ul>\n<p>举一个现实场景来说明上述图，比如我去银行去办理存钱业务，有两种方式去等待：</p>\n<ul>\n<li>排队等待</li>\n<li>选择抽取一个号码，等到开始办理这个号码的时候，工作人员会在喇叭喊我或者打电话给我，通知我轮到我办理业务。</li>\n</ul>\n<p>其中前者就是同步等待消息通知，就是说一直在等待银行办理业务；后者就是等到银行通知，就是说异步等待消息通知，当事件发生后就触发回调机制去通知我。<br><strong>同步IO与异步IO的区别在于：应用程序调用是否会立即返回。</strong></p>\n<h2 id=\"阻塞、非阻塞\"><a href=\"#阻塞、非阻塞\" class=\"headerlink\" title=\"阻塞、非阻塞\"></a>阻塞、非阻塞</h2><p>所谓<strong>阻塞与非阻塞是从程序在等待消息通知（无所谓同步异步）时的状态</strong>而言的，就是消息通知到的时候，如果调用的程序的数据还未准备好，此时时立即返回还是等待数据准备完成再返回。</p>\n<ul>\n<li><strong>阻塞IO</strong>是指执行这个函数的线程会在程序调用返回之前，一直挂起当前线程，该线程一直处于等待消息通知，不能够执行其他业务，直到函数在拿到调用结果后才返回，线程恢复执行。</li>\n<li><strong>非阻塞IO</strong>是指程序调用中函数不等结果，立即返回，该函数不会阻塞线程，线程不会挂起，线程继续执行其他的任务。</li>\n</ul>\n<p>简单理解阻塞和非阻塞就是函数能不能立即返回，如果不能立即返回，需要等待，那么就是阻塞了；否则就是非阻塞了。<br><img src=\"Tornado之web服务器的网络知识了解/tornado_003.png\" alt=\"\"></p>\n<p>继续举例银行这个场景来说明上述问题，当你无论是排队等待办理业务，还是等待通知再去办理业务，等待期间，你有两种方式去消耗等待时间：</p>\n<ul>\n<li>一心一意等待，即一心一意的去排队，或者一心一意的等待叫你的号码，这期间除了等待消息之外，你什么都不能做，只是傻等。表现在程序中就是该函数调用之处不能继续朝下执行，阻塞了。</li>\n<li>等待的时候和老婆发微信聊天，刷朋友圈，直到排队到你办理业务，或者银行工作人员叫你号去办理业务。这就是说你没阻塞在等待排队到你或者等待叫你号这个消息通知上，你是在做自己的事，自己边玩边等。</li>\n</ul>\n<p>上述两种方式其实就是阻塞与非阻塞的区别。前者显然是阻塞，除了等待，你什么都不能做，无论什么方式的等待都阻塞了；后者当然就是非阻塞了，你可以在等待期间，做自己的事情。看起来后者的效率高，你即完成了老婆交代办理银行业务的事情，又陪老婆聊天了，但是等待办理业务的是你，和老婆聊天的是你，你需要看看到你没，不断在低头和老婆聊天。在两种方式之间不断切换，一心不可二用，在切换频率过高，或者切换干的事情过多的时候，这个切换的消耗非常大，这个平衡点需要把握。</p>\n<p><strong>阻塞和非阻塞的区别在于：数据拷贝的时候，进程是否阻塞！</strong></p>\n<h2 id=\"同步-异步-阻塞-非阻塞的组合解释\"><a href=\"#同步-异步-阻塞-非阻塞的组合解释\" class=\"headerlink\" title=\"同步/异步-阻塞/非阻塞的组合解释\"></a>同步/异步-阻塞/非阻塞的组合解释</h2><p><strong>阻塞调用和同步调用不是一回事，</strong>不要混淆，对于同步调用来说，很多时候线程可能还是激活状态，并没有挂起，只是从逻辑上来说当时的函数还没有返回，但是此时线程可能也会处理别的事情。比如上述银行例子，同步调用只是在等待，但是这个等待调用可以是阻塞，也可以是非阻塞，也就是你可以一边等待一边刷微信和老婆聊天，也可以什么都不干一心一意的等到到你办理业务。</p>\n<p>通过上面的同步/异步和阻塞/非阻塞的介绍，既然这四种形式是从不同的角度划分的，那么就可以分为<strong>同步阻塞</strong>，<strong>同步非阻塞</strong>，<strong>异步阻塞</strong>，<strong>异步非阻塞</strong>四种了。</p>\n<ul>\n<li><strong>同步阻塞：</strong>即消息通知是同步的，而且会等待数据返回，不仅通知到还要拿到数据结果再返回来。比如上面银行的例子，同步阻塞的意思就是你只能专心排队等待，什么事情都不能做的。</li>\n<li><strong>异步阻塞：</strong>采用异步的方式等待消息被触发，也就是说你在银行办业务的时候，拿到纸条后，只能呆呆的坐在大厅等候叫你，不能离开银行，或者不能刷朋友圈，你就被阻塞在这个事情上了，哪里也去不了了。<strong>异步操作是可以被阻塞住的，只不过它不是在消息通知时阻塞，而是在等待消息通知这个事情上阻塞了。</strong></li>\n<li><strong>同步非阻塞：</strong>即消息通知是同步的，但是你可以不等待调用程序的数据准备好就返回。比如你一边在排队，一边在和老婆刷微信，只是你需要不断的在刷微信和抬头看你快排到了没这两种方式之间不停的来回切换。</li>\n<li><strong>异步非阻塞：</strong>消息通知到，而且不等待数据就直接返回了。比如你拿到号后，在大厅座位上等待的时候可以刷微信，或者你突然口渴想去超市买水，此时你告诉大堂经理，到你号的时候，打电话叫你一下（注册回调函数）。此时你并没有阻塞在银行办理业务这个事情上，这就是异步+非阻塞的方式，显然这种方式要高一些。程序也没有在两个不同的操作之间来回切换，因为给打电话是大堂经理的事情（消息触发机制），你只需要等待就好，触发了则通知你。</li>\n</ul>\n<p>综上所述，同步/异步关注的是消息的通知机制，阻塞/非阻塞所关注的时候是程序（线程）等待消息通知期间的状态。</p>\n<h2 id=\"再次举例说明同步、异步、阻塞、非阻塞\"><a href=\"#再次举例说明同步、异步、阻塞、非阻塞\" class=\"headerlink\" title=\"再次举例说明同步、异步、阻塞、非阻塞\"></a>再次举例说明同步、异步、阻塞、非阻塞</h2><p>上面已经明确说明，<strong>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态。</strong>，下面在举例一个场景，以小明下载文件为例，从这两个关注点来再次说明这两组概念。</p>\n<ul>\n<li>同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。</li>\n</ul>\n<blockquote>\n<p>同步体现在：等待下载完成通知；<br>阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；</p>\n</blockquote>\n<ul>\n<li>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到100% 就完成。 </li>\n</ul>\n<blockquote>\n<p>同步体现在：等待下载完成通知；<br>非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】</p>\n</blockquote>\n<ul>\n<li>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音。</li>\n</ul>\n<blockquote>\n<p>异步体现在：下载完成“叮”一声通知；<br>阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；</p>\n</blockquote>\n<ul>\n<li>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</li>\n</ul>\n<blockquote>\n<p>异步体现在：下载完成“叮”一声通知；<br>非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>\n</blockquote>\n<p><strong>也就是说，同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）。</strong></p>\n<h1 id=\"Linux下五种IO模型\"><a href=\"#Linux下五种IO模型\" class=\"headerlink\" title=\"Linux下五种IO模型\"></a>Linux下五种IO模型</h1><p>网络IO的本质其实就是socket的读取，因为在Linux中socket被抽象成<strong>流</strong>，所以网络IO可以理解为对流的操作。<br>对于一次IO访问，数据先会被copy到os内核缓冲区，然后再从操作系统内核缓冲区copy到进程缓冲区。同理，对于sockt的IO而言，也要经历两步：</p>\n<ul>\n<li>等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li>\n<li>把数据从内核缓冲区，复制到进程的缓冲区中。</li>\n</ul>\n<p><strong>下面着重介绍Linux的五种常用的IO模型</strong>：</p>\n<ul>\n<li>同步阻塞IO</li>\n<li>同步非阻塞IO</li>\n<li>IO复用(select和poll、epoll)—其实也是同步的</li>\n<li>异步非阻塞IO</li>\n<li>信号驱动IO</li>\n</ul>\n<p>其中前四种比较常用，尤其是IO复用，是现在网络编程的重点。下面重点介绍前四种。讲使用上面的银行柜台办理业务举例说明这几种模型。</p>\n<h2 id=\"同步阻塞IO\"><a href=\"#同步阻塞IO\" class=\"headerlink\" title=\"同步阻塞IO\"></a>同步阻塞IO</h2><blockquote>\n<p>我在银行办理业务，人爆满，所以我不知道什么时候能轮到我办理业务，但是我又不能离开，我只能等待，等待轮到我办理，这等待期间我不能出去抽烟，更不能先回家女朋友，所有的事情都被办理业务这个事情阻塞着。这就是一个典型的同步阻塞IO。</p>\n</blockquote>\n<p>同步阻塞IO是最常见的一种IO模型，也是最简单的一种模型，默认情况下都是同步阻塞IO模型。<br><strong>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费CPU而只是简单等待响应的状态。</strong><br>下图是在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_004.png\" alt=\"\"></p>\n<p>同步阻塞IO的特点就是在数据准备和数据拷贝的两个阶段都被block了。</p>\n<h2 id=\"同步非阻塞IO\"><a href=\"#同步非阻塞IO\" class=\"headerlink\" title=\"同步非阻塞IO\"></a>同步非阻塞IO</h2><blockquote>\n<p>我一直在银行傻等着办理业务，又不是阿甘能等到苹果公司的股票，况且旁边就是优衣库，我肯定不甘心这么浪费我的青春年华，所以我决定出去转转，看看能不能给老婆淘点宝回去。可是我的第一要务是办理银行业务，所以我不得不一会跑回来看看快到我没，一会又去优衣库，来回的切换，这就是典型的同步非阻塞IO，但是来来回回折腾，太累人了。<br>所以同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。</p>\n</blockquote>\n<p>由以上例子我们就可以看出：<br><strong>非阻塞IO也会进行recvform系统调用，检查数据是否准备好。只是非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</strong></p>\n<p>下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_005.png\" alt=\"\"></p>\n<p>同步非阻塞IO的特点是用户进程需要不断的主动询问数据好了没有，需要轮询</p>\n<h2 id=\"IO复用-select和poll、epoll\"><a href=\"#IO复用-select和poll、epoll\" class=\"headerlink\" title=\"IO复用(select和poll、epoll)\"></a>IO复用(select和poll、epoll)</h2><blockquote>\n<p>此类型和同步阻塞差不多，银行在大堂装有大屏幕，这样我就不用每次回去问那个一脸我欠她几百万的样子的阿姨了，我直接看大屏幕就好了，但是还是要轮询去看。</p>\n</blockquote>\n<p>IO复用就是同步非阻塞的2.0版，比如我不仅仅是办理银行业务，可能我还办理电话卡业务等，也就是说后台有多个任务在等待，我需要不断的在这好多个等待的进程中去切换，太累了，此时我老婆嫌我太累，来帮我看一半的业务，我来看一半，好了就通知我去办理，那么此时我老婆和我合起来就是所谓的<strong>IO复用</strong>，那么在Linux界，我老婆就相等于select、poll、epoll。</p>\n<p>可以看出IO复用其实也是要轮询多个socket的，只不过使用select\\poll\\epoll来轮询的，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p>\n<p>下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_006.png\" alt=\"\"></p>\n<p>多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p>\n<p><em>IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。</em></p>\n<h2 id=\"异步非阻塞IO\"><a href=\"#异步非阻塞IO\" class=\"headerlink\" title=\"异步非阻塞IO\"></a>异步非阻塞IO</h2><blockquote>\n<p>我在银行办理业务的时候，恰好碰见我一朋友，我朋友见我心不在焉，就说让我可以先回家，等到到我的时候，他给我打电话。于是我就吃着火锅唱着歌回家等待我朋友电话通知了。这就是异步非阻塞。</p>\n</blockquote>\n<p>异步非阻塞IO中，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p>\n<p>下图是同步阻塞IO在内核中等待数据和复制数据的大致网络模型图：</p>\n<p><img src=\"Tornado之web服务器的网络知识了解/tornado_007.png\" alt=\"\"></p>\n<p>上面这个看起来是很理想的情况，可是越理想，实现起来越麻烦，主要是操作系统实现API比较困难，有些os根本就不支持异步IO，而且异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。</p>\n<h2 id=\"五种IO类型的对比图\"><a href=\"#五种IO类型的对比图\" class=\"headerlink\" title=\"五种IO类型的对比图\"></a>五种IO类型的对比图</h2><p><img src=\"Tornado之web服务器的网络知识了解/tornado_008.png\" alt=\"\"></p>\n<h1 id=\"select、poll、epoll\"><a href=\"#select、poll、epoll\" class=\"headerlink\" title=\"select、poll、epoll\"></a>select、poll、epoll</h1><h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><h3 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h3><p>要了解epoll等时间必须先了解流的概念。流在上面我们已经介绍过了，在Linux中，文件、socket、pipe等等可以进行IO操作的内核对象，都可以看做一个流。</p>\n<h3 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h3><p>再来了解一个概念，缓冲区：缓冲区的引入是为了减少频繁IO操作而引起的频繁的系统调用（很慢，很重），当你操作一个流的时候，更多的是以缓冲区为单位进行操作的，当然这是相对于用户而言的。对于内核而言，也有自己的缓冲区。所以缓冲区又分为用户缓冲区和内核缓冲区。</p>\n<h3 id=\"阻塞IO缺点\"><a href=\"#阻塞IO缺点\" class=\"headerlink\" title=\"阻塞IO缺点\"></a>阻塞IO缺点</h3><p>上面我们详细的介绍了阻塞与非阻塞，我们知道阻塞IO的典型缺点是，在此模式下，一个线程/进程只能处理一个流的IO事件，所以要处理很多的流的IO事件，唯有开多个线程或者进程，很显然这种办法很笨，而且效率不高，处理的流有限。</p>\n<h3 id=\"非阻塞IO\"><a href=\"#非阻塞IO\" class=\"headerlink\" title=\"非阻塞IO\"></a>非阻塞IO</h3><p>那么要处理高并发，就只剩下非阻塞IO了，既然是非阻塞的IO，那么就不是实时的，肯定就需要忙轮询，不断的去检查那个流可以进行读写了，一遍遍检查。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> starteam[];&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> i has data:</div><div class=\"line\">            read until unavailable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述代码，我们看到我们需要不断的去轮询整个流，从而处理多流的情况。但是这样明显若是没有事件发生，就会白白浪费宝贵的CPU资源。为了避免无效的CPU轮询，就引入了一个代理，select代理，poll代理。</p>\n<h3 id=\"select-、poll\"><a href=\"#select-、poll\" class=\"headerlink\" title=\"select 、poll\"></a>select 、poll</h3><p> select、poll可以同时观察多个流的IO事件，他们本质上是一致的。在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span> &#123;</div><div class=\"line\">    select/poll(streams[])</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> starteam[];&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> i has data:</div><div class=\"line\">            read until unavailable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此时没有IO事件发生的时候，程序就阻塞在select以外，但是这时候他的缺点也暴露出来了。当流发生IO事件后，却不知道是那个流可以读数据或者写数据了，我们只能<strong>无差别的轮询</strong>一遍所有的流，找出能读数据或者写数据的流，对他们进行操作。<br><strong>因此使用select的时候，我们又O(n)的无差别的轮询复杂度，显然同时处理的流越多，每一次轮询所花费的轮询时间越长。</strong><br>终于epoll大牛出现了。</p>\n<h3 id=\"epoll介绍\"><a href=\"#epoll介绍\" class=\"headerlink\" title=\"epoll介绍\"></a>epoll介绍</h3><p><strong>epoll可以理解为event poll，它不同于忙轮询和无差别的轮询，epoll会把那个流发生了什么样的IO事件通知我们，因此我们每次的对这些流的操作都是有意义的。复杂度瞬间降低到了O(k),K是发生的IO事件的流的个数，也有人认为是O(1)，显然效率和上述各种模型不在一个档次了，</strong>男神啊简直是。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> true &#123;</div><div class=\"line\">    active_stream[] = epoll_wait(epollfd)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> active_stream[] &#123;</div><div class=\"line\">        read <span class=\"keyword\">or</span> write till unavailable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>即工作情形大致是：</p>\n<ul>\n<li>epoll_create 创建一个epoll对象，一般epollfd = epoll_create() </li>\n<li>epoll_ctl（epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件。比如epoll_ctl(epollfd, EPOLL_CTL_ADD,socket,EPOLLIN);//有缓冲区内有数据时epoll_wait返回，epoll_ctl(epollfd, EPOLL_CTL_DEL,socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回</li>\n<li>epoll_wait(epollfd,…)等待直到注册的事件发生。</li>\n</ul>\n<p>到此为止，本文就详细的聊了网络编程中一些基础概念，了解这些概念后，我们下一步就详细的剖析Tornado的源码，和高手过招，一定很刺激。</p>\n<p>学Python，我们是认真的。</p>\n<p><a href=\"http://blog.jobbole.com/99905/\">比较好的讲解的博客推荐</a></p>"},{"title":"Tornado的HTTP Server的服务模型","date":"2016-05-08T17:14:31.000Z","toc":true,"comments":1,"_content":"\n\n简单介绍web server的一般架构，重点介绍Tornado的HTTP Server架构模型。\n<!-- more -->\n\n首先了解一下，网络中的数据是怎么流动的。\n\n![](Tornado的HTTP-Server的服务模型/tornado_000.gif)\n\n","source":"_posts/Tornado的HTTP-Server的服务模型.md","raw":"---\ntitle: Tornado的HTTP Server的服务模型\ndate: 2016-05-09 01:14:31\ntags: Tornado源码分析\ncategories: Tornado系列\ntoc: true\ncomments: true\n---\n\n\n简单介绍web server的一般架构，重点介绍Tornado的HTTP Server架构模型。\n<!-- more -->\n\n首先了解一下，网络中的数据是怎么流动的。\n\n![](Tornado的HTTP-Server的服务模型/tornado_000.gif)\n\n","slug":"Tornado的HTTP-Server的服务模型","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoironw0008ta02fyqh96ev","content":"<p>简单介绍web server的一般架构，重点介绍Tornado的HTTP Server架构模型。<br><a id=\"more\"></a></p>\n<p>首先了解一下，网络中的数据是怎么流动的。</p>\n<p><img src=\"Tornado的HTTP-Server的服务模型/tornado_000.gif\" alt=\"\"></p>\n","excerpt":"<p>简单介绍web server的一般架构，重点介绍Tornado的HTTP Server架构模型。<br>","more":"</p>\n<p>首先了解一下，网络中的数据是怎么流动的。</p>\n<p><img src=\"Tornado的HTTP-Server的服务模型/tornado_000.gif\" alt=\"\"></p>"},{"title":"Tornado的简历","date":"2016-05-03T16:32:28.000Z","toc":true,"comments":1,"_content":"\nPython家族有祖孙满堂，其中tornado无疑是其最有出息的子孙之一。接下来，我们从tornado的一份档案开始介绍轻量、易扩展的web界大佬。\n<!-- more -->\n\n# Tornado基本信息\n\n## 简历\n- 姓名：tornado\n- 别名：Facebook 的 Web 服务器及其常用工具的开源版本\n- 民族：反正不是中国\n- 性别：不确认\n- 民族：反正不是汉族\n- 职业：Python界轻量级的web服务框架的幕后大老板、独立董事\n- 社会关系：\n    - 父亲：Python\n    - 母亲：Python\n    - 儿子：千千万万Python用户\n- 生卒：21世纪-永远\n- 个人技能： 简单、轻松的为Python的web服务开发者提供帮助，能解决[C10K](http://blog.csdn.net/jysg9/article/details/7901321)问题。tornado和现在主流的web服务器框架相比的区别：它是非阻塞式服务器，速度很快。因为tornado使用了非阻塞的方式和背靠epoll这颗大树，所以tornado每秒可以处理数以千计的链接。\n- 出生背景：开发这个web服务器框架的主要目的是为了处理FriendFeed的实时功能----在FriendFeed的应用里每个活动的用户都会保持一个服务器连接。这就意味着tornado是为了解决同时又多个连接出生的。（FriendFeed主要是方便用户跟踪好友在Facebook和Twitter等多个社交网站上的活动。）\n- 个人特色：采用asynchronous IO的网络模型，异步式IO一种很高效的网络模型；支持WSGI；tornado是异步http框架，天然具备长轮询的优势。\n- 缺点：tornado是单线程的。\n\n## tornado的安装\n*忽略，地球人都知道*\n\n## tornado版hello world - 简单的Web服务\n首先认识一下tornado是如何工作的，这里看看业界语言最经典的test，hello world问题：\n```python\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        greeting = self.get_argument('greeting', 'Hello')\n        self.write(greeting + ', tornado world!')\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n```\n- 启动服务：python hello.py --port=8000\n- 访问服务：\n```shell\n$ curl http://localhost:8000/\nHello, tornado world!\n```\n神奇的hello world就这样出生了，虽然谈不上眉清目秀，但是简单，不用怀胎十月，痛苦分娩。下面我们看看hello.py的剖腹产的视频，看看这哥们的出生过程,以及身体器官的构成。\n\n### tornado版hello.py的剖腹产的视频\n我们一步步分解开看看，这个小伙子是怎么成人的：\n```python\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n```\n- 导入tornado的必备模块，虽然tornado有很多有用的模块，但是这四个是最重要的模块，这就像婴儿的四肢和大脑，为人类必备。\n\n```python\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n```\n- 这是tornado提供的一个很有用的模块(tornado.options)，是从命令行中读取设置。我们这里读取的是监听的http请求的端口，我们看看define的工作方法：\n  - 如果命令行出现define设置的同名参数，则这个参数成为全局的options的一个属性\n  - 如果用户在命令行运行了--help，则打印出define指定的help的信息\n  - 如果用户没有指定相应的数据值，则使用default\n  - type参数是指定port属性的类型，若命令行设置的参数类型校验不通过，则抛出一个异常。\n```python\nclass IndexHandler(tornado.web.RequestHandler):\ndef get(self):\n    greeting = self.get_argument('greeting', 'Hello')\n    self.write(greeting + ', friendly user!')\n```\n- 这个函数是前端请求背后的男人，即tornado前端请求的处理类，这个男人一个月的薪资决定了前端的请求是逛天猫的奢侈品旗舰店呢，还是淘宝小摊。\n- 当处理一个请求时，Tornado将这个类实例化，并调用与HTTP请求方法所对应的方法，此处我们定义了一个get方法，也就是说此函数对tornado的HTTP的get请求作出响应。\n- tornado的RequestHandler类有一系列的非常有用的函数，也是tornado中非常重要的一个类。这里用到的**get_argument**函数，我们从字面意思就知道这个函数是取得字符串中greeting参数的值，缺省为Hello。\n- **write（）**函数是RequestHandler类中一个比较重要的函数，它以一个字符串作为函数的参数，并回写到HTTP响应中。\n- RequestHandler对象的基础：如何从一个传入的HTTP请求中获得信息（使用get_argument和传入到get和post的参数）以及写HTTP响应（使用write方法）在这个小程序中都有显示。\n\n```python\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])\n```\n\n - 这里才是这个小伙子的大脑和手脚，是真正让这个小伙子活蹦乱跳的关键所在，是真正让这个tornado运行起来的语句。首先，我们使用Tornado的options模块来解析命令行。然后我们创建了一个Tornado的**Application**类的实例。**传递给Application类__init__方法的最重要的参数是handlers。它告诉Tornado应该用哪个类来响应请求。**\n - 参数**handlers**是非常重要的，它是由一个元组组成的列表，其中每个元组的第一个元素是一个用于匹配的正则表达式，第二个元素是用于响应这个请求的一个RequesHandler类。\n\n```python\nhttp_server = tornado.httpserver.HTTPServer(app)\nhttp_server.listen(options.port)\ntornado.ioloop.IOLoop.instance().start()\n```\n\n - 从这里开始的代码将会被反复使用：**一旦Application对象被创建，我们可以将其传递给Tornado的HTTPServer对象，然后使用我们在命令行指定的端口进行监听（通过options对象取出。）最后，在程序准备好接收HTTP请求后，我们创建一个Tornado的IOLoop的实例**。\n以上就是Python家族中tornado大佬小时候刚出生的时候，单纯简单的大脑和四肢，但是注意，虽然简单，却五脏俱全。\n\n了解了上面的上的短小精悍的hello world，接下来的一些tornado系列，我将庖丁解牛般的逐个分析tornado的源码，重点解决一些tornado的一些精华类，并比较一些优缺点。\n\n# tornado的源码目录结构\n```shell\n├── tornado\n│   ├── auth.py\n│   ├── autoreload.py\n│   ├── concurrent.py\n│   ├── curl_httpclient.py\n│   ├── escape.py\n│   ├── gen.py\n│   ├── http1connection.py\n│   ├── httpclient.py\n│   ├── httpserver.py\n│   ├── httputil.py\n│   ├── __init__.py\n│   ├── ioloop.py\n│   ├── iostream.py\n│   ├── _locale_data.py\n│   ├── locale.py\n│   ├── locks.py\n│   ├── log.py\n│   ├── netutil.py\n│   ├── options.py\n│   ├── platform\n│   │   ├── asyncio.py\n│   │   ├── auto.py\n│   │   ├── caresresolver.py\n│   │   ├── common.py\n│   │   ├── epoll.py\n│   │   ├── __init__.py\n│   │   ├── interface.py\n│   │   ├── kqueue.py\n│   │   ├── posix.py\n│   │   ├── select.py\n│   │   ├── twisted.py\n│   │   └── windows.py\n│   ├── process.py\n│   ├── queues.py\n│   ├── simple_httpclient.py\n│   ├── speedups.c\n│   ├── stack_context.py\n│   ├── tcpclient.py\n│   ├── tcpserver.py\n│   ├── template.py\n│   ├── test\n│   │   ├── asyncio_test.py\n│   │   ├── auth_test.py\n│   │   ├── concurrent_test.py\n│   │   ├── csv_translations\n│   │   │   └── fr_FR.csv\n│   │   ├── curl_httpclient_test.py\n│   │   ├── escape_test.py\n│   │   ├── gen_test.py\n│   │   ├── gettext_translations\n│   │   │   └── fr_FR\n│   │   │       └── LC_MESSAGES\n│   │   │           ├── tornado_test.mo\n│   │   │           └── tornado_test.po\n│   │   ├── httpclient_test.py\n│   │   ├── httpserver_test.py\n│   │   ├── httputil_test.py\n│   │   ├── import_test.py\n│   │   ├── __init__.py\n│   │   ├── ioloop_test.py\n│   │   ├── iostream_test.py\n│   │   ├── locale_test.py\n│   │   ├── locks_test.py\n│   │   ├── log_test.py\n│   │   ├── __main__.py\n│   │   ├── netutil_test.py\n│   │   ├── options_test.cfg\n│   │   ├── options_test.py\n│   │   ├── process_test.py\n│   │   ├── queues_test.py\n│   │   ├── resolve_test_helper.py\n│   │   ├── runtests.py\n│   │   ├── simple_httpclient_test.py\n│   │   ├── stack_context_test.py\n│   │   ├── static\n│   │   │   ├── dir\n│   │   │   │   └── index.html\n│   │   │   ├── robots.txt\n│   │   │   ├── sample.xml\n│   │   │   ├── sample.xml.bz2\n│   │   │   └── sample.xml.gz\n│   │   ├── static_foo.txt\n│   │   ├── tcpclient_test.py\n│   │   ├── tcpserver_test.py\n│   │   ├── templates\n│   │   │   └── utf8.html\n│   │   ├── template_test.py\n│   │   ├── test.crt\n│   │   ├── testing_test.py\n│   │   ├── test.key\n│   │   ├── twisted_test.py\n│   │   ├── util.py\n│   │   ├── util_test.py\n│   │   ├── websocket_test.py\n│   │   ├── web_test.py\n│   │   └── wsgi_test.py\n│   ├── testing.py\n│   ├── util.py\n│   ├── web.py\n│   ├── websocket.py\n│   └── wsgi.py\n└── tornado_version\n```\n\n# tornado源码剖析链接\n**[tornado源码剖析链接](http://lingyue.github.io/2016/05/04/tornado%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/#more)**\n\n# 链接推荐：\n**[tornado翻译](http://demo.pythoner.com/itt2zh/index.html)**\n**[tornado翻译](http://demo.pythoner.com/itt2zh/index.html)**\n","source":"_posts/Tornado的简历.md","raw":"---\ntitle: Tornado的简历\ndate: 2016-05-04 00:32:28\ntags: Tornado源码分析\ncategories: Tornado系列\ntoc: true\ncomments: true\n---\n\nPython家族有祖孙满堂，其中tornado无疑是其最有出息的子孙之一。接下来，我们从tornado的一份档案开始介绍轻量、易扩展的web界大佬。\n<!-- more -->\n\n# Tornado基本信息\n\n## 简历\n- 姓名：tornado\n- 别名：Facebook 的 Web 服务器及其常用工具的开源版本\n- 民族：反正不是中国\n- 性别：不确认\n- 民族：反正不是汉族\n- 职业：Python界轻量级的web服务框架的幕后大老板、独立董事\n- 社会关系：\n    - 父亲：Python\n    - 母亲：Python\n    - 儿子：千千万万Python用户\n- 生卒：21世纪-永远\n- 个人技能： 简单、轻松的为Python的web服务开发者提供帮助，能解决[C10K](http://blog.csdn.net/jysg9/article/details/7901321)问题。tornado和现在主流的web服务器框架相比的区别：它是非阻塞式服务器，速度很快。因为tornado使用了非阻塞的方式和背靠epoll这颗大树，所以tornado每秒可以处理数以千计的链接。\n- 出生背景：开发这个web服务器框架的主要目的是为了处理FriendFeed的实时功能----在FriendFeed的应用里每个活动的用户都会保持一个服务器连接。这就意味着tornado是为了解决同时又多个连接出生的。（FriendFeed主要是方便用户跟踪好友在Facebook和Twitter等多个社交网站上的活动。）\n- 个人特色：采用asynchronous IO的网络模型，异步式IO一种很高效的网络模型；支持WSGI；tornado是异步http框架，天然具备长轮询的优势。\n- 缺点：tornado是单线程的。\n\n## tornado的安装\n*忽略，地球人都知道*\n\n## tornado版hello world - 简单的Web服务\n首先认识一下tornado是如何工作的，这里看看业界语言最经典的test，hello world问题：\n```python\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        greeting = self.get_argument('greeting', 'Hello')\n        self.write(greeting + ', tornado world!')\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n```\n- 启动服务：python hello.py --port=8000\n- 访问服务：\n```shell\n$ curl http://localhost:8000/\nHello, tornado world!\n```\n神奇的hello world就这样出生了，虽然谈不上眉清目秀，但是简单，不用怀胎十月，痛苦分娩。下面我们看看hello.py的剖腹产的视频，看看这哥们的出生过程,以及身体器官的构成。\n\n### tornado版hello.py的剖腹产的视频\n我们一步步分解开看看，这个小伙子是怎么成人的：\n```python\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n```\n- 导入tornado的必备模块，虽然tornado有很多有用的模块，但是这四个是最重要的模块，这就像婴儿的四肢和大脑，为人类必备。\n\n```python\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n```\n- 这是tornado提供的一个很有用的模块(tornado.options)，是从命令行中读取设置。我们这里读取的是监听的http请求的端口，我们看看define的工作方法：\n  - 如果命令行出现define设置的同名参数，则这个参数成为全局的options的一个属性\n  - 如果用户在命令行运行了--help，则打印出define指定的help的信息\n  - 如果用户没有指定相应的数据值，则使用default\n  - type参数是指定port属性的类型，若命令行设置的参数类型校验不通过，则抛出一个异常。\n```python\nclass IndexHandler(tornado.web.RequestHandler):\ndef get(self):\n    greeting = self.get_argument('greeting', 'Hello')\n    self.write(greeting + ', friendly user!')\n```\n- 这个函数是前端请求背后的男人，即tornado前端请求的处理类，这个男人一个月的薪资决定了前端的请求是逛天猫的奢侈品旗舰店呢，还是淘宝小摊。\n- 当处理一个请求时，Tornado将这个类实例化，并调用与HTTP请求方法所对应的方法，此处我们定义了一个get方法，也就是说此函数对tornado的HTTP的get请求作出响应。\n- tornado的RequestHandler类有一系列的非常有用的函数，也是tornado中非常重要的一个类。这里用到的**get_argument**函数，我们从字面意思就知道这个函数是取得字符串中greeting参数的值，缺省为Hello。\n- **write（）**函数是RequestHandler类中一个比较重要的函数，它以一个字符串作为函数的参数，并回写到HTTP响应中。\n- RequestHandler对象的基础：如何从一个传入的HTTP请求中获得信息（使用get_argument和传入到get和post的参数）以及写HTTP响应（使用write方法）在这个小程序中都有显示。\n\n```python\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])\n```\n\n - 这里才是这个小伙子的大脑和手脚，是真正让这个小伙子活蹦乱跳的关键所在，是真正让这个tornado运行起来的语句。首先，我们使用Tornado的options模块来解析命令行。然后我们创建了一个Tornado的**Application**类的实例。**传递给Application类__init__方法的最重要的参数是handlers。它告诉Tornado应该用哪个类来响应请求。**\n - 参数**handlers**是非常重要的，它是由一个元组组成的列表，其中每个元组的第一个元素是一个用于匹配的正则表达式，第二个元素是用于响应这个请求的一个RequesHandler类。\n\n```python\nhttp_server = tornado.httpserver.HTTPServer(app)\nhttp_server.listen(options.port)\ntornado.ioloop.IOLoop.instance().start()\n```\n\n - 从这里开始的代码将会被反复使用：**一旦Application对象被创建，我们可以将其传递给Tornado的HTTPServer对象，然后使用我们在命令行指定的端口进行监听（通过options对象取出。）最后，在程序准备好接收HTTP请求后，我们创建一个Tornado的IOLoop的实例**。\n以上就是Python家族中tornado大佬小时候刚出生的时候，单纯简单的大脑和四肢，但是注意，虽然简单，却五脏俱全。\n\n了解了上面的上的短小精悍的hello world，接下来的一些tornado系列，我将庖丁解牛般的逐个分析tornado的源码，重点解决一些tornado的一些精华类，并比较一些优缺点。\n\n# tornado的源码目录结构\n```shell\n├── tornado\n│   ├── auth.py\n│   ├── autoreload.py\n│   ├── concurrent.py\n│   ├── curl_httpclient.py\n│   ├── escape.py\n│   ├── gen.py\n│   ├── http1connection.py\n│   ├── httpclient.py\n│   ├── httpserver.py\n│   ├── httputil.py\n│   ├── __init__.py\n│   ├── ioloop.py\n│   ├── iostream.py\n│   ├── _locale_data.py\n│   ├── locale.py\n│   ├── locks.py\n│   ├── log.py\n│   ├── netutil.py\n│   ├── options.py\n│   ├── platform\n│   │   ├── asyncio.py\n│   │   ├── auto.py\n│   │   ├── caresresolver.py\n│   │   ├── common.py\n│   │   ├── epoll.py\n│   │   ├── __init__.py\n│   │   ├── interface.py\n│   │   ├── kqueue.py\n│   │   ├── posix.py\n│   │   ├── select.py\n│   │   ├── twisted.py\n│   │   └── windows.py\n│   ├── process.py\n│   ├── queues.py\n│   ├── simple_httpclient.py\n│   ├── speedups.c\n│   ├── stack_context.py\n│   ├── tcpclient.py\n│   ├── tcpserver.py\n│   ├── template.py\n│   ├── test\n│   │   ├── asyncio_test.py\n│   │   ├── auth_test.py\n│   │   ├── concurrent_test.py\n│   │   ├── csv_translations\n│   │   │   └── fr_FR.csv\n│   │   ├── curl_httpclient_test.py\n│   │   ├── escape_test.py\n│   │   ├── gen_test.py\n│   │   ├── gettext_translations\n│   │   │   └── fr_FR\n│   │   │       └── LC_MESSAGES\n│   │   │           ├── tornado_test.mo\n│   │   │           └── tornado_test.po\n│   │   ├── httpclient_test.py\n│   │   ├── httpserver_test.py\n│   │   ├── httputil_test.py\n│   │   ├── import_test.py\n│   │   ├── __init__.py\n│   │   ├── ioloop_test.py\n│   │   ├── iostream_test.py\n│   │   ├── locale_test.py\n│   │   ├── locks_test.py\n│   │   ├── log_test.py\n│   │   ├── __main__.py\n│   │   ├── netutil_test.py\n│   │   ├── options_test.cfg\n│   │   ├── options_test.py\n│   │   ├── process_test.py\n│   │   ├── queues_test.py\n│   │   ├── resolve_test_helper.py\n│   │   ├── runtests.py\n│   │   ├── simple_httpclient_test.py\n│   │   ├── stack_context_test.py\n│   │   ├── static\n│   │   │   ├── dir\n│   │   │   │   └── index.html\n│   │   │   ├── robots.txt\n│   │   │   ├── sample.xml\n│   │   │   ├── sample.xml.bz2\n│   │   │   └── sample.xml.gz\n│   │   ├── static_foo.txt\n│   │   ├── tcpclient_test.py\n│   │   ├── tcpserver_test.py\n│   │   ├── templates\n│   │   │   └── utf8.html\n│   │   ├── template_test.py\n│   │   ├── test.crt\n│   │   ├── testing_test.py\n│   │   ├── test.key\n│   │   ├── twisted_test.py\n│   │   ├── util.py\n│   │   ├── util_test.py\n│   │   ├── websocket_test.py\n│   │   ├── web_test.py\n│   │   └── wsgi_test.py\n│   ├── testing.py\n│   ├── util.py\n│   ├── web.py\n│   ├── websocket.py\n│   └── wsgi.py\n└── tornado_version\n```\n\n# tornado源码剖析链接\n**[tornado源码剖析链接](http://lingyue.github.io/2016/05/04/tornado%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/#more)**\n\n# 链接推荐：\n**[tornado翻译](http://demo.pythoner.com/itt2zh/index.html)**\n**[tornado翻译](http://demo.pythoner.com/itt2zh/index.html)**\n","slug":"Tornado的简历","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoiroo3000ata02jkit1y59","content":"<p>Python家族有祖孙满堂，其中tornado无疑是其最有出息的子孙之一。接下来，我们从tornado的一份档案开始介绍轻量、易扩展的web界大佬。<br><a id=\"more\"></a></p>\n<h1 id=\"Tornado基本信息\"><a href=\"#Tornado基本信息\" class=\"headerlink\" title=\"Tornado基本信息\"></a>Tornado基本信息</h1><h2 id=\"简历\"><a href=\"#简历\" class=\"headerlink\" title=\"简历\"></a>简历</h2><ul>\n<li>姓名：tornado</li>\n<li>别名：Facebook 的 Web 服务器及其常用工具的开源版本</li>\n<li>民族：反正不是中国</li>\n<li>性别：不确认</li>\n<li>民族：反正不是汉族</li>\n<li>职业：Python界轻量级的web服务框架的幕后大老板、独立董事</li>\n<li>社会关系：<ul>\n<li>父亲：Python</li>\n<li>母亲：Python</li>\n<li>儿子：千千万万Python用户</li>\n</ul>\n</li>\n<li>生卒：21世纪-永远</li>\n<li>个人技能： 简单、轻松的为Python的web服务开发者提供帮助，能解决<a href=\"http://blog.csdn.net/jysg9/article/details/7901321\" target=\"_blank\" rel=\"external\">C10K</a>问题。tornado和现在主流的web服务器框架相比的区别：它是非阻塞式服务器，速度很快。因为tornado使用了非阻塞的方式和背靠epoll这颗大树，所以tornado每秒可以处理数以千计的链接。</li>\n<li>出生背景：开发这个web服务器框架的主要目的是为了处理FriendFeed的实时功能—-在FriendFeed的应用里每个活动的用户都会保持一个服务器连接。这就意味着tornado是为了解决同时又多个连接出生的。（FriendFeed主要是方便用户跟踪好友在Facebook和Twitter等多个社交网站上的活动。）</li>\n<li>个人特色：采用asynchronous IO的网络模型，异步式IO一种很高效的网络模型；支持WSGI；tornado是异步http框架，天然具备长轮询的优势。</li>\n<li>缺点：tornado是单线程的。</li>\n</ul>\n<h2 id=\"tornado的安装\"><a href=\"#tornado的安装\" class=\"headerlink\" title=\"tornado的安装\"></a>tornado的安装</h2><p><em>忽略，地球人都知道</em></p>\n<h2 id=\"tornado版hello-world-简单的Web服务\"><a href=\"#tornado版hello-world-简单的Web服务\" class=\"headerlink\" title=\"tornado版hello world - 简单的Web服务\"></a>tornado版hello world - 简单的Web服务</h2><p>首先认识一下tornado是如何工作的，这里看看业界语言最经典的test，hello world问题：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> tornado.httpserver</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.ioloop</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.options</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.web</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> tornado.options <span class=\"keyword\">import</span> define, options</div><div class=\"line\">define(<span class=\"string\">\"port\"</span>, default=<span class=\"number\">8000</span>, help=<span class=\"string\">\"run on the given port\"</span>, type=int)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexHandler</span><span class=\"params\">(tornado.web.RequestHandler)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        greeting = self.get_argument(<span class=\"string\">'greeting'</span>, <span class=\"string\">'Hello'</span>)</div><div class=\"line\">        self.write(greeting + <span class=\"string\">', tornado world!'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    tornado.options.parse_command_line()</div><div class=\"line\">    app = tornado.web.Application(handlers=[(<span class=\"string\">r\"/\"</span>, IndexHandler)])</div><div class=\"line\">    http_server = tornado.httpserver.HTTPServer(app)</div><div class=\"line\">    http_server.listen(options.port)</div><div class=\"line\">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>\n<ul>\n<li>启动服务：python hello.py –port=8000</li>\n<li>访问服务：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl http://localhost:8000/</div><div class=\"line\">Hello, tornado world!</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>神奇的hello world就这样出生了，虽然谈不上眉清目秀，但是简单，不用怀胎十月，痛苦分娩。下面我们看看hello.py的剖腹产的视频，看看这哥们的出生过程,以及身体器官的构成。</p>\n<h3 id=\"tornado版hello-py的剖腹产的视频\"><a href=\"#tornado版hello-py的剖腹产的视频\" class=\"headerlink\" title=\"tornado版hello.py的剖腹产的视频\"></a>tornado版hello.py的剖腹产的视频</h3><p>我们一步步分解开看看，这个小伙子是怎么成人的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> tornado.httpserver</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.ioloop</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.options</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.web</div></pre></td></tr></table></figure></p>\n<ul>\n<li>导入tornado的必备模块，虽然tornado有很多有用的模块，但是这四个是最重要的模块，这就像婴儿的四肢和大脑，为人类必备。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> tornado.options <span class=\"keyword\">import</span> define, options</div><div class=\"line\">define(<span class=\"string\">\"port\"</span>, default=<span class=\"number\">8000</span>, help=<span class=\"string\">\"run on the given port\"</span>, type=int)</div></pre></td></tr></table></figure>\n<ul>\n<li><p>这是tornado提供的一个很有用的模块(tornado.options)，是从命令行中读取设置。我们这里读取的是监听的http请求的端口，我们看看define的工作方法：</p>\n<ul>\n<li>如果命令行出现define设置的同名参数，则这个参数成为全局的options的一个属性</li>\n<li>如果用户在命令行运行了–help，则打印出define指定的help的信息</li>\n<li>如果用户没有指定相应的数据值，则使用default</li>\n<li>type参数是指定port属性的类型，若命令行设置的参数类型校验不通过，则抛出一个异常。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexHandler</span><span class=\"params\">(tornado.web.RequestHandler)</span>:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">    greeting = self.get_argument(<span class=\"string\">'greeting'</span>, <span class=\"string\">'Hello'</span>)</div><div class=\"line\">    self.write(greeting + <span class=\"string\">', friendly user!'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>这个函数是前端请求背后的男人，即tornado前端请求的处理类，这个男人一个月的薪资决定了前端的请求是逛天猫的奢侈品旗舰店呢，还是淘宝小摊。</p>\n</li>\n<li>当处理一个请求时，Tornado将这个类实例化，并调用与HTTP请求方法所对应的方法，此处我们定义了一个get方法，也就是说此函数对tornado的HTTP的get请求作出响应。</li>\n<li>tornado的RequestHandler类有一系列的非常有用的函数，也是tornado中非常重要的一个类。这里用到的<strong>get_argument</strong>函数，我们从字面意思就知道这个函数是取得字符串中greeting参数的值，缺省为Hello。</li>\n<li><strong>write（）</strong>函数是RequestHandler类中一个比较重要的函数，它以一个字符串作为函数的参数，并回写到HTTP响应中。</li>\n<li>RequestHandler对象的基础：如何从一个传入的HTTP请求中获得信息（使用get_argument和传入到get和post的参数）以及写HTTP响应（使用write方法）在这个小程序中都有显示。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    tornado.options.parse_command_line()</div><div class=\"line\">    app = tornado.web.Application(handlers=[(<span class=\"string\">r\"/\"</span>, IndexHandler)])</div></pre></td></tr></table></figure>\n<ul>\n<li>这里才是这个小伙子的大脑和手脚，是真正让这个小伙子活蹦乱跳的关键所在，是真正让这个tornado运行起来的语句。首先，我们使用Tornado的options模块来解析命令行。然后我们创建了一个Tornado的<strong>Application</strong>类的实例。<strong>传递给Application类<strong>init</strong>方法的最重要的参数是handlers。它告诉Tornado应该用哪个类来响应请求。</strong></li>\n<li>参数<strong>handlers</strong>是非常重要的，它是由一个元组组成的列表，其中每个元组的第一个元素是一个用于匹配的正则表达式，第二个元素是用于响应这个请求的一个RequesHandler类。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">http_server = tornado.httpserver.HTTPServer(app)</div><div class=\"line\">http_server.listen(options.port)</div><div class=\"line\">tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure>\n<ul>\n<li>从这里开始的代码将会被反复使用：<strong>一旦Application对象被创建，我们可以将其传递给Tornado的HTTPServer对象，然后使用我们在命令行指定的端口进行监听（通过options对象取出。）最后，在程序准备好接收HTTP请求后，我们创建一个Tornado的IOLoop的实例</strong>。<br>以上就是Python家族中tornado大佬小时候刚出生的时候，单纯简单的大脑和四肢，但是注意，虽然简单，却五脏俱全。</li>\n</ul>\n<p>了解了上面的上的短小精悍的hello world，接下来的一些tornado系列，我将庖丁解牛般的逐个分析tornado的源码，重点解决一些tornado的一些精华类，并比较一些优缺点。</p>\n<h1 id=\"tornado的源码目录结构\"><a href=\"#tornado的源码目录结构\" class=\"headerlink\" title=\"tornado的源码目录结构\"></a>tornado的源码目录结构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── tornado</div><div class=\"line\">│   ├── auth.py</div><div class=\"line\">│   ├── autoreload.py</div><div class=\"line\">│   ├── concurrent.py</div><div class=\"line\">│   ├── curl_httpclient.py</div><div class=\"line\">│   ├── escape.py</div><div class=\"line\">│   ├── gen.py</div><div class=\"line\">│   ├── http1connection.py</div><div class=\"line\">│   ├── httpclient.py</div><div class=\"line\">│   ├── httpserver.py</div><div class=\"line\">│   ├── httputil.py</div><div class=\"line\">│   ├── __init__.py</div><div class=\"line\">│   ├── ioloop.py</div><div class=\"line\">│   ├── iostream.py</div><div class=\"line\">│   ├── _locale_data.py</div><div class=\"line\">│   ├── locale.py</div><div class=\"line\">│   ├── locks.py</div><div class=\"line\">│   ├── log.py</div><div class=\"line\">│   ├── netutil.py</div><div class=\"line\">│   ├── options.py</div><div class=\"line\">│   ├── platform</div><div class=\"line\">│   │   ├── asyncio.py</div><div class=\"line\">│   │   ├── auto.py</div><div class=\"line\">│   │   ├── caresresolver.py</div><div class=\"line\">│   │   ├── common.py</div><div class=\"line\">│   │   ├── epoll.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── interface.py</div><div class=\"line\">│   │   ├── kqueue.py</div><div class=\"line\">│   │   ├── posix.py</div><div class=\"line\">│   │   ├── select.py</div><div class=\"line\">│   │   ├── twisted.py</div><div class=\"line\">│   │   └── windows.py</div><div class=\"line\">│   ├── process.py</div><div class=\"line\">│   ├── queues.py</div><div class=\"line\">│   ├── simple_httpclient.py</div><div class=\"line\">│   ├── speedups.c</div><div class=\"line\">│   ├── stack_context.py</div><div class=\"line\">│   ├── tcpclient.py</div><div class=\"line\">│   ├── tcpserver.py</div><div class=\"line\">│   ├── template.py</div><div class=\"line\">│   ├── test</div><div class=\"line\">│   │   ├── asyncio_test.py</div><div class=\"line\">│   │   ├── auth_test.py</div><div class=\"line\">│   │   ├── concurrent_test.py</div><div class=\"line\">│   │   ├── csv_translations</div><div class=\"line\">│   │   │   └── fr_FR.csv</div><div class=\"line\">│   │   ├── curl_httpclient_test.py</div><div class=\"line\">│   │   ├── escape_test.py</div><div class=\"line\">│   │   ├── gen_test.py</div><div class=\"line\">│   │   ├── gettext_translations</div><div class=\"line\">│   │   │   └── fr_FR</div><div class=\"line\">│   │   │       └── LC_MESSAGES</div><div class=\"line\">│   │   │           ├── tornado_test.mo</div><div class=\"line\">│   │   │           └── tornado_test.po</div><div class=\"line\">│   │   ├── httpclient_test.py</div><div class=\"line\">│   │   ├── httpserver_test.py</div><div class=\"line\">│   │   ├── httputil_test.py</div><div class=\"line\">│   │   ├── import_test.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── ioloop_test.py</div><div class=\"line\">│   │   ├── iostream_test.py</div><div class=\"line\">│   │   ├── locale_test.py</div><div class=\"line\">│   │   ├── locks_test.py</div><div class=\"line\">│   │   ├── log_test.py</div><div class=\"line\">│   │   ├── __main__.py</div><div class=\"line\">│   │   ├── netutil_test.py</div><div class=\"line\">│   │   ├── options_test.cfg</div><div class=\"line\">│   │   ├── options_test.py</div><div class=\"line\">│   │   ├── process_test.py</div><div class=\"line\">│   │   ├── queues_test.py</div><div class=\"line\">│   │   ├── resolve_test_helper.py</div><div class=\"line\">│   │   ├── runtests.py</div><div class=\"line\">│   │   ├── simple_httpclient_test.py</div><div class=\"line\">│   │   ├── stack_context_test.py</div><div class=\"line\">│   │   ├── static</div><div class=\"line\">│   │   │   ├── dir</div><div class=\"line\">│   │   │   │   └── index.html</div><div class=\"line\">│   │   │   ├── robots.txt</div><div class=\"line\">│   │   │   ├── sample.xml</div><div class=\"line\">│   │   │   ├── sample.xml.bz2</div><div class=\"line\">│   │   │   └── sample.xml.gz</div><div class=\"line\">│   │   ├── static_foo.txt</div><div class=\"line\">│   │   ├── tcpclient_test.py</div><div class=\"line\">│   │   ├── tcpserver_test.py</div><div class=\"line\">│   │   ├── templates</div><div class=\"line\">│   │   │   └── utf8.html</div><div class=\"line\">│   │   ├── template_test.py</div><div class=\"line\">│   │   ├── test.crt</div><div class=\"line\">│   │   ├── testing_test.py</div><div class=\"line\">│   │   ├── test.key</div><div class=\"line\">│   │   ├── twisted_test.py</div><div class=\"line\">│   │   ├── util.py</div><div class=\"line\">│   │   ├── util_test.py</div><div class=\"line\">│   │   ├── websocket_test.py</div><div class=\"line\">│   │   ├── web_test.py</div><div class=\"line\">│   │   └── wsgi_test.py</div><div class=\"line\">│   ├── testing.py</div><div class=\"line\">│   ├── util.py</div><div class=\"line\">│   ├── web.py</div><div class=\"line\">│   ├── websocket.py</div><div class=\"line\">│   └── wsgi.py</div><div class=\"line\">└── tornado_version</div></pre></td></tr></table></figure>\n<h1 id=\"tornado源码剖析链接\"><a href=\"#tornado源码剖析链接\" class=\"headerlink\" title=\"tornado源码剖析链接\"></a>tornado源码剖析链接</h1><p><strong><a href=\"http://lingyue.github.io/2016/05/04/tornado%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/#more\" target=\"_blank\" rel=\"external\">tornado源码剖析链接</a></strong></p>\n<h1 id=\"链接推荐：\"><a href=\"#链接推荐：\" class=\"headerlink\" title=\"链接推荐：\"></a>链接推荐：</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado翻译</a></strong><br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado翻译</a></strong></p>\n","excerpt":"<p>Python家族有祖孙满堂，其中tornado无疑是其最有出息的子孙之一。接下来，我们从tornado的一份档案开始介绍轻量、易扩展的web界大佬。<br>","more":"</p>\n<h1 id=\"Tornado基本信息\"><a href=\"#Tornado基本信息\" class=\"headerlink\" title=\"Tornado基本信息\"></a>Tornado基本信息</h1><h2 id=\"简历\"><a href=\"#简历\" class=\"headerlink\" title=\"简历\"></a>简历</h2><ul>\n<li>姓名：tornado</li>\n<li>别名：Facebook 的 Web 服务器及其常用工具的开源版本</li>\n<li>民族：反正不是中国</li>\n<li>性别：不确认</li>\n<li>民族：反正不是汉族</li>\n<li>职业：Python界轻量级的web服务框架的幕后大老板、独立董事</li>\n<li>社会关系：<ul>\n<li>父亲：Python</li>\n<li>母亲：Python</li>\n<li>儿子：千千万万Python用户</li>\n</ul>\n</li>\n<li>生卒：21世纪-永远</li>\n<li>个人技能： 简单、轻松的为Python的web服务开发者提供帮助，能解决<a href=\"http://blog.csdn.net/jysg9/article/details/7901321\">C10K</a>问题。tornado和现在主流的web服务器框架相比的区别：它是非阻塞式服务器，速度很快。因为tornado使用了非阻塞的方式和背靠epoll这颗大树，所以tornado每秒可以处理数以千计的链接。</li>\n<li>出生背景：开发这个web服务器框架的主要目的是为了处理FriendFeed的实时功能—-在FriendFeed的应用里每个活动的用户都会保持一个服务器连接。这就意味着tornado是为了解决同时又多个连接出生的。（FriendFeed主要是方便用户跟踪好友在Facebook和Twitter等多个社交网站上的活动。）</li>\n<li>个人特色：采用asynchronous IO的网络模型，异步式IO一种很高效的网络模型；支持WSGI；tornado是异步http框架，天然具备长轮询的优势。</li>\n<li>缺点：tornado是单线程的。</li>\n</ul>\n<h2 id=\"tornado的安装\"><a href=\"#tornado的安装\" class=\"headerlink\" title=\"tornado的安装\"></a>tornado的安装</h2><p><em>忽略，地球人都知道</em></p>\n<h2 id=\"tornado版hello-world-简单的Web服务\"><a href=\"#tornado版hello-world-简单的Web服务\" class=\"headerlink\" title=\"tornado版hello world - 简单的Web服务\"></a>tornado版hello world - 简单的Web服务</h2><p>首先认识一下tornado是如何工作的，这里看看业界语言最经典的test，hello world问题：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> tornado.httpserver</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.ioloop</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.options</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.web</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> tornado.options <span class=\"keyword\">import</span> define, options</div><div class=\"line\">define(<span class=\"string\">\"port\"</span>, default=<span class=\"number\">8000</span>, help=<span class=\"string\">\"run on the given port\"</span>, type=int)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexHandler</span><span class=\"params\">(tornado.web.RequestHandler)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        greeting = self.get_argument(<span class=\"string\">'greeting'</span>, <span class=\"string\">'Hello'</span>)</div><div class=\"line\">        self.write(greeting + <span class=\"string\">', tornado world!'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    tornado.options.parse_command_line()</div><div class=\"line\">    app = tornado.web.Application(handlers=[(<span class=\"string\">r\"/\"</span>, IndexHandler)])</div><div class=\"line\">    http_server = tornado.httpserver.HTTPServer(app)</div><div class=\"line\">    http_server.listen(options.port)</div><div class=\"line\">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>\n<ul>\n<li>启动服务：python hello.py –port=8000</li>\n<li>访问服务：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl http://localhost:8000/</div><div class=\"line\">Hello, tornado world!</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>神奇的hello world就这样出生了，虽然谈不上眉清目秀，但是简单，不用怀胎十月，痛苦分娩。下面我们看看hello.py的剖腹产的视频，看看这哥们的出生过程,以及身体器官的构成。</p>\n<h3 id=\"tornado版hello-py的剖腹产的视频\"><a href=\"#tornado版hello-py的剖腹产的视频\" class=\"headerlink\" title=\"tornado版hello.py的剖腹产的视频\"></a>tornado版hello.py的剖腹产的视频</h3><p>我们一步步分解开看看，这个小伙子是怎么成人的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> tornado.httpserver</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.ioloop</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.options</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.web</div></pre></td></tr></table></figure></p>\n<ul>\n<li>导入tornado的必备模块，虽然tornado有很多有用的模块，但是这四个是最重要的模块，这就像婴儿的四肢和大脑，为人类必备。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> tornado.options <span class=\"keyword\">import</span> define, options</div><div class=\"line\">define(<span class=\"string\">\"port\"</span>, default=<span class=\"number\">8000</span>, help=<span class=\"string\">\"run on the given port\"</span>, type=int)</div></pre></td></tr></table></figure>\n<ul>\n<li><p>这是tornado提供的一个很有用的模块(tornado.options)，是从命令行中读取设置。我们这里读取的是监听的http请求的端口，我们看看define的工作方法：</p>\n<ul>\n<li>如果命令行出现define设置的同名参数，则这个参数成为全局的options的一个属性</li>\n<li>如果用户在命令行运行了–help，则打印出define指定的help的信息</li>\n<li>如果用户没有指定相应的数据值，则使用default</li>\n<li>type参数是指定port属性的类型，若命令行设置的参数类型校验不通过，则抛出一个异常。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexHandler</span><span class=\"params\">(tornado.web.RequestHandler)</span>:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">    greeting = self.get_argument(<span class=\"string\">'greeting'</span>, <span class=\"string\">'Hello'</span>)</div><div class=\"line\">    self.write(greeting + <span class=\"string\">', friendly user!'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>这个函数是前端请求背后的男人，即tornado前端请求的处理类，这个男人一个月的薪资决定了前端的请求是逛天猫的奢侈品旗舰店呢，还是淘宝小摊。</p>\n</li>\n<li>当处理一个请求时，Tornado将这个类实例化，并调用与HTTP请求方法所对应的方法，此处我们定义了一个get方法，也就是说此函数对tornado的HTTP的get请求作出响应。</li>\n<li>tornado的RequestHandler类有一系列的非常有用的函数，也是tornado中非常重要的一个类。这里用到的<strong>get_argument</strong>函数，我们从字面意思就知道这个函数是取得字符串中greeting参数的值，缺省为Hello。</li>\n<li><strong>write（）</strong>函数是RequestHandler类中一个比较重要的函数，它以一个字符串作为函数的参数，并回写到HTTP响应中。</li>\n<li>RequestHandler对象的基础：如何从一个传入的HTTP请求中获得信息（使用get_argument和传入到get和post的参数）以及写HTTP响应（使用write方法）在这个小程序中都有显示。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    tornado.options.parse_command_line()</div><div class=\"line\">    app = tornado.web.Application(handlers=[(<span class=\"string\">r\"/\"</span>, IndexHandler)])</div></pre></td></tr></table></figure>\n<ul>\n<li>这里才是这个小伙子的大脑和手脚，是真正让这个小伙子活蹦乱跳的关键所在，是真正让这个tornado运行起来的语句。首先，我们使用Tornado的options模块来解析命令行。然后我们创建了一个Tornado的<strong>Application</strong>类的实例。<strong>传递给Application类<strong>init</strong>方法的最重要的参数是handlers。它告诉Tornado应该用哪个类来响应请求。</strong></li>\n<li>参数<strong>handlers</strong>是非常重要的，它是由一个元组组成的列表，其中每个元组的第一个元素是一个用于匹配的正则表达式，第二个元素是用于响应这个请求的一个RequesHandler类。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">http_server = tornado.httpserver.HTTPServer(app)</div><div class=\"line\">http_server.listen(options.port)</div><div class=\"line\">tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure>\n<ul>\n<li>从这里开始的代码将会被反复使用：<strong>一旦Application对象被创建，我们可以将其传递给Tornado的HTTPServer对象，然后使用我们在命令行指定的端口进行监听（通过options对象取出。）最后，在程序准备好接收HTTP请求后，我们创建一个Tornado的IOLoop的实例</strong>。<br>以上就是Python家族中tornado大佬小时候刚出生的时候，单纯简单的大脑和四肢，但是注意，虽然简单，却五脏俱全。</li>\n</ul>\n<p>了解了上面的上的短小精悍的hello world，接下来的一些tornado系列，我将庖丁解牛般的逐个分析tornado的源码，重点解决一些tornado的一些精华类，并比较一些优缺点。</p>\n<h1 id=\"tornado的源码目录结构\"><a href=\"#tornado的源码目录结构\" class=\"headerlink\" title=\"tornado的源码目录结构\"></a>tornado的源码目录结构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── tornado</div><div class=\"line\">│   ├── auth.py</div><div class=\"line\">│   ├── autoreload.py</div><div class=\"line\">│   ├── concurrent.py</div><div class=\"line\">│   ├── curl_httpclient.py</div><div class=\"line\">│   ├── escape.py</div><div class=\"line\">│   ├── gen.py</div><div class=\"line\">│   ├── http1connection.py</div><div class=\"line\">│   ├── httpclient.py</div><div class=\"line\">│   ├── httpserver.py</div><div class=\"line\">│   ├── httputil.py</div><div class=\"line\">│   ├── __init__.py</div><div class=\"line\">│   ├── ioloop.py</div><div class=\"line\">│   ├── iostream.py</div><div class=\"line\">│   ├── _locale_data.py</div><div class=\"line\">│   ├── locale.py</div><div class=\"line\">│   ├── locks.py</div><div class=\"line\">│   ├── log.py</div><div class=\"line\">│   ├── netutil.py</div><div class=\"line\">│   ├── options.py</div><div class=\"line\">│   ├── platform</div><div class=\"line\">│   │   ├── asyncio.py</div><div class=\"line\">│   │   ├── auto.py</div><div class=\"line\">│   │   ├── caresresolver.py</div><div class=\"line\">│   │   ├── common.py</div><div class=\"line\">│   │   ├── epoll.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── interface.py</div><div class=\"line\">│   │   ├── kqueue.py</div><div class=\"line\">│   │   ├── posix.py</div><div class=\"line\">│   │   ├── select.py</div><div class=\"line\">│   │   ├── twisted.py</div><div class=\"line\">│   │   └── windows.py</div><div class=\"line\">│   ├── process.py</div><div class=\"line\">│   ├── queues.py</div><div class=\"line\">│   ├── simple_httpclient.py</div><div class=\"line\">│   ├── speedups.c</div><div class=\"line\">│   ├── stack_context.py</div><div class=\"line\">│   ├── tcpclient.py</div><div class=\"line\">│   ├── tcpserver.py</div><div class=\"line\">│   ├── template.py</div><div class=\"line\">│   ├── test</div><div class=\"line\">│   │   ├── asyncio_test.py</div><div class=\"line\">│   │   ├── auth_test.py</div><div class=\"line\">│   │   ├── concurrent_test.py</div><div class=\"line\">│   │   ├── csv_translations</div><div class=\"line\">│   │   │   └── fr_FR.csv</div><div class=\"line\">│   │   ├── curl_httpclient_test.py</div><div class=\"line\">│   │   ├── escape_test.py</div><div class=\"line\">│   │   ├── gen_test.py</div><div class=\"line\">│   │   ├── gettext_translations</div><div class=\"line\">│   │   │   └── fr_FR</div><div class=\"line\">│   │   │       └── LC_MESSAGES</div><div class=\"line\">│   │   │           ├── tornado_test.mo</div><div class=\"line\">│   │   │           └── tornado_test.po</div><div class=\"line\">│   │   ├── httpclient_test.py</div><div class=\"line\">│   │   ├── httpserver_test.py</div><div class=\"line\">│   │   ├── httputil_test.py</div><div class=\"line\">│   │   ├── import_test.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── ioloop_test.py</div><div class=\"line\">│   │   ├── iostream_test.py</div><div class=\"line\">│   │   ├── locale_test.py</div><div class=\"line\">│   │   ├── locks_test.py</div><div class=\"line\">│   │   ├── log_test.py</div><div class=\"line\">│   │   ├── __main__.py</div><div class=\"line\">│   │   ├── netutil_test.py</div><div class=\"line\">│   │   ├── options_test.cfg</div><div class=\"line\">│   │   ├── options_test.py</div><div class=\"line\">│   │   ├── process_test.py</div><div class=\"line\">│   │   ├── queues_test.py</div><div class=\"line\">│   │   ├── resolve_test_helper.py</div><div class=\"line\">│   │   ├── runtests.py</div><div class=\"line\">│   │   ├── simple_httpclient_test.py</div><div class=\"line\">│   │   ├── stack_context_test.py</div><div class=\"line\">│   │   ├── static</div><div class=\"line\">│   │   │   ├── dir</div><div class=\"line\">│   │   │   │   └── index.html</div><div class=\"line\">│   │   │   ├── robots.txt</div><div class=\"line\">│   │   │   ├── sample.xml</div><div class=\"line\">│   │   │   ├── sample.xml.bz2</div><div class=\"line\">│   │   │   └── sample.xml.gz</div><div class=\"line\">│   │   ├── static_foo.txt</div><div class=\"line\">│   │   ├── tcpclient_test.py</div><div class=\"line\">│   │   ├── tcpserver_test.py</div><div class=\"line\">│   │   ├── templates</div><div class=\"line\">│   │   │   └── utf8.html</div><div class=\"line\">│   │   ├── template_test.py</div><div class=\"line\">│   │   ├── test.crt</div><div class=\"line\">│   │   ├── testing_test.py</div><div class=\"line\">│   │   ├── test.key</div><div class=\"line\">│   │   ├── twisted_test.py</div><div class=\"line\">│   │   ├── util.py</div><div class=\"line\">│   │   ├── util_test.py</div><div class=\"line\">│   │   ├── websocket_test.py</div><div class=\"line\">│   │   ├── web_test.py</div><div class=\"line\">│   │   └── wsgi_test.py</div><div class=\"line\">│   ├── testing.py</div><div class=\"line\">│   ├── util.py</div><div class=\"line\">│   ├── web.py</div><div class=\"line\">│   ├── websocket.py</div><div class=\"line\">│   └── wsgi.py</div><div class=\"line\">└── tornado_version</div></pre></td></tr></table></figure>\n<h1 id=\"tornado源码剖析链接\"><a href=\"#tornado源码剖析链接\" class=\"headerlink\" title=\"tornado源码剖析链接\"></a>tornado源码剖析链接</h1><p><strong><a href=\"http://lingyue.github.io/2016/05/04/tornado%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/#more\">tornado源码剖析链接</a></strong></p>\n<h1 id=\"链接推荐：\"><a href=\"#链接推荐：\" class=\"headerlink\" title=\"链接推荐：\"></a>链接推荐：</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado翻译</a></strong><br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado翻译</a></strong></p>"},{"title":"Tornado.web源码分析","date":"2016-05-17T16:01:02.000Z","toc":true,"comments":1,"_content":"\ntorndao.web是Handler类的集合，tornado的web框架是在web.py中实现的，tornado.web模块中提供了两个重量级的类，Application和RequestHandler（本质是http请求处理的封装）类。Application类主要是做路由转发，torndao使用web.Application做URI，然后在通过RequestHandler类去处理这些请求。\n\n<!-- more -->\n# torndao.web.Application\nApplication官网解释说它是一系列网络请求的Handler，这些Handler的组合撑起了一个web网站。\n\ntorndao.web.Application提供的函数：\n![torndao.web.Application提供的函数](tornado-web源码分析/torndao_001.PNG)\n\n## Application类的方法和工作原理简单介绍\n\n - 构造函数：接受handlers参数，也是最终匹配主机的路径路由列表；设定transform列表；设定静态文件的路由；添加(\".*$\")的路由列表。\n - listen方法：创建server，并把自身，self作为回调函数\n - accept到新连接后主动调（__call__），其根据请求，把该请求转发到相应的路由路径表中具体的handler上去处理请求\n\n## **def __init__()**\n```python\ndef __init__(self, handlers=None, default_host=\"\", transforms=None,\n        **settings):\n```\n参数解析：\n\n - **handlers：**类型为list，一系列的URI的处理器列表，为对应的每个URI与handlers处理器的map，类似[(URI,handler_1),(URI_01,handler_1),.....]，当然还可以带一系列参数，比如static_path等:\n```python\napplication = web.Application([\n(r\"/static/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n])\n```\n - **default_host:**\n - **transforms：**分块、压缩等\n - **settings：**各种设置，如static、gzip、cookie_secret等等，是一个dict\n\n\nApplication类的初始化函数，将传入的处理器列表调用add_handlers函数注册，再有一些分块、压缩、UI、静态文件处理器的初始化，并调用add_handlers 方法，完成URI和处理器的映射关系，这个函数我们下面将会详细的介绍这个函数。\n\n## **def listen()**\n```python\ndef listen(self, port, address=\"\", **kwargs):\n```\n这个函数只是对HTTPServer的listen函数的一个封装，返回一个HTTPServer实例。在HTTPServer类中将仔细分析该函数。\n\n\n### 源码\n```python\ndef listen(self, port, address=\"\", **kwargs):\n    from tornado.httpserver import HTTPServer\n    #简单的封装\n    server = HTTPServer(self, **kwargs) #当连接到来后，HTTPServer负责调用\n    server.listen(port, address)\n    return server\n```\n**这里我们可以认为，在特定的地址-端口上创建并监听socket，并注册socket的可读事件到自身的call（前后双下划线，下同）方法上，即每逢一个新连接到来后，call将被调用。**\n\n## **def add_handlers()**\n```python\ndef add_handlers(self, host_pattern, host_handlers)\n```\n参数解析：\n\n - **host_pattern：**主机名正则\n - **host_handlers:**路由表和handler，即路径路由列表。如：\n```python\napplication = web.Application([\n    (r\"/static/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n])\n```\n添加路由与handlers的到处理器列表中，完成URI和处理器的映射。\n\n### 源码\n\n```python\ndef add_handlers(self, host_pattern, host_handlers):\n    #若无正则表达式的结束符，则添加\n    if not host_pattern.endswith(\"$\"):\n        host_pattern += \"$\"\n    handlers = []\n\n    #self.handlesr是一个主机和路由列表，每个元素是一个tuple，\n    #将主机名和路径路由列表合成tuple，添加到self.handlers中，供_get_host_handler()检索，\n    #可以根据主机名找到路径路由列表\n    if self.handlers and self.handlers[-1][0].pattern == '.*$': #由于'.*$'的特殊性，必须放在列表的最后\n        self.handlers.insert(-1, (re.compile(host_pattern), handlers))\n    else:\n        self.handlers.append((re.compile(host_pattern), handlers))\n\n    for spec in host_handlers:\n        if isinstance(spec, (tuple, list)):\n            assert len(spec) in (2, 3, 4)\n            spec = URLSpec(*spec)\n        #添加到处理器列表中\n        handlers.append(spec)\n        if spec.name:\n            if spec.name in self.named_handlers:\n                app_log.warning(\n                    \"Multiple handlers named %s; replacing previous value\",\n                    spec.name)\n            self.named_handlers[spec.name] = spec\n```\n我们看这个函数函数还是很简单的，就是把URI和handler添加到处理器列表中，完成映射map，完事。\n\n## **def add_transform()**\n```python\ndef add_transform(self, transform_class):\n```\n\n这个函数及其简单，完成的任务就是添加输出过滤器，例如gzip，chunk，会在输出的时候调用其。\n\n## def __call__()(备注：前后双下划线，下同)\n\n这个函数可以说是Application的主要核心方法之一，我们详细的来看看。\n\n```python\n    def __call__(self, request):\n        #传统的HTTP服务器接口\n        dispatcher = _RequestDispatcher(self, None)#传进去的是self参数\n        dispatcher.set_request(request)\n        return dispatcher.execute()\n```\n参数解析：\n\n - **request:**HttpRequest对象对象，定义在httputil中。\n\n这个函数实现的挺有技巧性，实现了一个__call__函数，这个函数有什么作用呢，就是类Application可以当做函数来调用了。\nApplication类可以这么理解它自身的一些函数的关系：\n在特定的地址-端口上创建并监听该socket，并且注册了该sockt的可读事件到自身的__call__函数。\n\n**__call__函数的好处**\n\n - Application类的对象可以当做函数来调用。\n - 当类对象当做函数来调用的时候，__call__会自动被调用，并且会保留对象的上下文。\n\n我们在tornado版的hello world前面的举例中，会发现当时是这么调用的：\n```python\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\nhttp_server = tornado.httpserver.HTTPServer(application)\nhttp_server.listen(options.port)\ntornado.ioloop.IOLoop.current().start()\n```\n\n上述举例可以看出，**我们将Application实例传给了HTTPServer，当监听到（listen()函数）请求的，由于Application类实现了__call__函数,所以当请求到来后，通过HTTPServer来调用Application实例，__call__方法中完成具体的URI转发工作，即，__call__函数会遍历Application的handlers列表，匹配到相应的URL的handler后，通过handler._execute进行相应处理；如果没有匹配的URL，则会调用ErrorHandler。**\n\n由上面的__call__函数我们看到，此方法主要是调用_RequestDispatcher来完成请求的处理，那么下面我们具体看看请求到来后的处理过程：\n\n### **Application对request的处理过程**\n```python\ndef _has_stream_request_body(cls):\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    return getattr(cls, '_stream_request_body', False)\n\n#Application类的方法\n#Application类的构造函数有这么一段代码：\n\"\"\"\nif handlers:\n    self.add_handlers(\".*$\", handlers)#host_pattern传入\".*$\",表示无限次的匹配，即默认情况下，所有的主机名都会被匹配\n\"\"\"\n#所以显然，默认情况下，任何host都会被匹配的，\ndef _get_host_handlers(self, request):\n    host = split_host_and_port(request.host.lower())[0]\n    matches = []\n    for pattern, handlers in self.handlers:\n        if pattern.match(host):\n            matches.extend(handlers)\n    if not matches and \"X-Real-Ip\" not in request.headers:\n        for pattern, handlers in self.handlers:\n            if pattern.match(self.default_host):\n                matches.extend(handlers)\n    return matches or None\n\nclass _RequestDispatcher(httputil.HTTPMessageDelegate):\n    def __init__(self, application, connection):\n        self.application = application\n        self.connection = connection\n        self.request = None\n        self.chunks = []\n        self.handler_class = None\n        self.handler_kwargs = None\n        self.path_args = []\n        self.path_kwargs = {}\n\n    .....\n\n    def set_request(self, request):\n        self.request = request\n        self._find_handler()\n        self.stream_request_body = _has_stream_request_body(self.handler_class)\n\n    def _find_handler(self):\n        app = self.application\n        #该函数将得到该host对应的路径路由列表，也就是那个映射map，\n        #也就是说返回的列表就是传递给构造Application的那个tuple列表\n        handlers = app._get_host_handlers(self.request)\n        if not handlers:\n            self.handler_class = RedirectHandler\n            self.handler_kwargs = dict(url=\"%s://%s/\"\n                                       % (self.request.protocol,\n                                          app.default_host))\n            return\n        #handler得到类似：[URLSpec('/$', <class '__main__.IndexHandler'>, kwargs={}, name=None), URLSpec('/poem$', <class '__main__.PoemPageHandler'>, kwargs={}, name=None)]的返回值，就是对应的路径路由列表\n        for spec in handlers:\n            #对于路由表中的每个对象用request.path匹配，根据请求URL路径匹配Handler\n            match = spec.regex.match(self.request.path)\n            #匹配到路径后，生成RequstHandler对象，取得URL路径参数，跳出循环\n            if match:\n                #实例化，生成RequstHandler对象，即调用此类的构造函数\n                self.handler_class = spec.handler_class\n                self.handler_kwargs = spec.kwargs\n                #根据path路径，得到请求的URL的参数\n                if spec.regex.groups:\n                    #字符串做key的正则表\n                    if spec.regex.groupindex:\n                        self.path_kwargs = dict(\n                            (str(k), _unquote_or_none(v))\n                            for (k, v) in match.groupdict().items())\n                    else:\n                        #数字做key正则表\n                        self.path_args = [_unquote_or_none(s)\n                                          for s in match.groups()]\n                return\n        #若没匹配的到，如果有默认的handler，则使用\n        if app.settings.get('default_handler_class'):\n            self.handler_class = app.settings['default_handler_class']\n            self.handler_kwargs = app.settings.get(\n                'default_handler_args', {})\n        #否则返回404\n        else:\n            self.handler_class = ErrorHandler\n            self.handler_kwargs = dict(status_code=404)\n\n    def execute(self):\n        if not self.application.settings.get(\"compiled_template_cache\", True):\n            with RequestHandler._template_loader_lock:\n                for loader in RequestHandler._template_loaders.values():\n                    loader.reset()\n        if not self.application.settings.get('static_hash_cache', True):\n            StaticFileHandler.reset()\n\n        self.handler = self.handler_class(self.application, self.request,\n                                          **self.handler_kwargs)\n        transforms = [t(self.request) for t in self.application.transforms]\n\n        if self.stream_request_body:\n            self.handler._prepared_future = Future()\n\n        #调用已注册的处理器的_execute方法，处理请求。\n        self.handler._execute(transforms, *self.path_args,\n                              **self.path_kwargs)\n        return self.handler._prepared_future\n```\n\n# torndao.web.RequestHandler\n\nRequestHandler就是具体处理请求的类。这个类非常重要，RequestHandler中涉及到很多HTTP相关的技术，包括 Header、Status、Cookie、Etag、Content-Type、链接参数、重定向、长连接等等，还有和用户身份相关的XSRF和CSRF等等。\n\n在上面介绍Application中可以看到，Application通过调用RequestHandler类的方法_execute来完成调度，那么_execute显然就是真正干活的地方，我们就重点看这个函数。这个类中还包含了很多很实用的方法，具体在应用的时候可以看看。\n\n## _execute方法\n\n### 函数原型：\n```python\ndef _execute(self, transforms, *args, **kwargs):\n```\n\n参数解析：\n\n - **transforms:**相当于Application的中间件\n -\n\n```python\n@gen.coroutine\ndef _execute(self, transforms, *args, **kwargs):\n    self._transforms = transforms\n    try:\n        if self.request.method not in self.SUPPORTED_METHODS:\n            raise HTTPError(405)\n        self.path_args = [self.decode_argument(arg) for arg in args]\n        self.path_kwargs = dict((k, self.decode_argument(v, name=k))\n                                for (k, v) in kwargs.items())\n        if self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and \\\n                self.application.settings.get(\"xsrf_cookies\"):\n            self.check_xsrf_cookie()\n\n        result = self.prepare()\n        if result is not None:\n            result = yield result\n        if self._prepared_future is not None:\n            self._prepared_future.set_result(None)\n        if self._finished:\n            return\n\n        if _has_stream_request_body(self.__class__):\n            try:\n                yield self.request.body\n            except iostream.StreamClosedError:\n                return\n\n        #调handler的具体业务逻辑处理，在子类的get/post/put/delete 方法中处理，这里就是真正调Handler的post、get等方法的地方\n        method = getattr(self, self.request.method.lower())\n        result = method(*self.path_args, **self.path_kwargs)\n        if result is not None:\n            result = yield result\n        #self.finish函数做一些善后事宜，比如释放缓冲区，关闭连接等\n        if self._auto_finish and not self._finished:\n            self.finish()\n    except Exception as e:\n        try:\n            self._handle_request_exception(e)\n        except Exception:\n            app_log.error(\"Exception in exception handler\", exc_info=True)\n        if (self._prepared_future is not None and\n                not self._prepared_future.done()):\n            self._prepared_future.set_result(None)\n```\n\n","source":"_posts/tornado-web源码分析.md","raw":"---\ntitle: Tornado.web源码分析\ndate: 2016-05-18 00:01:02\ntags: Tornado源码分析\ncategories: Tornado系列\ntoc: true\ncomments: true\n---\n\ntorndao.web是Handler类的集合，tornado的web框架是在web.py中实现的，tornado.web模块中提供了两个重量级的类，Application和RequestHandler（本质是http请求处理的封装）类。Application类主要是做路由转发，torndao使用web.Application做URI，然后在通过RequestHandler类去处理这些请求。\n\n<!-- more -->\n# torndao.web.Application\nApplication官网解释说它是一系列网络请求的Handler，这些Handler的组合撑起了一个web网站。\n\ntorndao.web.Application提供的函数：\n![torndao.web.Application提供的函数](tornado-web源码分析/torndao_001.PNG)\n\n## Application类的方法和工作原理简单介绍\n\n - 构造函数：接受handlers参数，也是最终匹配主机的路径路由列表；设定transform列表；设定静态文件的路由；添加(\".*$\")的路由列表。\n - listen方法：创建server，并把自身，self作为回调函数\n - accept到新连接后主动调（__call__），其根据请求，把该请求转发到相应的路由路径表中具体的handler上去处理请求\n\n## **def __init__()**\n```python\ndef __init__(self, handlers=None, default_host=\"\", transforms=None,\n        **settings):\n```\n参数解析：\n\n - **handlers：**类型为list，一系列的URI的处理器列表，为对应的每个URI与handlers处理器的map，类似[(URI,handler_1),(URI_01,handler_1),.....]，当然还可以带一系列参数，比如static_path等:\n```python\napplication = web.Application([\n(r\"/static/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n])\n```\n - **default_host:**\n - **transforms：**分块、压缩等\n - **settings：**各种设置，如static、gzip、cookie_secret等等，是一个dict\n\n\nApplication类的初始化函数，将传入的处理器列表调用add_handlers函数注册，再有一些分块、压缩、UI、静态文件处理器的初始化，并调用add_handlers 方法，完成URI和处理器的映射关系，这个函数我们下面将会详细的介绍这个函数。\n\n## **def listen()**\n```python\ndef listen(self, port, address=\"\", **kwargs):\n```\n这个函数只是对HTTPServer的listen函数的一个封装，返回一个HTTPServer实例。在HTTPServer类中将仔细分析该函数。\n\n\n### 源码\n```python\ndef listen(self, port, address=\"\", **kwargs):\n    from tornado.httpserver import HTTPServer\n    #简单的封装\n    server = HTTPServer(self, **kwargs) #当连接到来后，HTTPServer负责调用\n    server.listen(port, address)\n    return server\n```\n**这里我们可以认为，在特定的地址-端口上创建并监听socket，并注册socket的可读事件到自身的call（前后双下划线，下同）方法上，即每逢一个新连接到来后，call将被调用。**\n\n## **def add_handlers()**\n```python\ndef add_handlers(self, host_pattern, host_handlers)\n```\n参数解析：\n\n - **host_pattern：**主机名正则\n - **host_handlers:**路由表和handler，即路径路由列表。如：\n```python\napplication = web.Application([\n    (r\"/static/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n])\n```\n添加路由与handlers的到处理器列表中，完成URI和处理器的映射。\n\n### 源码\n\n```python\ndef add_handlers(self, host_pattern, host_handlers):\n    #若无正则表达式的结束符，则添加\n    if not host_pattern.endswith(\"$\"):\n        host_pattern += \"$\"\n    handlers = []\n\n    #self.handlesr是一个主机和路由列表，每个元素是一个tuple，\n    #将主机名和路径路由列表合成tuple，添加到self.handlers中，供_get_host_handler()检索，\n    #可以根据主机名找到路径路由列表\n    if self.handlers and self.handlers[-1][0].pattern == '.*$': #由于'.*$'的特殊性，必须放在列表的最后\n        self.handlers.insert(-1, (re.compile(host_pattern), handlers))\n    else:\n        self.handlers.append((re.compile(host_pattern), handlers))\n\n    for spec in host_handlers:\n        if isinstance(spec, (tuple, list)):\n            assert len(spec) in (2, 3, 4)\n            spec = URLSpec(*spec)\n        #添加到处理器列表中\n        handlers.append(spec)\n        if spec.name:\n            if spec.name in self.named_handlers:\n                app_log.warning(\n                    \"Multiple handlers named %s; replacing previous value\",\n                    spec.name)\n            self.named_handlers[spec.name] = spec\n```\n我们看这个函数函数还是很简单的，就是把URI和handler添加到处理器列表中，完成映射map，完事。\n\n## **def add_transform()**\n```python\ndef add_transform(self, transform_class):\n```\n\n这个函数及其简单，完成的任务就是添加输出过滤器，例如gzip，chunk，会在输出的时候调用其。\n\n## def __call__()(备注：前后双下划线，下同)\n\n这个函数可以说是Application的主要核心方法之一，我们详细的来看看。\n\n```python\n    def __call__(self, request):\n        #传统的HTTP服务器接口\n        dispatcher = _RequestDispatcher(self, None)#传进去的是self参数\n        dispatcher.set_request(request)\n        return dispatcher.execute()\n```\n参数解析：\n\n - **request:**HttpRequest对象对象，定义在httputil中。\n\n这个函数实现的挺有技巧性，实现了一个__call__函数，这个函数有什么作用呢，就是类Application可以当做函数来调用了。\nApplication类可以这么理解它自身的一些函数的关系：\n在特定的地址-端口上创建并监听该socket，并且注册了该sockt的可读事件到自身的__call__函数。\n\n**__call__函数的好处**\n\n - Application类的对象可以当做函数来调用。\n - 当类对象当做函数来调用的时候，__call__会自动被调用，并且会保留对象的上下文。\n\n我们在tornado版的hello world前面的举例中，会发现当时是这么调用的：\n```python\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\nhttp_server = tornado.httpserver.HTTPServer(application)\nhttp_server.listen(options.port)\ntornado.ioloop.IOLoop.current().start()\n```\n\n上述举例可以看出，**我们将Application实例传给了HTTPServer，当监听到（listen()函数）请求的，由于Application类实现了__call__函数,所以当请求到来后，通过HTTPServer来调用Application实例，__call__方法中完成具体的URI转发工作，即，__call__函数会遍历Application的handlers列表，匹配到相应的URL的handler后，通过handler._execute进行相应处理；如果没有匹配的URL，则会调用ErrorHandler。**\n\n由上面的__call__函数我们看到，此方法主要是调用_RequestDispatcher来完成请求的处理，那么下面我们具体看看请求到来后的处理过程：\n\n### **Application对request的处理过程**\n```python\ndef _has_stream_request_body(cls):\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    return getattr(cls, '_stream_request_body', False)\n\n#Application类的方法\n#Application类的构造函数有这么一段代码：\n\"\"\"\nif handlers:\n    self.add_handlers(\".*$\", handlers)#host_pattern传入\".*$\",表示无限次的匹配，即默认情况下，所有的主机名都会被匹配\n\"\"\"\n#所以显然，默认情况下，任何host都会被匹配的，\ndef _get_host_handlers(self, request):\n    host = split_host_and_port(request.host.lower())[0]\n    matches = []\n    for pattern, handlers in self.handlers:\n        if pattern.match(host):\n            matches.extend(handlers)\n    if not matches and \"X-Real-Ip\" not in request.headers:\n        for pattern, handlers in self.handlers:\n            if pattern.match(self.default_host):\n                matches.extend(handlers)\n    return matches or None\n\nclass _RequestDispatcher(httputil.HTTPMessageDelegate):\n    def __init__(self, application, connection):\n        self.application = application\n        self.connection = connection\n        self.request = None\n        self.chunks = []\n        self.handler_class = None\n        self.handler_kwargs = None\n        self.path_args = []\n        self.path_kwargs = {}\n\n    .....\n\n    def set_request(self, request):\n        self.request = request\n        self._find_handler()\n        self.stream_request_body = _has_stream_request_body(self.handler_class)\n\n    def _find_handler(self):\n        app = self.application\n        #该函数将得到该host对应的路径路由列表，也就是那个映射map，\n        #也就是说返回的列表就是传递给构造Application的那个tuple列表\n        handlers = app._get_host_handlers(self.request)\n        if not handlers:\n            self.handler_class = RedirectHandler\n            self.handler_kwargs = dict(url=\"%s://%s/\"\n                                       % (self.request.protocol,\n                                          app.default_host))\n            return\n        #handler得到类似：[URLSpec('/$', <class '__main__.IndexHandler'>, kwargs={}, name=None), URLSpec('/poem$', <class '__main__.PoemPageHandler'>, kwargs={}, name=None)]的返回值，就是对应的路径路由列表\n        for spec in handlers:\n            #对于路由表中的每个对象用request.path匹配，根据请求URL路径匹配Handler\n            match = spec.regex.match(self.request.path)\n            #匹配到路径后，生成RequstHandler对象，取得URL路径参数，跳出循环\n            if match:\n                #实例化，生成RequstHandler对象，即调用此类的构造函数\n                self.handler_class = spec.handler_class\n                self.handler_kwargs = spec.kwargs\n                #根据path路径，得到请求的URL的参数\n                if spec.regex.groups:\n                    #字符串做key的正则表\n                    if spec.regex.groupindex:\n                        self.path_kwargs = dict(\n                            (str(k), _unquote_or_none(v))\n                            for (k, v) in match.groupdict().items())\n                    else:\n                        #数字做key正则表\n                        self.path_args = [_unquote_or_none(s)\n                                          for s in match.groups()]\n                return\n        #若没匹配的到，如果有默认的handler，则使用\n        if app.settings.get('default_handler_class'):\n            self.handler_class = app.settings['default_handler_class']\n            self.handler_kwargs = app.settings.get(\n                'default_handler_args', {})\n        #否则返回404\n        else:\n            self.handler_class = ErrorHandler\n            self.handler_kwargs = dict(status_code=404)\n\n    def execute(self):\n        if not self.application.settings.get(\"compiled_template_cache\", True):\n            with RequestHandler._template_loader_lock:\n                for loader in RequestHandler._template_loaders.values():\n                    loader.reset()\n        if not self.application.settings.get('static_hash_cache', True):\n            StaticFileHandler.reset()\n\n        self.handler = self.handler_class(self.application, self.request,\n                                          **self.handler_kwargs)\n        transforms = [t(self.request) for t in self.application.transforms]\n\n        if self.stream_request_body:\n            self.handler._prepared_future = Future()\n\n        #调用已注册的处理器的_execute方法，处理请求。\n        self.handler._execute(transforms, *self.path_args,\n                              **self.path_kwargs)\n        return self.handler._prepared_future\n```\n\n# torndao.web.RequestHandler\n\nRequestHandler就是具体处理请求的类。这个类非常重要，RequestHandler中涉及到很多HTTP相关的技术，包括 Header、Status、Cookie、Etag、Content-Type、链接参数、重定向、长连接等等，还有和用户身份相关的XSRF和CSRF等等。\n\n在上面介绍Application中可以看到，Application通过调用RequestHandler类的方法_execute来完成调度，那么_execute显然就是真正干活的地方，我们就重点看这个函数。这个类中还包含了很多很实用的方法，具体在应用的时候可以看看。\n\n## _execute方法\n\n### 函数原型：\n```python\ndef _execute(self, transforms, *args, **kwargs):\n```\n\n参数解析：\n\n - **transforms:**相当于Application的中间件\n -\n\n```python\n@gen.coroutine\ndef _execute(self, transforms, *args, **kwargs):\n    self._transforms = transforms\n    try:\n        if self.request.method not in self.SUPPORTED_METHODS:\n            raise HTTPError(405)\n        self.path_args = [self.decode_argument(arg) for arg in args]\n        self.path_kwargs = dict((k, self.decode_argument(v, name=k))\n                                for (k, v) in kwargs.items())\n        if self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and \\\n                self.application.settings.get(\"xsrf_cookies\"):\n            self.check_xsrf_cookie()\n\n        result = self.prepare()\n        if result is not None:\n            result = yield result\n        if self._prepared_future is not None:\n            self._prepared_future.set_result(None)\n        if self._finished:\n            return\n\n        if _has_stream_request_body(self.__class__):\n            try:\n                yield self.request.body\n            except iostream.StreamClosedError:\n                return\n\n        #调handler的具体业务逻辑处理，在子类的get/post/put/delete 方法中处理，这里就是真正调Handler的post、get等方法的地方\n        method = getattr(self, self.request.method.lower())\n        result = method(*self.path_args, **self.path_kwargs)\n        if result is not None:\n            result = yield result\n        #self.finish函数做一些善后事宜，比如释放缓冲区，关闭连接等\n        if self._auto_finish and not self._finished:\n            self.finish()\n    except Exception as e:\n        try:\n            self._handle_request_exception(e)\n        except Exception:\n            app_log.error(\"Exception in exception handler\", exc_info=True)\n        if (self._prepared_future is not None and\n                not self._prepared_future.done()):\n            self._prepared_future.set_result(None)\n```\n\n","slug":"tornado-web源码分析","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoiroo6000eta02solcpsz1","content":"<p>torndao.web是Handler类的集合，tornado的web框架是在web.py中实现的，tornado.web模块中提供了两个重量级的类，Application和RequestHandler（本质是http请求处理的封装）类。Application类主要是做路由转发，torndao使用web.Application做URI，然后在通过RequestHandler类去处理这些请求。</p>\n<a id=\"more\"></a>\n<h1 id=\"torndao-web-Application\"><a href=\"#torndao-web-Application\" class=\"headerlink\" title=\"torndao.web.Application\"></a>torndao.web.Application</h1><p>Application官网解释说它是一系列网络请求的Handler，这些Handler的组合撑起了一个web网站。</p>\n<p>torndao.web.Application提供的函数：<br><img src=\"tornado-web源码分析/torndao_001.PNG\" alt=\"torndao.web.Application提供的函数\"></p>\n<h2 id=\"Application类的方法和工作原理简单介绍\"><a href=\"#Application类的方法和工作原理简单介绍\" class=\"headerlink\" title=\"Application类的方法和工作原理简单介绍\"></a>Application类的方法和工作原理简单介绍</h2><ul>\n<li>构造函数：接受handlers参数，也是最终匹配主机的路径路由列表；设定transform列表；设定静态文件的路由；添加(“.*$”)的路由列表。</li>\n<li>listen方法：创建server，并把自身，self作为回调函数</li>\n<li>accept到新连接后主动调（<strong>call</strong>），其根据请求，把该请求转发到相应的路由路径表中具体的handler上去处理请求</li>\n</ul>\n<h2 id=\"def-init\"><a href=\"#def-init\" class=\"headerlink\" title=\"def init()\"></a><strong>def <strong>init</strong>()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, handlers=None, default_host=<span class=\"string\">\"\"</span>, transforms=None,</span></span></div><div class=\"line\">        **settings):</div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><p><strong>handlers：</strong>类型为list，一系列的URI的处理器列表，为对应的每个URI与handlers处理器的map，类似[(URI,handler_1),(URI_01,handler_1),…..]，当然还可以带一系列参数，比如static_path等:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = web.Application([</div><div class=\"line\">(<span class=\"string\">r\"/static/(.*)\"</span>, web.StaticFileHandler, &#123;<span class=\"string\">\"path\"</span>: <span class=\"string\">\"/var/www\"</span>&#125;),</div><div class=\"line\">])</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>default_host:</strong></p>\n</li>\n<li><strong>transforms：</strong>分块、压缩等</li>\n<li><strong>settings：</strong>各种设置，如static、gzip、cookie_secret等等，是一个dict</li>\n</ul>\n<p>Application类的初始化函数，将传入的处理器列表调用add_handlers函数注册，再有一些分块、压缩、UI、静态文件处理器的初始化，并调用add_handlers 方法，完成URI和处理器的映射关系，这个函数我们下面将会详细的介绍这个函数。</p>\n<h2 id=\"def-listen\"><a href=\"#def-listen\" class=\"headerlink\" title=\"def listen()\"></a><strong>def listen()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">listen</span><span class=\"params\">(self, port, address=<span class=\"string\">\"\"</span>, **kwargs)</span>:</span></div></pre></td></tr></table></figure>\n<p>这个函数只是对HTTPServer的listen函数的一个封装，返回一个HTTPServer实例。在HTTPServer类中将仔细分析该函数。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">listen</span><span class=\"params\">(self, port, address=<span class=\"string\">\"\"</span>, **kwargs)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">from</span> tornado.httpserver <span class=\"keyword\">import</span> HTTPServer</div><div class=\"line\">    <span class=\"comment\">#简单的封装</span></div><div class=\"line\">    server = HTTPServer(self, **kwargs) <span class=\"comment\">#当连接到来后，HTTPServer负责调用</span></div><div class=\"line\">    server.listen(port, address)</div><div class=\"line\">    <span class=\"keyword\">return</span> server</div></pre></td></tr></table></figure>\n<p><strong>这里我们可以认为，在特定的地址-端口上创建并监听socket，并注册socket的可读事件到自身的call（前后双下划线，下同）方法上，即每逢一个新连接到来后，call将被调用。</strong></p>\n<h2 id=\"def-add-handlers\"><a href=\"#def-add-handlers\" class=\"headerlink\" title=\"def add_handlers()\"></a><strong>def add_handlers()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_handlers</span><span class=\"params\">(self, host_pattern, host_handlers)</span></span></div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><strong>host_pattern：</strong>主机名正则</li>\n<li><strong>host_handlers:</strong>路由表和handler，即路径路由列表。如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = web.Application([</div><div class=\"line\">    (<span class=\"string\">r\"/static/(.*)\"</span>, web.StaticFileHandler, &#123;<span class=\"string\">\"path\"</span>: <span class=\"string\">\"/var/www\"</span>&#125;),</div><div class=\"line\">])</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加路由与handlers的到处理器列表中，完成URI和处理器的映射。</p>\n<h3 id=\"源码-1\"><a href=\"#源码-1\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_handlers</span><span class=\"params\">(self, host_pattern, host_handlers)</span>:</span></div><div class=\"line\">    <span class=\"comment\">#若无正则表达式的结束符，则添加</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> host_pattern.endswith(<span class=\"string\">\"$\"</span>):</div><div class=\"line\">        host_pattern += <span class=\"string\">\"$\"</span></div><div class=\"line\">    handlers = []</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">#self.handlesr是一个主机和路由列表，每个元素是一个tuple，</span></div><div class=\"line\">    <span class=\"comment\">#将主机名和路径路由列表合成tuple，添加到self.handlers中，供_get_host_handler()检索，</span></div><div class=\"line\">    <span class=\"comment\">#可以根据主机名找到路径路由列表</span></div><div class=\"line\">    <span class=\"keyword\">if</span> self.handlers <span class=\"keyword\">and</span> self.handlers[<span class=\"number\">-1</span>][<span class=\"number\">0</span>].pattern == <span class=\"string\">'.*$'</span>: <span class=\"comment\">#由于'.*$'的特殊性，必须放在列表的最后</span></div><div class=\"line\">        self.handlers.insert(<span class=\"number\">-1</span>, (re.compile(host_pattern), handlers))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        self.handlers.append((re.compile(host_pattern), handlers))</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> spec <span class=\"keyword\">in</span> host_handlers:</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(spec, (tuple, list)):</div><div class=\"line\">            <span class=\"keyword\">assert</span> len(spec) <span class=\"keyword\">in</span> (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</div><div class=\"line\">            spec = URLSpec(*spec)</div><div class=\"line\">        <span class=\"comment\">#添加到处理器列表中</span></div><div class=\"line\">        handlers.append(spec)</div><div class=\"line\">        <span class=\"keyword\">if</span> spec.name:</div><div class=\"line\">            <span class=\"keyword\">if</span> spec.name <span class=\"keyword\">in</span> self.named_handlers:</div><div class=\"line\">                app_log.warning(</div><div class=\"line\">                    <span class=\"string\">\"Multiple handlers named %s; replacing previous value\"</span>,</div><div class=\"line\">                    spec.name)</div><div class=\"line\">            self.named_handlers[spec.name] = spec</div></pre></td></tr></table></figure>\n<p>我们看这个函数函数还是很简单的，就是把URI和handler添加到处理器列表中，完成映射map，完事。</p>\n<h2 id=\"def-add-transform\"><a href=\"#def-add-transform\" class=\"headerlink\" title=\"def add_transform()\"></a><strong>def add_transform()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_transform</span><span class=\"params\">(self, transform_class)</span>:</span></div></pre></td></tr></table></figure>\n<p>这个函数及其简单，完成的任务就是添加输出过滤器，例如gzip，chunk，会在输出的时候调用其。</p>\n<h2 id=\"def-call-备注：前后双下划线，下同\"><a href=\"#def-call-备注：前后双下划线，下同\" class=\"headerlink\" title=\"def call()(备注：前后双下划线，下同)\"></a>def <strong>call</strong>()(备注：前后双下划线，下同)</h2><p>这个函数可以说是Application的主要核心方法之一，我们详细的来看看。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">    <span class=\"comment\">#传统的HTTP服务器接口</span></div><div class=\"line\">    dispatcher = _RequestDispatcher(self, <span class=\"keyword\">None</span>)<span class=\"comment\">#传进去的是self参数</span></div><div class=\"line\">    dispatcher.set_request(request)</div><div class=\"line\">    <span class=\"keyword\">return</span> dispatcher.execute()</div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><strong>request:</strong>HttpRequest对象对象，定义在httputil中。</li>\n</ul>\n<p>这个函数实现的挺有技巧性，实现了一个<strong>call</strong>函数，这个函数有什么作用呢，就是类Application可以当做函数来调用了。<br>Application类可以这么理解它自身的一些函数的关系：<br>在特定的地址-端口上创建并监听该socket，并且注册了该sockt的可读事件到自身的<strong>call</strong>函数。</p>\n<p><strong><strong>call</strong>函数的好处</strong></p>\n<ul>\n<li>Application类的对象可以当做函数来调用。</li>\n<li>当类对象当做函数来调用的时候，<strong>call</strong>会自动被调用，并且会保留对象的上下文。</li>\n</ul>\n<p>我们在tornado版的hello world前面的举例中，会发现当时是这么调用的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = tornado.web.Application([</div><div class=\"line\">    (<span class=\"string\">r\"/\"</span>, MainHandler),</div><div class=\"line\">])</div><div class=\"line\">http_server = tornado.httpserver.HTTPServer(application)</div><div class=\"line\">http_server.listen(options.port)</div><div class=\"line\">tornado.ioloop.IOLoop.current().start()</div></pre></td></tr></table></figure></p>\n<p>上述举例可以看出，<strong>我们将Application实例传给了HTTPServer，当监听到（listen()函数）请求的，由于Application类实现了<strong>call</strong>函数,所以当请求到来后，通过HTTPServer来调用Application实例，<strong>call</strong>方法中完成具体的URI转发工作，即，<strong>call</strong>函数会遍历Application的handlers列表，匹配到相应的URL的handler后，通过handler._execute进行相应处理；如果没有匹配的URL，则会调用ErrorHandler。</strong></p>\n<p>由上面的<strong>call</strong>函数我们看到，此方法主要是调用_RequestDispatcher来完成请求的处理，那么下面我们具体看看请求到来后的处理过程：</p>\n<h3 id=\"Application对request的处理过程\"><a href=\"#Application对request的处理过程\" class=\"headerlink\" title=\"Application对request的处理过程\"></a><strong>Application对request的处理过程</strong></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_has_stream_request_body</span><span class=\"params\">(cls)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> issubclass(cls, RequestHandler):</div><div class=\"line\">        <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">\"expected subclass of RequestHandler, got %r\"</span>, cls)</div><div class=\"line\">    <span class=\"keyword\">return</span> getattr(cls, <span class=\"string\">'_stream_request_body'</span>, <span class=\"keyword\">False</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#Application类的方法</span></div><div class=\"line\"><span class=\"comment\">#Application类的构造函数有这么一段代码：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">if handlers:</div><div class=\"line\">    self.add_handlers(\".*$\", handlers)#host_pattern传入\".*$\",表示无限次的匹配，即默认情况下，所有的主机名都会被匹配</div><div class=\"line\">\"\"\"</div><div class=\"line\"><span class=\"comment\">#所以显然，默认情况下，任何host都会被匹配的，</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_get_host_handlers</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">    host = split_host_and_port(request.host.lower())[<span class=\"number\">0</span>]</div><div class=\"line\">    matches = []</div><div class=\"line\">    <span class=\"keyword\">for</span> pattern, handlers <span class=\"keyword\">in</span> self.handlers:</div><div class=\"line\">        <span class=\"keyword\">if</span> pattern.match(host):</div><div class=\"line\">            matches.extend(handlers)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matches <span class=\"keyword\">and</span> <span class=\"string\">\"X-Real-Ip\"</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.headers:</div><div class=\"line\">        <span class=\"keyword\">for</span> pattern, handlers <span class=\"keyword\">in</span> self.handlers:</div><div class=\"line\">            <span class=\"keyword\">if</span> pattern.match(self.default_host):</div><div class=\"line\">                matches.extend(handlers)</div><div class=\"line\">    <span class=\"keyword\">return</span> matches <span class=\"keyword\">or</span> <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_RequestDispatcher</span><span class=\"params\">(httputil.HTTPMessageDelegate)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, application, connection)</span>:</span></div><div class=\"line\">        self.application = application</div><div class=\"line\">        self.connection = connection</div><div class=\"line\">        self.request = <span class=\"keyword\">None</span></div><div class=\"line\">        self.chunks = []</div><div class=\"line\">        self.handler_class = <span class=\"keyword\">None</span></div><div class=\"line\">        self.handler_kwargs = <span class=\"keyword\">None</span></div><div class=\"line\">        self.path_args = []</div><div class=\"line\">        self.path_kwargs = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    .....</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_request</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        self.request = request</div><div class=\"line\">        self._find_handler()</div><div class=\"line\">        self.stream_request_body = _has_stream_request_body(self.handler_class)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_find_handler</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        app = self.application</div><div class=\"line\">        <span class=\"comment\">#该函数将得到该host对应的路径路由列表，也就是那个映射map，</span></div><div class=\"line\">        <span class=\"comment\">#也就是说返回的列表就是传递给构造Application的那个tuple列表</span></div><div class=\"line\">        handlers = app._get_host_handlers(self.request)</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> handlers:</div><div class=\"line\">            self.handler_class = RedirectHandler</div><div class=\"line\">            self.handler_kwargs = dict(url=<span class=\"string\">\"%s://%s/\"</span></div><div class=\"line\">                                       % (self.request.protocol,</div><div class=\"line\">                                          app.default_host))</div><div class=\"line\">            <span class=\"keyword\">return</span></div><div class=\"line\">        <span class=\"comment\">#handler得到类似：[URLSpec('/$', &lt;class '__main__.IndexHandler'&gt;, kwargs=&#123;&#125;, name=None), URLSpec('/poem$', &lt;class '__main__.PoemPageHandler'&gt;, kwargs=&#123;&#125;, name=None)]的返回值，就是对应的路径路由列表</span></div><div class=\"line\">        <span class=\"keyword\">for</span> spec <span class=\"keyword\">in</span> handlers:</div><div class=\"line\">            <span class=\"comment\">#对于路由表中的每个对象用request.path匹配，根据请求URL路径匹配Handler</span></div><div class=\"line\">            match = spec.regex.match(self.request.path)</div><div class=\"line\">            <span class=\"comment\">#匹配到路径后，生成RequstHandler对象，取得URL路径参数，跳出循环</span></div><div class=\"line\">            <span class=\"keyword\">if</span> match:</div><div class=\"line\">                <span class=\"comment\">#实例化，生成RequstHandler对象，即调用此类的构造函数</span></div><div class=\"line\">                self.handler_class = spec.handler_class</div><div class=\"line\">                self.handler_kwargs = spec.kwargs</div><div class=\"line\">                <span class=\"comment\">#根据path路径，得到请求的URL的参数</span></div><div class=\"line\">                <span class=\"keyword\">if</span> spec.regex.groups:</div><div class=\"line\">                    <span class=\"comment\">#字符串做key的正则表</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> spec.regex.groupindex:</div><div class=\"line\">                        self.path_kwargs = dict(</div><div class=\"line\">                            (str(k), _unquote_or_none(v))</div><div class=\"line\">                            <span class=\"keyword\">for</span> (k, v) <span class=\"keyword\">in</span> match.groupdict().items())</div><div class=\"line\">                    <span class=\"keyword\">else</span>:</div><div class=\"line\">                        <span class=\"comment\">#数字做key正则表</span></div><div class=\"line\">                        self.path_args = [_unquote_or_none(s)</div><div class=\"line\">                                          <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> match.groups()]</div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">        <span class=\"comment\">#若没匹配的到，如果有默认的handler，则使用</span></div><div class=\"line\">        <span class=\"keyword\">if</span> app.settings.get(<span class=\"string\">'default_handler_class'</span>):</div><div class=\"line\">            self.handler_class = app.settings[<span class=\"string\">'default_handler_class'</span>]</div><div class=\"line\">            self.handler_kwargs = app.settings.get(</div><div class=\"line\">                <span class=\"string\">'default_handler_args'</span>, &#123;&#125;)</div><div class=\"line\">        <span class=\"comment\">#否则返回404</span></div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            self.handler_class = ErrorHandler</div><div class=\"line\">            self.handler_kwargs = dict(status_code=<span class=\"number\">404</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">execute</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.application.settings.get(<span class=\"string\">\"compiled_template_cache\"</span>, <span class=\"keyword\">True</span>):</div><div class=\"line\">            <span class=\"keyword\">with</span> RequestHandler._template_loader_lock:</div><div class=\"line\">                <span class=\"keyword\">for</span> loader <span class=\"keyword\">in</span> RequestHandler._template_loaders.values():</div><div class=\"line\">                    loader.reset()</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.application.settings.get(<span class=\"string\">'static_hash_cache'</span>, <span class=\"keyword\">True</span>):</div><div class=\"line\">            StaticFileHandler.reset()</div><div class=\"line\"></div><div class=\"line\">        self.handler = self.handler_class(self.application, self.request,</div><div class=\"line\">                                          **self.handler_kwargs)</div><div class=\"line\">        transforms = [t(self.request) <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> self.application.transforms]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> self.stream_request_body:</div><div class=\"line\">            self.handler._prepared_future = Future()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#调用已注册的处理器的_execute方法，处理请求。</span></div><div class=\"line\">        self.handler._execute(transforms, *self.path_args,</div><div class=\"line\">                              **self.path_kwargs)</div><div class=\"line\">        <span class=\"keyword\">return</span> self.handler._prepared_future</div></pre></td></tr></table></figure>\n<h1 id=\"torndao-web-RequestHandler\"><a href=\"#torndao-web-RequestHandler\" class=\"headerlink\" title=\"torndao.web.RequestHandler\"></a>torndao.web.RequestHandler</h1><p>RequestHandler就是具体处理请求的类。这个类非常重要，RequestHandler中涉及到很多HTTP相关的技术，包括 Header、Status、Cookie、Etag、Content-Type、链接参数、重定向、长连接等等，还有和用户身份相关的XSRF和CSRF等等。</p>\n<p>在上面介绍Application中可以看到，Application通过调用RequestHandler类的方法_execute来完成调度，那么_execute显然就是真正干活的地方，我们就重点看这个函数。这个类中还包含了很多很实用的方法，具体在应用的时候可以看看。</p>\n<h2 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"_execute方法\"></a>_execute方法</h2><h3 id=\"函数原型：\"><a href=\"#函数原型：\" class=\"headerlink\" title=\"函数原型：\"></a>函数原型：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_execute</span><span class=\"params\">(self, transforms, *args, **kwargs)</span>:</span></div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><strong>transforms:</strong>相当于Application的中间件<br>-</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@gen.coroutine</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_execute</span><span class=\"params\">(self, transforms, *args, **kwargs)</span>:</span></div><div class=\"line\">    self._transforms = transforms</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        <span class=\"keyword\">if</span> self.request.method <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.SUPPORTED_METHODS:</div><div class=\"line\">            <span class=\"keyword\">raise</span> HTTPError(<span class=\"number\">405</span>)</div><div class=\"line\">        self.path_args = [self.decode_argument(arg) <span class=\"keyword\">for</span> arg <span class=\"keyword\">in</span> args]</div><div class=\"line\">        self.path_kwargs = dict((k, self.decode_argument(v, name=k))</div><div class=\"line\">                                <span class=\"keyword\">for</span> (k, v) <span class=\"keyword\">in</span> kwargs.items())</div><div class=\"line\">        <span class=\"keyword\">if</span> self.request.method <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"HEAD\"</span>, <span class=\"string\">\"OPTIONS\"</span>) <span class=\"keyword\">and</span> \\</div><div class=\"line\">                self.application.settings.get(<span class=\"string\">\"xsrf_cookies\"</span>):</div><div class=\"line\">            self.check_xsrf_cookie()</div><div class=\"line\"></div><div class=\"line\">        result = self.prepare()</div><div class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            result = <span class=\"keyword\">yield</span> result</div><div class=\"line\">        <span class=\"keyword\">if</span> self._prepared_future <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            self._prepared_future.set_result(<span class=\"keyword\">None</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self._finished:</div><div class=\"line\">            <span class=\"keyword\">return</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> _has_stream_request_body(self.__class__):</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                <span class=\"keyword\">yield</span> self.request.body</div><div class=\"line\">            <span class=\"keyword\">except</span> iostream.StreamClosedError:</div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#调handler的具体业务逻辑处理，在子类的get/post/put/delete 方法中处理，这里就是真正调Handler的post、get等方法的地方</span></div><div class=\"line\">        method = getattr(self, self.request.method.lower())</div><div class=\"line\">        result = method(*self.path_args, **self.path_kwargs)</div><div class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            result = <span class=\"keyword\">yield</span> result</div><div class=\"line\">        <span class=\"comment\">#self.finish函数做一些善后事宜，比如释放缓冲区，关闭连接等</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self._auto_finish <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> self._finished:</div><div class=\"line\">            self.finish()</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            self._handle_request_exception(e)</div><div class=\"line\">        <span class=\"keyword\">except</span> Exception:</div><div class=\"line\">            app_log.error(<span class=\"string\">\"Exception in exception handler\"</span>, exc_info=<span class=\"keyword\">True</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> (self._prepared_future <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span> <span class=\"keyword\">and</span></div><div class=\"line\">                <span class=\"keyword\">not</span> self._prepared_future.done()):</div><div class=\"line\">            self._prepared_future.set_result(<span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>\n","excerpt":"<p>torndao.web是Handler类的集合，tornado的web框架是在web.py中实现的，tornado.web模块中提供了两个重量级的类，Application和RequestHandler（本质是http请求处理的封装）类。Application类主要是做路由转发，torndao使用web.Application做URI，然后在通过RequestHandler类去处理这些请求。</p>","more":"<h1 id=\"torndao-web-Application\"><a href=\"#torndao-web-Application\" class=\"headerlink\" title=\"torndao.web.Application\"></a>torndao.web.Application</h1><p>Application官网解释说它是一系列网络请求的Handler，这些Handler的组合撑起了一个web网站。</p>\n<p>torndao.web.Application提供的函数：<br><img src=\"tornado-web源码分析/torndao_001.PNG\" alt=\"torndao.web.Application提供的函数\"></p>\n<h2 id=\"Application类的方法和工作原理简单介绍\"><a href=\"#Application类的方法和工作原理简单介绍\" class=\"headerlink\" title=\"Application类的方法和工作原理简单介绍\"></a>Application类的方法和工作原理简单介绍</h2><ul>\n<li>构造函数：接受handlers参数，也是最终匹配主机的路径路由列表；设定transform列表；设定静态文件的路由；添加(“.*$”)的路由列表。</li>\n<li>listen方法：创建server，并把自身，self作为回调函数</li>\n<li>accept到新连接后主动调（<strong>call</strong>），其根据请求，把该请求转发到相应的路由路径表中具体的handler上去处理请求</li>\n</ul>\n<h2 id=\"def-init\"><a href=\"#def-init\" class=\"headerlink\" title=\"def init()\"></a><strong>def <strong>init</strong>()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, handlers=None, default_host=<span class=\"string\">\"\"</span>, transforms=None,</div><div class=\"line\">        **settings)</span>:</span></div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><p><strong>handlers：</strong>类型为list，一系列的URI的处理器列表，为对应的每个URI与handlers处理器的map，类似[(URI,handler_1),(URI_01,handler_1),…..]，当然还可以带一系列参数，比如static_path等:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = web.Application([</div><div class=\"line\">(<span class=\"string\">r\"/static/(.*)\"</span>, web.StaticFileHandler, &#123;<span class=\"string\">\"path\"</span>: <span class=\"string\">\"/var/www\"</span>&#125;),</div><div class=\"line\">])</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>default_host:</strong></p>\n</li>\n<li><strong>transforms：</strong>分块、压缩等</li>\n<li><strong>settings：</strong>各种设置，如static、gzip、cookie_secret等等，是一个dict</li>\n</ul>\n<p>Application类的初始化函数，将传入的处理器列表调用add_handlers函数注册，再有一些分块、压缩、UI、静态文件处理器的初始化，并调用add_handlers 方法，完成URI和处理器的映射关系，这个函数我们下面将会详细的介绍这个函数。</p>\n<h2 id=\"def-listen\"><a href=\"#def-listen\" class=\"headerlink\" title=\"def listen()\"></a><strong>def listen()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">listen</span><span class=\"params\">(self, port, address=<span class=\"string\">\"\"</span>, **kwargs)</span>:</span></div></pre></td></tr></table></figure>\n<p>这个函数只是对HTTPServer的listen函数的一个封装，返回一个HTTPServer实例。在HTTPServer类中将仔细分析该函数。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">listen</span><span class=\"params\">(self, port, address=<span class=\"string\">\"\"</span>, **kwargs)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">from</span> tornado.httpserver <span class=\"keyword\">import</span> HTTPServer</div><div class=\"line\">    <span class=\"comment\">#简单的封装</span></div><div class=\"line\">    server = HTTPServer(self, **kwargs) <span class=\"comment\">#当连接到来后，HTTPServer负责调用</span></div><div class=\"line\">    server.listen(port, address)</div><div class=\"line\">    <span class=\"keyword\">return</span> server</div></pre></td></tr></table></figure>\n<p><strong>这里我们可以认为，在特定的地址-端口上创建并监听socket，并注册socket的可读事件到自身的call（前后双下划线，下同）方法上，即每逢一个新连接到来后，call将被调用。</strong></p>\n<h2 id=\"def-add-handlers\"><a href=\"#def-add-handlers\" class=\"headerlink\" title=\"def add_handlers()\"></a><strong>def add_handlers()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_handlers</span><span class=\"params\">(self, host_pattern, host_handlers)</span></span></div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><strong>host_pattern：</strong>主机名正则</li>\n<li><strong>host_handlers:</strong>路由表和handler，即路径路由列表。如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = web.Application([</div><div class=\"line\">    (<span class=\"string\">r\"/static/(.*)\"</span>, web.StaticFileHandler, &#123;<span class=\"string\">\"path\"</span>: <span class=\"string\">\"/var/www\"</span>&#125;),</div><div class=\"line\">])</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加路由与handlers的到处理器列表中，完成URI和处理器的映射。</p>\n<h3 id=\"源码-1\"><a href=\"#源码-1\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_handlers</span><span class=\"params\">(self, host_pattern, host_handlers)</span>:</span></div><div class=\"line\">    <span class=\"comment\">#若无正则表达式的结束符，则添加</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> host_pattern.endswith(<span class=\"string\">\"$\"</span>):</div><div class=\"line\">        host_pattern += <span class=\"string\">\"$\"</span></div><div class=\"line\">    handlers = []</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">#self.handlesr是一个主机和路由列表，每个元素是一个tuple，</span></div><div class=\"line\">    <span class=\"comment\">#将主机名和路径路由列表合成tuple，添加到self.handlers中，供_get_host_handler()检索，</span></div><div class=\"line\">    <span class=\"comment\">#可以根据主机名找到路径路由列表</span></div><div class=\"line\">    <span class=\"keyword\">if</span> self.handlers <span class=\"keyword\">and</span> self.handlers[<span class=\"number\">-1</span>][<span class=\"number\">0</span>].pattern == <span class=\"string\">'.*$'</span>: <span class=\"comment\">#由于'.*$'的特殊性，必须放在列表的最后</span></div><div class=\"line\">        self.handlers.insert(<span class=\"number\">-1</span>, (re.compile(host_pattern), handlers))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        self.handlers.append((re.compile(host_pattern), handlers))</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> spec <span class=\"keyword\">in</span> host_handlers:</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(spec, (tuple, list)):</div><div class=\"line\">            <span class=\"keyword\">assert</span> len(spec) <span class=\"keyword\">in</span> (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</div><div class=\"line\">            spec = URLSpec(*spec)</div><div class=\"line\">        <span class=\"comment\">#添加到处理器列表中</span></div><div class=\"line\">        handlers.append(spec)</div><div class=\"line\">        <span class=\"keyword\">if</span> spec.name:</div><div class=\"line\">            <span class=\"keyword\">if</span> spec.name <span class=\"keyword\">in</span> self.named_handlers:</div><div class=\"line\">                app_log.warning(</div><div class=\"line\">                    <span class=\"string\">\"Multiple handlers named %s; replacing previous value\"</span>,</div><div class=\"line\">                    spec.name)</div><div class=\"line\">            self.named_handlers[spec.name] = spec</div></pre></td></tr></table></figure>\n<p>我们看这个函数函数还是很简单的，就是把URI和handler添加到处理器列表中，完成映射map，完事。</p>\n<h2 id=\"def-add-transform\"><a href=\"#def-add-transform\" class=\"headerlink\" title=\"def add_transform()\"></a><strong>def add_transform()</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_transform</span><span class=\"params\">(self, transform_class)</span>:</span></div></pre></td></tr></table></figure>\n<p>这个函数及其简单，完成的任务就是添加输出过滤器，例如gzip，chunk，会在输出的时候调用其。</p>\n<h2 id=\"def-call-备注：前后双下划线，下同\"><a href=\"#def-call-备注：前后双下划线，下同\" class=\"headerlink\" title=\"def call()(备注：前后双下划线，下同)\"></a>def <strong>call</strong>()(备注：前后双下划线，下同)</h2><p>这个函数可以说是Application的主要核心方法之一，我们详细的来看看。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">    <span class=\"comment\">#传统的HTTP服务器接口</span></div><div class=\"line\">    dispatcher = _RequestDispatcher(self, <span class=\"keyword\">None</span>)<span class=\"comment\">#传进去的是self参数</span></div><div class=\"line\">    dispatcher.set_request(request)</div><div class=\"line\">    <span class=\"keyword\">return</span> dispatcher.execute()</div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><strong>request:</strong>HttpRequest对象对象，定义在httputil中。</li>\n</ul>\n<p>这个函数实现的挺有技巧性，实现了一个<strong>call</strong>函数，这个函数有什么作用呢，就是类Application可以当做函数来调用了。<br>Application类可以这么理解它自身的一些函数的关系：<br>在特定的地址-端口上创建并监听该socket，并且注册了该sockt的可读事件到自身的<strong>call</strong>函数。</p>\n<p><strong><strong>call</strong>函数的好处</strong></p>\n<ul>\n<li>Application类的对象可以当做函数来调用。</li>\n<li>当类对象当做函数来调用的时候，<strong>call</strong>会自动被调用，并且会保留对象的上下文。</li>\n</ul>\n<p>我们在tornado版的hello world前面的举例中，会发现当时是这么调用的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = tornado.web.Application([</div><div class=\"line\">    (<span class=\"string\">r\"/\"</span>, MainHandler),</div><div class=\"line\">])</div><div class=\"line\">http_server = tornado.httpserver.HTTPServer(application)</div><div class=\"line\">http_server.listen(options.port)</div><div class=\"line\">tornado.ioloop.IOLoop.current().start()</div></pre></td></tr></table></figure></p>\n<p>上述举例可以看出，<strong>我们将Application实例传给了HTTPServer，当监听到（listen()函数）请求的，由于Application类实现了<strong>call</strong>函数,所以当请求到来后，通过HTTPServer来调用Application实例，<strong>call</strong>方法中完成具体的URI转发工作，即，<strong>call</strong>函数会遍历Application的handlers列表，匹配到相应的URL的handler后，通过handler._execute进行相应处理；如果没有匹配的URL，则会调用ErrorHandler。</strong></p>\n<p>由上面的<strong>call</strong>函数我们看到，此方法主要是调用_RequestDispatcher来完成请求的处理，那么下面我们具体看看请求到来后的处理过程：</p>\n<h3 id=\"Application对request的处理过程\"><a href=\"#Application对request的处理过程\" class=\"headerlink\" title=\"Application对request的处理过程\"></a><strong>Application对request的处理过程</strong></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_has_stream_request_body</span><span class=\"params\">(cls)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> issubclass(cls, RequestHandler):</div><div class=\"line\">        <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">\"expected subclass of RequestHandler, got %r\"</span>, cls)</div><div class=\"line\">    <span class=\"keyword\">return</span> getattr(cls, <span class=\"string\">'_stream_request_body'</span>, <span class=\"keyword\">False</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#Application类的方法</span></div><div class=\"line\"><span class=\"comment\">#Application类的构造函数有这么一段代码：</span></div><div class=\"line\"><span class=\"string\">\"\"\"</div><div class=\"line\">if handlers:</div><div class=\"line\">    self.add_handlers(\".*$\", handlers)#host_pattern传入\".*$\",表示无限次的匹配，即默认情况下，所有的主机名都会被匹配</div><div class=\"line\">\"\"\"</span></div><div class=\"line\"><span class=\"comment\">#所以显然，默认情况下，任何host都会被匹配的，</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_get_host_handlers</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">    host = split_host_and_port(request.host.lower())[<span class=\"number\">0</span>]</div><div class=\"line\">    matches = []</div><div class=\"line\">    <span class=\"keyword\">for</span> pattern, handlers <span class=\"keyword\">in</span> self.handlers:</div><div class=\"line\">        <span class=\"keyword\">if</span> pattern.match(host):</div><div class=\"line\">            matches.extend(handlers)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matches <span class=\"keyword\">and</span> <span class=\"string\">\"X-Real-Ip\"</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.headers:</div><div class=\"line\">        <span class=\"keyword\">for</span> pattern, handlers <span class=\"keyword\">in</span> self.handlers:</div><div class=\"line\">            <span class=\"keyword\">if</span> pattern.match(self.default_host):</div><div class=\"line\">                matches.extend(handlers)</div><div class=\"line\">    <span class=\"keyword\">return</span> matches <span class=\"keyword\">or</span> <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_RequestDispatcher</span><span class=\"params\">(httputil.HTTPMessageDelegate)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, application, connection)</span>:</span></div><div class=\"line\">        self.application = application</div><div class=\"line\">        self.connection = connection</div><div class=\"line\">        self.request = <span class=\"keyword\">None</span></div><div class=\"line\">        self.chunks = []</div><div class=\"line\">        self.handler_class = <span class=\"keyword\">None</span></div><div class=\"line\">        self.handler_kwargs = <span class=\"keyword\">None</span></div><div class=\"line\">        self.path_args = []</div><div class=\"line\">        self.path_kwargs = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    .....</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_request</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        self.request = request</div><div class=\"line\">        self._find_handler()</div><div class=\"line\">        self.stream_request_body = _has_stream_request_body(self.handler_class)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_find_handler</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        app = self.application</div><div class=\"line\">        <span class=\"comment\">#该函数将得到该host对应的路径路由列表，也就是那个映射map，</span></div><div class=\"line\">        <span class=\"comment\">#也就是说返回的列表就是传递给构造Application的那个tuple列表</span></div><div class=\"line\">        handlers = app._get_host_handlers(self.request)</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> handlers:</div><div class=\"line\">            self.handler_class = RedirectHandler</div><div class=\"line\">            self.handler_kwargs = dict(url=<span class=\"string\">\"%s://%s/\"</span></div><div class=\"line\">                                       % (self.request.protocol,</div><div class=\"line\">                                          app.default_host))</div><div class=\"line\">            <span class=\"keyword\">return</span></div><div class=\"line\">        <span class=\"comment\">#handler得到类似：[URLSpec('/$', &lt;class '__main__.IndexHandler'&gt;, kwargs=&#123;&#125;, name=None), URLSpec('/poem$', &lt;class '__main__.PoemPageHandler'&gt;, kwargs=&#123;&#125;, name=None)]的返回值，就是对应的路径路由列表</span></div><div class=\"line\">        <span class=\"keyword\">for</span> spec <span class=\"keyword\">in</span> handlers:</div><div class=\"line\">            <span class=\"comment\">#对于路由表中的每个对象用request.path匹配，根据请求URL路径匹配Handler</span></div><div class=\"line\">            match = spec.regex.match(self.request.path)</div><div class=\"line\">            <span class=\"comment\">#匹配到路径后，生成RequstHandler对象，取得URL路径参数，跳出循环</span></div><div class=\"line\">            <span class=\"keyword\">if</span> match:</div><div class=\"line\">                <span class=\"comment\">#实例化，生成RequstHandler对象，即调用此类的构造函数</span></div><div class=\"line\">                self.handler_class = spec.handler_class</div><div class=\"line\">                self.handler_kwargs = spec.kwargs</div><div class=\"line\">                <span class=\"comment\">#根据path路径，得到请求的URL的参数</span></div><div class=\"line\">                <span class=\"keyword\">if</span> spec.regex.groups:</div><div class=\"line\">                    <span class=\"comment\">#字符串做key的正则表</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> spec.regex.groupindex:</div><div class=\"line\">                        self.path_kwargs = dict(</div><div class=\"line\">                            (str(k), _unquote_or_none(v))</div><div class=\"line\">                            <span class=\"keyword\">for</span> (k, v) <span class=\"keyword\">in</span> match.groupdict().items())</div><div class=\"line\">                    <span class=\"keyword\">else</span>:</div><div class=\"line\">                        <span class=\"comment\">#数字做key正则表</span></div><div class=\"line\">                        self.path_args = [_unquote_or_none(s)</div><div class=\"line\">                                          <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> match.groups()]</div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">        <span class=\"comment\">#若没匹配的到，如果有默认的handler，则使用</span></div><div class=\"line\">        <span class=\"keyword\">if</span> app.settings.get(<span class=\"string\">'default_handler_class'</span>):</div><div class=\"line\">            self.handler_class = app.settings[<span class=\"string\">'default_handler_class'</span>]</div><div class=\"line\">            self.handler_kwargs = app.settings.get(</div><div class=\"line\">                <span class=\"string\">'default_handler_args'</span>, &#123;&#125;)</div><div class=\"line\">        <span class=\"comment\">#否则返回404</span></div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            self.handler_class = ErrorHandler</div><div class=\"line\">            self.handler_kwargs = dict(status_code=<span class=\"number\">404</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">execute</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.application.settings.get(<span class=\"string\">\"compiled_template_cache\"</span>, <span class=\"keyword\">True</span>):</div><div class=\"line\">            <span class=\"keyword\">with</span> RequestHandler._template_loader_lock:</div><div class=\"line\">                <span class=\"keyword\">for</span> loader <span class=\"keyword\">in</span> RequestHandler._template_loaders.values():</div><div class=\"line\">                    loader.reset()</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.application.settings.get(<span class=\"string\">'static_hash_cache'</span>, <span class=\"keyword\">True</span>):</div><div class=\"line\">            StaticFileHandler.reset()</div><div class=\"line\"></div><div class=\"line\">        self.handler = self.handler_class(self.application, self.request,</div><div class=\"line\">                                          **self.handler_kwargs)</div><div class=\"line\">        transforms = [t(self.request) <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> self.application.transforms]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> self.stream_request_body:</div><div class=\"line\">            self.handler._prepared_future = Future()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#调用已注册的处理器的_execute方法，处理请求。</span></div><div class=\"line\">        self.handler._execute(transforms, *self.path_args,</div><div class=\"line\">                              **self.path_kwargs)</div><div class=\"line\">        <span class=\"keyword\">return</span> self.handler._prepared_future</div></pre></td></tr></table></figure>\n<h1 id=\"torndao-web-RequestHandler\"><a href=\"#torndao-web-RequestHandler\" class=\"headerlink\" title=\"torndao.web.RequestHandler\"></a>torndao.web.RequestHandler</h1><p>RequestHandler就是具体处理请求的类。这个类非常重要，RequestHandler中涉及到很多HTTP相关的技术，包括 Header、Status、Cookie、Etag、Content-Type、链接参数、重定向、长连接等等，还有和用户身份相关的XSRF和CSRF等等。</p>\n<p>在上面介绍Application中可以看到，Application通过调用RequestHandler类的方法_execute来完成调度，那么_execute显然就是真正干活的地方，我们就重点看这个函数。这个类中还包含了很多很实用的方法，具体在应用的时候可以看看。</p>\n<h2 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"_execute方法\"></a>_execute方法</h2><h3 id=\"函数原型：\"><a href=\"#函数原型：\" class=\"headerlink\" title=\"函数原型：\"></a>函数原型：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_execute</span><span class=\"params\">(self, transforms, *args, **kwargs)</span>:</span></div></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><strong>transforms:</strong>相当于Application的中间件<br>-</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@gen.coroutine</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_execute</span><span class=\"params\">(self, transforms, *args, **kwargs)</span>:</span></div><div class=\"line\">    self._transforms = transforms</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        <span class=\"keyword\">if</span> self.request.method <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.SUPPORTED_METHODS:</div><div class=\"line\">            <span class=\"keyword\">raise</span> HTTPError(<span class=\"number\">405</span>)</div><div class=\"line\">        self.path_args = [self.decode_argument(arg) <span class=\"keyword\">for</span> arg <span class=\"keyword\">in</span> args]</div><div class=\"line\">        self.path_kwargs = dict((k, self.decode_argument(v, name=k))</div><div class=\"line\">                                <span class=\"keyword\">for</span> (k, v) <span class=\"keyword\">in</span> kwargs.items())</div><div class=\"line\">        <span class=\"keyword\">if</span> self.request.method <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"HEAD\"</span>, <span class=\"string\">\"OPTIONS\"</span>) <span class=\"keyword\">and</span> \\</div><div class=\"line\">                self.application.settings.get(<span class=\"string\">\"xsrf_cookies\"</span>):</div><div class=\"line\">            self.check_xsrf_cookie()</div><div class=\"line\"></div><div class=\"line\">        result = self.prepare()</div><div class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            result = <span class=\"keyword\">yield</span> result</div><div class=\"line\">        <span class=\"keyword\">if</span> self._prepared_future <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            self._prepared_future.set_result(<span class=\"keyword\">None</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self._finished:</div><div class=\"line\">            <span class=\"keyword\">return</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> _has_stream_request_body(self.__class__):</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                <span class=\"keyword\">yield</span> self.request.body</div><div class=\"line\">            <span class=\"keyword\">except</span> iostream.StreamClosedError:</div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#调handler的具体业务逻辑处理，在子类的get/post/put/delete 方法中处理，这里就是真正调Handler的post、get等方法的地方</span></div><div class=\"line\">        method = getattr(self, self.request.method.lower())</div><div class=\"line\">        result = method(*self.path_args, **self.path_kwargs)</div><div class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            result = <span class=\"keyword\">yield</span> result</div><div class=\"line\">        <span class=\"comment\">#self.finish函数做一些善后事宜，比如释放缓冲区，关闭连接等</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self._auto_finish <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> self._finished:</div><div class=\"line\">            self.finish()</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            self._handle_request_exception(e)</div><div class=\"line\">        <span class=\"keyword\">except</span> Exception:</div><div class=\"line\">            app_log.error(<span class=\"string\">\"Exception in exception handler\"</span>, exc_info=<span class=\"keyword\">True</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> (self._prepared_future <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span> <span class=\"keyword\">and</span></div><div class=\"line\">                <span class=\"keyword\">not</span> self._prepared_future.done()):</div><div class=\"line\">            self._prepared_future.set_result(<span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>"},{"title":"Tornado源码剖析系列文章目录","date":"2016-05-04T11:26:05.000Z","toc":true,"comments":1,"_content":"\ntornado源码剖析目录。\n<!-- more -->\n\n在山人分析Tornado之前，可能有部分同学要问他，为干嘛要分析他的源码呢？我会用不久行了吗？\n那么我们就来看看我剖析Tornado源码中我们能学习到什么呢？\n\n- Tornado是Python业界比较有名的web框架，也是处理高并发的利器，那么学习了这种源码以后，对Tornado的开发将更加的得心应手。\n- Tonado几乎囊括了所有重要的网络编程模型，比如阻塞、非阻塞、异步、epoll、HTTP服务等等，在学习了Tornado之后，基本对这块就会非常的了解。\n- 我认为这是最重要的：**要提高自己，必须不断的和高手过招，逐渐混入高手的精英圈子，那么你也就是精英了，至少是半个精英。**和高手过招，是最快的提高自己的捷径，兵熊熊一个，将熊熊一窝，跟着什么人，你就会成为什么人。显然Tornado是高手的精华代码，当然是我等小辈趋之若鹜的。Tornado是Python编程的绝佳实习基地。\n\n**tornado核心模块的源码剖析目录及相应源码剖析的链接**\n\n----------\n\n\n# 核心web framework模块\n\n**[tornado.web](http://demo.pythoner.com/itt2zh/index.html):**包含绝大部分web框架的主要功能。\n**[tornado.httpserver](http://demo.pythoner.com/itt2zh/index.html):**一个无阻塞的HTTP服务器的实现，以服务web模块。\n**[tornado.template](http://demo.pythoner.com/itt2zh/index.html):**基于Python的web模块的一个模板系统。\n**[tornado.escape](http://demo.pythoner.com/itt2zh/index.html):** HTML、JSON、URLs等的编码解码和一些字符串操作。\n**[tornado.locale](http://demo.pythoner.com/itt2zh/index.html):**国际化支持，是基于本地化和翻译的支持。\n\n----------\n\n\n# 主要底层模块\n**[tornado.ioloop](http://demo.pythoner.com/itt2zh/index.html):**核心的I/O循环\n**[tornado.iostream](http://demo.pythoner.com/itt2zh/index.html):**对非阻塞式的socket的简单封装，以方便一些常用的读写操作。\n**[tornado.httpclient](http://demo.pythoner.com/itt2zh/index.html):**非阻塞式HTTP客户端，它用来和web模块、httpserver模块协同工作。\n**[tornado.netutil](http://demo.pythoner.com/itt2zh/index.html):**一些网络应用的实现，主要实现TCPServer类。\n\n----------\n\n\n# 与其他系统的交互的主要模块\n**[tornado.auth](http://demo.pythoner.com/itt2zh/index.html):**第三方认证的实现。\n**[tornado.websocket](http://demo.pythoner.com/itt2zh/index.html):**实现和浏览器的双向通信。\n**[tornado.wsgi](http://demo.pythoner.com/itt2zh/index.html):**与其他Python网络框架、服务器的互相操作。\n\n\n----------\n\n\n# 应用的时的主要模块\n**[tornado.autoreload](http://demo.pythoner.com/itt2zh/index.html):**生产环境中自动检查代码更新。\n**[tornado.gen](http://demo.pythoner.com/itt2zh/index.html):**一个基于生成器的接口，使用该模块保证代码异步运行。\n**[tornado.httputil](http://demo.pythoner.com/itt2zh/index.html):**分析HTTP请求内容。\n**[tornado.options](http://demo.pythoner.com/itt2zh/index.html):**命令行和配置文件解析工具，针对服务器环境做了优化。\n**[tornado.process](http://demo.pythoner.com/itt2zh/index.html):**多进程实现的封装。\n**[tornado.stack_context](http://demo.pythoner.com/itt2zh/index.html):**用于异步环境中对回调函数的上下文保存、异常处理。\n**[tornado.testing](http://demo.pythoner.com/itt2zh/index.html):**单元测试。\n\n\n----------\n\n# tornado源码结构\n\n```python\n├── tornado\n│   ├── auth.py\n│   ├── autoreload.py\n│   ├── concurrent.py\n│   ├── curl_httpclient.py\n│   ├── escape.py\n│   ├── gen.py\n│   ├── http1connection.py\n│   ├── httpclient.py\n│   ├── httpserver.py\n│   ├── httputil.py\n│   ├── __init__.py\n│   ├── ioloop.py\n│   ├── iostream.py\n│   ├── _locale_data.py\n│   ├── locale.py\n│   ├── locks.py\n│   ├── log.py\n│   ├── netutil.py\n│   ├── options.py\n│   ├── platform\n│   │   ├── asyncio.py\n│   │   ├── auto.py\n│   │   ├── caresresolver.py\n│   │   ├── common.py\n│   │   ├── epoll.py\n│   │   ├── __init__.py\n│   │   ├── interface.py\n│   │   ├── kqueue.py\n│   │   ├── posix.py\n│   │   ├── select.py\n│   │   ├── twisted.py\n│   │   └── windows.py\n│   ├── process.py\n│   ├── queues.py\n│   ├── simple_httpclient.py\n│   ├── speedups.c\n│   ├── stack_context.py\n│   ├── tcpclient.py\n│   ├── tcpserver.py\n│   ├── template.py\n│   ├── test\n│   │   ├── asyncio_test.py\n│   │   ├── auth_test.py\n│   │   ├── concurrent_test.py\n│   │   ├── csv_translations\n│   │   │   └── fr_FR.csv\n│   │   ├── curl_httpclient_test.py\n│   │   ├── escape_test.py\n│   │   ├── gen_test.py\n│   │   ├── gettext_translations\n│   │   │   └── fr_FR\n│   │   │       └── LC_MESSAGES\n│   │   │           ├── tornado_test.mo\n│   │   │           └── tornado_test.po\n│   │   ├── httpclient_test.py\n│   │   ├── httpserver_test.py\n│   │   ├── httputil_test.py\n│   │   ├── import_test.py\n│   │   ├── __init__.py\n│   │   ├── ioloop_test.py\n│   │   ├── iostream_test.py\n│   │   ├── locale_test.py\n│   │   ├── locks_test.py\n│   │   ├── log_test.py\n│   │   ├── __main__.py\n│   │   ├── netutil_test.py\n│   │   ├── options_test.cfg\n│   │   ├── options_test.py\n│   │   ├── process_test.py\n│   │   ├── queues_test.py\n│   │   ├── resolve_test_helper.py\n│   │   ├── runtests.py\n│   │   ├── simple_httpclient_test.py\n│   │   ├── stack_context_test.py\n│   │   ├── static\n│   │   │   ├── dir\n│   │   │   │   └── index.html\n│   │   │   ├── robots.txt\n│   │   │   ├── sample.xml\n│   │   │   ├── sample.xml.bz2\n│   │   │   └── sample.xml.gz\n│   │   ├── static_foo.txt\n│   │   ├── tcpclient_test.py\n│   │   ├── tcpserver_test.py\n│   │   ├── templates\n│   │   │   └── utf8.html\n│   │   ├── template_test.py\n│   │   ├── test.crt\n│   │   ├── testing_test.py\n│   │   ├── test.key\n│   │   ├── twisted_test.py\n│   │   ├── util.py\n│   │   ├── util_test.py\n│   │   ├── websocket_test.py\n│   │   ├── web_test.py\n│   │   └── wsgi_test.py\n│   ├── testing.py\n│   ├── util.py\n│   ├── web.py\n│   ├── websocket.py\n│   └── wsgi.py\n└── tornado_version\n```\n","source":"_posts/tornado源码剖析系列文章目录.md","raw":"---\ntitle: Tornado源码剖析系列文章目录\ndate: 2016-05-04 19:26:05\ntags: Tornado源码分析\ncategories: Tornado系列\ntoc: true\ncomments: true\n---\n\ntornado源码剖析目录。\n<!-- more -->\n\n在山人分析Tornado之前，可能有部分同学要问他，为干嘛要分析他的源码呢？我会用不久行了吗？\n那么我们就来看看我剖析Tornado源码中我们能学习到什么呢？\n\n- Tornado是Python业界比较有名的web框架，也是处理高并发的利器，那么学习了这种源码以后，对Tornado的开发将更加的得心应手。\n- Tonado几乎囊括了所有重要的网络编程模型，比如阻塞、非阻塞、异步、epoll、HTTP服务等等，在学习了Tornado之后，基本对这块就会非常的了解。\n- 我认为这是最重要的：**要提高自己，必须不断的和高手过招，逐渐混入高手的精英圈子，那么你也就是精英了，至少是半个精英。**和高手过招，是最快的提高自己的捷径，兵熊熊一个，将熊熊一窝，跟着什么人，你就会成为什么人。显然Tornado是高手的精华代码，当然是我等小辈趋之若鹜的。Tornado是Python编程的绝佳实习基地。\n\n**tornado核心模块的源码剖析目录及相应源码剖析的链接**\n\n----------\n\n\n# 核心web framework模块\n\n**[tornado.web](http://demo.pythoner.com/itt2zh/index.html):**包含绝大部分web框架的主要功能。\n**[tornado.httpserver](http://demo.pythoner.com/itt2zh/index.html):**一个无阻塞的HTTP服务器的实现，以服务web模块。\n**[tornado.template](http://demo.pythoner.com/itt2zh/index.html):**基于Python的web模块的一个模板系统。\n**[tornado.escape](http://demo.pythoner.com/itt2zh/index.html):** HTML、JSON、URLs等的编码解码和一些字符串操作。\n**[tornado.locale](http://demo.pythoner.com/itt2zh/index.html):**国际化支持，是基于本地化和翻译的支持。\n\n----------\n\n\n# 主要底层模块\n**[tornado.ioloop](http://demo.pythoner.com/itt2zh/index.html):**核心的I/O循环\n**[tornado.iostream](http://demo.pythoner.com/itt2zh/index.html):**对非阻塞式的socket的简单封装，以方便一些常用的读写操作。\n**[tornado.httpclient](http://demo.pythoner.com/itt2zh/index.html):**非阻塞式HTTP客户端，它用来和web模块、httpserver模块协同工作。\n**[tornado.netutil](http://demo.pythoner.com/itt2zh/index.html):**一些网络应用的实现，主要实现TCPServer类。\n\n----------\n\n\n# 与其他系统的交互的主要模块\n**[tornado.auth](http://demo.pythoner.com/itt2zh/index.html):**第三方认证的实现。\n**[tornado.websocket](http://demo.pythoner.com/itt2zh/index.html):**实现和浏览器的双向通信。\n**[tornado.wsgi](http://demo.pythoner.com/itt2zh/index.html):**与其他Python网络框架、服务器的互相操作。\n\n\n----------\n\n\n# 应用的时的主要模块\n**[tornado.autoreload](http://demo.pythoner.com/itt2zh/index.html):**生产环境中自动检查代码更新。\n**[tornado.gen](http://demo.pythoner.com/itt2zh/index.html):**一个基于生成器的接口，使用该模块保证代码异步运行。\n**[tornado.httputil](http://demo.pythoner.com/itt2zh/index.html):**分析HTTP请求内容。\n**[tornado.options](http://demo.pythoner.com/itt2zh/index.html):**命令行和配置文件解析工具，针对服务器环境做了优化。\n**[tornado.process](http://demo.pythoner.com/itt2zh/index.html):**多进程实现的封装。\n**[tornado.stack_context](http://demo.pythoner.com/itt2zh/index.html):**用于异步环境中对回调函数的上下文保存、异常处理。\n**[tornado.testing](http://demo.pythoner.com/itt2zh/index.html):**单元测试。\n\n\n----------\n\n# tornado源码结构\n\n```python\n├── tornado\n│   ├── auth.py\n│   ├── autoreload.py\n│   ├── concurrent.py\n│   ├── curl_httpclient.py\n│   ├── escape.py\n│   ├── gen.py\n│   ├── http1connection.py\n│   ├── httpclient.py\n│   ├── httpserver.py\n│   ├── httputil.py\n│   ├── __init__.py\n│   ├── ioloop.py\n│   ├── iostream.py\n│   ├── _locale_data.py\n│   ├── locale.py\n│   ├── locks.py\n│   ├── log.py\n│   ├── netutil.py\n│   ├── options.py\n│   ├── platform\n│   │   ├── asyncio.py\n│   │   ├── auto.py\n│   │   ├── caresresolver.py\n│   │   ├── common.py\n│   │   ├── epoll.py\n│   │   ├── __init__.py\n│   │   ├── interface.py\n│   │   ├── kqueue.py\n│   │   ├── posix.py\n│   │   ├── select.py\n│   │   ├── twisted.py\n│   │   └── windows.py\n│   ├── process.py\n│   ├── queues.py\n│   ├── simple_httpclient.py\n│   ├── speedups.c\n│   ├── stack_context.py\n│   ├── tcpclient.py\n│   ├── tcpserver.py\n│   ├── template.py\n│   ├── test\n│   │   ├── asyncio_test.py\n│   │   ├── auth_test.py\n│   │   ├── concurrent_test.py\n│   │   ├── csv_translations\n│   │   │   └── fr_FR.csv\n│   │   ├── curl_httpclient_test.py\n│   │   ├── escape_test.py\n│   │   ├── gen_test.py\n│   │   ├── gettext_translations\n│   │   │   └── fr_FR\n│   │   │       └── LC_MESSAGES\n│   │   │           ├── tornado_test.mo\n│   │   │           └── tornado_test.po\n│   │   ├── httpclient_test.py\n│   │   ├── httpserver_test.py\n│   │   ├── httputil_test.py\n│   │   ├── import_test.py\n│   │   ├── __init__.py\n│   │   ├── ioloop_test.py\n│   │   ├── iostream_test.py\n│   │   ├── locale_test.py\n│   │   ├── locks_test.py\n│   │   ├── log_test.py\n│   │   ├── __main__.py\n│   │   ├── netutil_test.py\n│   │   ├── options_test.cfg\n│   │   ├── options_test.py\n│   │   ├── process_test.py\n│   │   ├── queues_test.py\n│   │   ├── resolve_test_helper.py\n│   │   ├── runtests.py\n│   │   ├── simple_httpclient_test.py\n│   │   ├── stack_context_test.py\n│   │   ├── static\n│   │   │   ├── dir\n│   │   │   │   └── index.html\n│   │   │   ├── robots.txt\n│   │   │   ├── sample.xml\n│   │   │   ├── sample.xml.bz2\n│   │   │   └── sample.xml.gz\n│   │   ├── static_foo.txt\n│   │   ├── tcpclient_test.py\n│   │   ├── tcpserver_test.py\n│   │   ├── templates\n│   │   │   └── utf8.html\n│   │   ├── template_test.py\n│   │   ├── test.crt\n│   │   ├── testing_test.py\n│   │   ├── test.key\n│   │   ├── twisted_test.py\n│   │   ├── util.py\n│   │   ├── util_test.py\n│   │   ├── websocket_test.py\n│   │   ├── web_test.py\n│   │   └── wsgi_test.py\n│   ├── testing.py\n│   ├── util.py\n│   ├── web.py\n│   ├── websocket.py\n│   └── wsgi.py\n└── tornado_version\n```\n","slug":"tornado源码剖析系列文章目录","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoiroo8000gta025wyum7u3","content":"<p>tornado源码剖析目录。<br><a id=\"more\"></a></p>\n<p>在山人分析Tornado之前，可能有部分同学要问他，为干嘛要分析他的源码呢？我会用不久行了吗？<br>那么我们就来看看我剖析Tornado源码中我们能学习到什么呢？</p>\n<ul>\n<li>Tornado是Python业界比较有名的web框架，也是处理高并发的利器，那么学习了这种源码以后，对Tornado的开发将更加的得心应手。</li>\n<li>Tonado几乎囊括了所有重要的网络编程模型，比如阻塞、非阻塞、异步、epoll、HTTP服务等等，在学习了Tornado之后，基本对这块就会非常的了解。</li>\n<li>我认为这是最重要的：<strong>要提高自己，必须不断的和高手过招，逐渐混入高手的精英圈子，那么你也就是精英了，至少是半个精英。</strong>和高手过招，是最快的提高自己的捷径，兵熊熊一个，将熊熊一窝，跟着什么人，你就会成为什么人。显然Tornado是高手的精华代码，当然是我等小辈趋之若鹜的。Tornado是Python编程的绝佳实习基地。</li>\n</ul>\n<p><strong>tornado核心模块的源码剖析目录及相应源码剖析的链接</strong></p>\n<hr>\n<h1 id=\"核心web-framework模块\"><a href=\"#核心web-framework模块\" class=\"headerlink\" title=\"核心web framework模块\"></a>核心web framework模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.web</a>:</strong>包含绝大部分web框架的主要功能。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.httpserver</a>:</strong>一个无阻塞的HTTP服务器的实现，以服务web模块。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.template</a>:</strong>基于Python的web模块的一个模板系统。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.escape</a>:</strong> HTML、JSON、URLs等的编码解码和一些字符串操作。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.locale</a>:</strong>国际化支持，是基于本地化和翻译的支持。</p>\n<hr>\n<h1 id=\"主要底层模块\"><a href=\"#主要底层模块\" class=\"headerlink\" title=\"主要底层模块\"></a>主要底层模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.ioloop</a>:</strong>核心的I/O循环<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.iostream</a>:</strong>对非阻塞式的socket的简单封装，以方便一些常用的读写操作。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.httpclient</a>:</strong>非阻塞式HTTP客户端，它用来和web模块、httpserver模块协同工作。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.netutil</a>:</strong>一些网络应用的实现，主要实现TCPServer类。</p>\n<hr>\n<h1 id=\"与其他系统的交互的主要模块\"><a href=\"#与其他系统的交互的主要模块\" class=\"headerlink\" title=\"与其他系统的交互的主要模块\"></a>与其他系统的交互的主要模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.auth</a>:</strong>第三方认证的实现。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.websocket</a>:</strong>实现和浏览器的双向通信。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.wsgi</a>:</strong>与其他Python网络框架、服务器的互相操作。</p>\n<hr>\n<h1 id=\"应用的时的主要模块\"><a href=\"#应用的时的主要模块\" class=\"headerlink\" title=\"应用的时的主要模块\"></a>应用的时的主要模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.autoreload</a>:</strong>生产环境中自动检查代码更新。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.gen</a>:</strong>一个基于生成器的接口，使用该模块保证代码异步运行。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.httputil</a>:</strong>分析HTTP请求内容。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.options</a>:</strong>命令行和配置文件解析工具，针对服务器环境做了优化。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.process</a>:</strong>多进程实现的封装。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.stack_context</a>:</strong>用于异步环境中对回调函数的上下文保存、异常处理。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\" target=\"_blank\" rel=\"external\">tornado.testing</a>:</strong>单元测试。</p>\n<hr>\n<h1 id=\"tornado源码结构\"><a href=\"#tornado源码结构\" class=\"headerlink\" title=\"tornado源码结构\"></a>tornado源码结构</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── tornado</div><div class=\"line\">│   ├── auth.py</div><div class=\"line\">│   ├── autoreload.py</div><div class=\"line\">│   ├── concurrent.py</div><div class=\"line\">│   ├── curl_httpclient.py</div><div class=\"line\">│   ├── escape.py</div><div class=\"line\">│   ├── gen.py</div><div class=\"line\">│   ├── http1connection.py</div><div class=\"line\">│   ├── httpclient.py</div><div class=\"line\">│   ├── httpserver.py</div><div class=\"line\">│   ├── httputil.py</div><div class=\"line\">│   ├── __init__.py</div><div class=\"line\">│   ├── ioloop.py</div><div class=\"line\">│   ├── iostream.py</div><div class=\"line\">│   ├── _locale_data.py</div><div class=\"line\">│   ├── locale.py</div><div class=\"line\">│   ├── locks.py</div><div class=\"line\">│   ├── log.py</div><div class=\"line\">│   ├── netutil.py</div><div class=\"line\">│   ├── options.py</div><div class=\"line\">│   ├── platform</div><div class=\"line\">│   │   ├── asyncio.py</div><div class=\"line\">│   │   ├── auto.py</div><div class=\"line\">│   │   ├── caresresolver.py</div><div class=\"line\">│   │   ├── common.py</div><div class=\"line\">│   │   ├── epoll.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── interface.py</div><div class=\"line\">│   │   ├── kqueue.py</div><div class=\"line\">│   │   ├── posix.py</div><div class=\"line\">│   │   ├── select.py</div><div class=\"line\">│   │   ├── twisted.py</div><div class=\"line\">│   │   └── windows.py</div><div class=\"line\">│   ├── process.py</div><div class=\"line\">│   ├── queues.py</div><div class=\"line\">│   ├── simple_httpclient.py</div><div class=\"line\">│   ├── speedups.c</div><div class=\"line\">│   ├── stack_context.py</div><div class=\"line\">│   ├── tcpclient.py</div><div class=\"line\">│   ├── tcpserver.py</div><div class=\"line\">│   ├── template.py</div><div class=\"line\">│   ├── test</div><div class=\"line\">│   │   ├── asyncio_test.py</div><div class=\"line\">│   │   ├── auth_test.py</div><div class=\"line\">│   │   ├── concurrent_test.py</div><div class=\"line\">│   │   ├── csv_translations</div><div class=\"line\">│   │   │   └── fr_FR.csv</div><div class=\"line\">│   │   ├── curl_httpclient_test.py</div><div class=\"line\">│   │   ├── escape_test.py</div><div class=\"line\">│   │   ├── gen_test.py</div><div class=\"line\">│   │   ├── gettext_translations</div><div class=\"line\">│   │   │   └── fr_FR</div><div class=\"line\">│   │   │       └── LC_MESSAGES</div><div class=\"line\">│   │   │           ├── tornado_test.mo</div><div class=\"line\">│   │   │           └── tornado_test.po</div><div class=\"line\">│   │   ├── httpclient_test.py</div><div class=\"line\">│   │   ├── httpserver_test.py</div><div class=\"line\">│   │   ├── httputil_test.py</div><div class=\"line\">│   │   ├── import_test.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── ioloop_test.py</div><div class=\"line\">│   │   ├── iostream_test.py</div><div class=\"line\">│   │   ├── locale_test.py</div><div class=\"line\">│   │   ├── locks_test.py</div><div class=\"line\">│   │   ├── log_test.py</div><div class=\"line\">│   │   ├── __main__.py</div><div class=\"line\">│   │   ├── netutil_test.py</div><div class=\"line\">│   │   ├── options_test.cfg</div><div class=\"line\">│   │   ├── options_test.py</div><div class=\"line\">│   │   ├── process_test.py</div><div class=\"line\">│   │   ├── queues_test.py</div><div class=\"line\">│   │   ├── resolve_test_helper.py</div><div class=\"line\">│   │   ├── runtests.py</div><div class=\"line\">│   │   ├── simple_httpclient_test.py</div><div class=\"line\">│   │   ├── stack_context_test.py</div><div class=\"line\">│   │   ├── static</div><div class=\"line\">│   │   │   ├── dir</div><div class=\"line\">│   │   │   │   └── index.html</div><div class=\"line\">│   │   │   ├── robots.txt</div><div class=\"line\">│   │   │   ├── sample.xml</div><div class=\"line\">│   │   │   ├── sample.xml.bz2</div><div class=\"line\">│   │   │   └── sample.xml.gz</div><div class=\"line\">│   │   ├── static_foo.txt</div><div class=\"line\">│   │   ├── tcpclient_test.py</div><div class=\"line\">│   │   ├── tcpserver_test.py</div><div class=\"line\">│   │   ├── templates</div><div class=\"line\">│   │   │   └── utf8.html</div><div class=\"line\">│   │   ├── template_test.py</div><div class=\"line\">│   │   ├── test.crt</div><div class=\"line\">│   │   ├── testing_test.py</div><div class=\"line\">│   │   ├── test.key</div><div class=\"line\">│   │   ├── twisted_test.py</div><div class=\"line\">│   │   ├── util.py</div><div class=\"line\">│   │   ├── util_test.py</div><div class=\"line\">│   │   ├── websocket_test.py</div><div class=\"line\">│   │   ├── web_test.py</div><div class=\"line\">│   │   └── wsgi_test.py</div><div class=\"line\">│   ├── testing.py</div><div class=\"line\">│   ├── util.py</div><div class=\"line\">│   ├── web.py</div><div class=\"line\">│   ├── websocket.py</div><div class=\"line\">│   └── wsgi.py</div><div class=\"line\">└── tornado_version</div></pre></td></tr></table></figure>\n","excerpt":"<p>tornado源码剖析目录。<br>","more":"</p>\n<p>在山人分析Tornado之前，可能有部分同学要问他，为干嘛要分析他的源码呢？我会用不久行了吗？<br>那么我们就来看看我剖析Tornado源码中我们能学习到什么呢？</p>\n<ul>\n<li>Tornado是Python业界比较有名的web框架，也是处理高并发的利器，那么学习了这种源码以后，对Tornado的开发将更加的得心应手。</li>\n<li>Tonado几乎囊括了所有重要的网络编程模型，比如阻塞、非阻塞、异步、epoll、HTTP服务等等，在学习了Tornado之后，基本对这块就会非常的了解。</li>\n<li>我认为这是最重要的：<strong>要提高自己，必须不断的和高手过招，逐渐混入高手的精英圈子，那么你也就是精英了，至少是半个精英。</strong>和高手过招，是最快的提高自己的捷径，兵熊熊一个，将熊熊一窝，跟着什么人，你就会成为什么人。显然Tornado是高手的精华代码，当然是我等小辈趋之若鹜的。Tornado是Python编程的绝佳实习基地。</li>\n</ul>\n<p><strong>tornado核心模块的源码剖析目录及相应源码剖析的链接</strong></p>\n<hr>\n<h1 id=\"核心web-framework模块\"><a href=\"#核心web-framework模块\" class=\"headerlink\" title=\"核心web framework模块\"></a>核心web framework模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.web</a>:</strong>包含绝大部分web框架的主要功能。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.httpserver</a>:</strong>一个无阻塞的HTTP服务器的实现，以服务web模块。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.template</a>:</strong>基于Python的web模块的一个模板系统。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.escape</a>:</strong> HTML、JSON、URLs等的编码解码和一些字符串操作。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.locale</a>:</strong>国际化支持，是基于本地化和翻译的支持。</p>\n<hr>\n<h1 id=\"主要底层模块\"><a href=\"#主要底层模块\" class=\"headerlink\" title=\"主要底层模块\"></a>主要底层模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.ioloop</a>:</strong>核心的I/O循环<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.iostream</a>:</strong>对非阻塞式的socket的简单封装，以方便一些常用的读写操作。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.httpclient</a>:</strong>非阻塞式HTTP客户端，它用来和web模块、httpserver模块协同工作。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.netutil</a>:</strong>一些网络应用的实现，主要实现TCPServer类。</p>\n<hr>\n<h1 id=\"与其他系统的交互的主要模块\"><a href=\"#与其他系统的交互的主要模块\" class=\"headerlink\" title=\"与其他系统的交互的主要模块\"></a>与其他系统的交互的主要模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.auth</a>:</strong>第三方认证的实现。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.websocket</a>:</strong>实现和浏览器的双向通信。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.wsgi</a>:</strong>与其他Python网络框架、服务器的互相操作。</p>\n<hr>\n<h1 id=\"应用的时的主要模块\"><a href=\"#应用的时的主要模块\" class=\"headerlink\" title=\"应用的时的主要模块\"></a>应用的时的主要模块</h1><p><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.autoreload</a>:</strong>生产环境中自动检查代码更新。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.gen</a>:</strong>一个基于生成器的接口，使用该模块保证代码异步运行。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.httputil</a>:</strong>分析HTTP请求内容。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.options</a>:</strong>命令行和配置文件解析工具，针对服务器环境做了优化。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.process</a>:</strong>多进程实现的封装。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.stack_context</a>:</strong>用于异步环境中对回调函数的上下文保存、异常处理。<br><strong><a href=\"http://demo.pythoner.com/itt2zh/index.html\">tornado.testing</a>:</strong>单元测试。</p>\n<hr>\n<h1 id=\"tornado源码结构\"><a href=\"#tornado源码结构\" class=\"headerlink\" title=\"tornado源码结构\"></a>tornado源码结构</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── tornado</div><div class=\"line\">│   ├── auth.py</div><div class=\"line\">│   ├── autoreload.py</div><div class=\"line\">│   ├── concurrent.py</div><div class=\"line\">│   ├── curl_httpclient.py</div><div class=\"line\">│   ├── escape.py</div><div class=\"line\">│   ├── gen.py</div><div class=\"line\">│   ├── http1connection.py</div><div class=\"line\">│   ├── httpclient.py</div><div class=\"line\">│   ├── httpserver.py</div><div class=\"line\">│   ├── httputil.py</div><div class=\"line\">│   ├── __init__.py</div><div class=\"line\">│   ├── ioloop.py</div><div class=\"line\">│   ├── iostream.py</div><div class=\"line\">│   ├── _locale_data.py</div><div class=\"line\">│   ├── locale.py</div><div class=\"line\">│   ├── locks.py</div><div class=\"line\">│   ├── log.py</div><div class=\"line\">│   ├── netutil.py</div><div class=\"line\">│   ├── options.py</div><div class=\"line\">│   ├── platform</div><div class=\"line\">│   │   ├── asyncio.py</div><div class=\"line\">│   │   ├── auto.py</div><div class=\"line\">│   │   ├── caresresolver.py</div><div class=\"line\">│   │   ├── common.py</div><div class=\"line\">│   │   ├── epoll.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── interface.py</div><div class=\"line\">│   │   ├── kqueue.py</div><div class=\"line\">│   │   ├── posix.py</div><div class=\"line\">│   │   ├── select.py</div><div class=\"line\">│   │   ├── twisted.py</div><div class=\"line\">│   │   └── windows.py</div><div class=\"line\">│   ├── process.py</div><div class=\"line\">│   ├── queues.py</div><div class=\"line\">│   ├── simple_httpclient.py</div><div class=\"line\">│   ├── speedups.c</div><div class=\"line\">│   ├── stack_context.py</div><div class=\"line\">│   ├── tcpclient.py</div><div class=\"line\">│   ├── tcpserver.py</div><div class=\"line\">│   ├── template.py</div><div class=\"line\">│   ├── test</div><div class=\"line\">│   │   ├── asyncio_test.py</div><div class=\"line\">│   │   ├── auth_test.py</div><div class=\"line\">│   │   ├── concurrent_test.py</div><div class=\"line\">│   │   ├── csv_translations</div><div class=\"line\">│   │   │   └── fr_FR.csv</div><div class=\"line\">│   │   ├── curl_httpclient_test.py</div><div class=\"line\">│   │   ├── escape_test.py</div><div class=\"line\">│   │   ├── gen_test.py</div><div class=\"line\">│   │   ├── gettext_translations</div><div class=\"line\">│   │   │   └── fr_FR</div><div class=\"line\">│   │   │       └── LC_MESSAGES</div><div class=\"line\">│   │   │           ├── tornado_test.mo</div><div class=\"line\">│   │   │           └── tornado_test.po</div><div class=\"line\">│   │   ├── httpclient_test.py</div><div class=\"line\">│   │   ├── httpserver_test.py</div><div class=\"line\">│   │   ├── httputil_test.py</div><div class=\"line\">│   │   ├── import_test.py</div><div class=\"line\">│   │   ├── __init__.py</div><div class=\"line\">│   │   ├── ioloop_test.py</div><div class=\"line\">│   │   ├── iostream_test.py</div><div class=\"line\">│   │   ├── locale_test.py</div><div class=\"line\">│   │   ├── locks_test.py</div><div class=\"line\">│   │   ├── log_test.py</div><div class=\"line\">│   │   ├── __main__.py</div><div class=\"line\">│   │   ├── netutil_test.py</div><div class=\"line\">│   │   ├── options_test.cfg</div><div class=\"line\">│   │   ├── options_test.py</div><div class=\"line\">│   │   ├── process_test.py</div><div class=\"line\">│   │   ├── queues_test.py</div><div class=\"line\">│   │   ├── resolve_test_helper.py</div><div class=\"line\">│   │   ├── runtests.py</div><div class=\"line\">│   │   ├── simple_httpclient_test.py</div><div class=\"line\">│   │   ├── stack_context_test.py</div><div class=\"line\">│   │   ├── static</div><div class=\"line\">│   │   │   ├── dir</div><div class=\"line\">│   │   │   │   └── index.html</div><div class=\"line\">│   │   │   ├── robots.txt</div><div class=\"line\">│   │   │   ├── sample.xml</div><div class=\"line\">│   │   │   ├── sample.xml.bz2</div><div class=\"line\">│   │   │   └── sample.xml.gz</div><div class=\"line\">│   │   ├── static_foo.txt</div><div class=\"line\">│   │   ├── tcpclient_test.py</div><div class=\"line\">│   │   ├── tcpserver_test.py</div><div class=\"line\">│   │   ├── templates</div><div class=\"line\">│   │   │   └── utf8.html</div><div class=\"line\">│   │   ├── template_test.py</div><div class=\"line\">│   │   ├── test.crt</div><div class=\"line\">│   │   ├── testing_test.py</div><div class=\"line\">│   │   ├── test.key</div><div class=\"line\">│   │   ├── twisted_test.py</div><div class=\"line\">│   │   ├── util.py</div><div class=\"line\">│   │   ├── util_test.py</div><div class=\"line\">│   │   ├── websocket_test.py</div><div class=\"line\">│   │   ├── web_test.py</div><div class=\"line\">│   │   └── wsgi_test.py</div><div class=\"line\">│   ├── testing.py</div><div class=\"line\">│   ├── util.py</div><div class=\"line\">│   ├── web.py</div><div class=\"line\">│   ├── websocket.py</div><div class=\"line\">│   └── wsgi.py</div><div class=\"line\">└── tornado_version</div></pre></td></tr></table></figure>"},{"title":"Tornado源码之handler","date":"2016-05-13T03:49:52.000Z","toc":true,"comments":1,"_content":"\n\n在深度聊tornado之前，我们先要聊聊torndao中非常重要的handler。\n<!-- more -->\n\n\n# 重提hello world\n\n我们在[tornado简历](http://lingyue.github.io/2016/05/04/tornado%E7%9A%84%E7%AE%80%E5%8E%86/)一文中曾重点介绍过程序员世界经典的的hello world，本文将旧事重提，再次介绍torndao的hello world，以便管中窥豹，一叶知秋去了解torndao和一般的tornado应用程序的代码结构，以及本文的重点heandler。\n\n下面的hello world是我在tornado中的demos中获取的，torndao的demos自带有很多经典的demo：\n\n```python\n#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n\nfrom tornado.options import define, options\n\ndefine(\"port\", default=8888, help=\"run on the given port\", type=int)\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\n\ndef main():\n    tornado.options.parse_command_line()\n    application = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n    http_server = tornado.httpserver.HTTPServer(application)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n - **xxHandler类型的函数：** xxHandler主要是针对映射的url的一些具体的实现。\n - **main函数说明：** 应用程序执行的时候，会先创建一个Application实例并传递给HTTPServer实例，之后启动这个实例，此时，http server就启动了。tornado.httpserver模块用来支持非阻塞的HTTP Server。启动服务器后，接下来就是启动IOLoop实例了，IOLoop主要是一个事件循环机制，配合非阻塞的HTTP Server工作，后面会详细解决。\n - **Application：** 这个是tornado中一个男二号，很重要的一个模块，定义在web.py中，后面我们会深入的分析这个模块的。torndao中解释，Application类实际上是一个Handler的集合，这些Handler组成了一个web应用程序的。\n\n# torndao中的handler\n\ntorndao中的handler其实就是Django中的View层的函数，即MVC模式中的V层，是真正处理一些用户的请求，并根据用户的请求，返回用户所需要的信息的函数，可以理解为tornado一个真正干活的地方。\n\n我们知道，当你在浏览器中打来一个网站的时候，他会提交一个URL，表示“把这个地址的数据给我”，当然这中间涉及到DNS解析等各种中间环节才能到你服务器，此处略去。你这个url的数据可能是一个网页，如https://tornado/index.htm；可能是一张图片，如https://tornaado/tornado.png。这些数据传递给浏览器的时候，经过浏览器的渲染，就是你所看到的网站的东西。\n对于每个url，应用服务可以设置一个handler来处理，如https://tornado/index.htm请求就交给handler_1_htm来处理；https://tornaado/tornado.png就交给handler_2_png来处理，这些handler函数的作用就是负责根据客户端的请求的内容通过http协议返回给客户端。**这就是tornado中的handler。**\n\n这些handler相对于静态网页而言，就很有优势了，可以动态展示，比如根据每个人的工号，从数据库中取出这个人的基本信息展示在浏览器，没个人看到的网页都是不一样的，就是说就成动态的了。其实torndao开发网站，绝大多数时候，其实都是在开发handler。\n\n至于URL如何和handler对应起来，这就是所谓的映射需要干的活，如hello中就是通过：\n```python\napplication = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n```\n这样每个请求url和handler组成一个tuple，如**(r\"/\", MainHandler)**，就把handler与用户请求之间的映射关系建立起来了，显然Application的handlers是一个list，每个list中的元素是一个tuple，这样组成了handler和url的映射map。\n上述中的tuple表示，当用户请求根目录的时候，就请MainHandler这个handler来处理了，你所在浏览器中看到的结果，就是MainHandler处理的结果了。\n\n当然，不是说每个浏览器地址栏中的url并不一定表示这个服务器上一定有这个文件，它可以是web服务器虚拟映射的一个路径。\n\n以上就是Handler的主要介绍，看看，其实handler还是蛮简单的嘛。雄关漫步真如铁，而今漫步从头越，加油，少年！\n学Python，我们是认真的。\n\n\n","source":"_posts/聊聊tornado源码之前奏曲-深入了解handler.md","raw":"---\ntitle: Tornado源码之handler\ndate: 2016-05-13 11:49:52\ntags: Tornado源码分析\ncategories: Tornado系列\ntoc: true\ncomments: true\n---\n\n\n在深度聊tornado之前，我们先要聊聊torndao中非常重要的handler。\n<!-- more -->\n\n\n# 重提hello world\n\n我们在[tornado简历](http://lingyue.github.io/2016/05/04/tornado%E7%9A%84%E7%AE%80%E5%8E%86/)一文中曾重点介绍过程序员世界经典的的hello world，本文将旧事重提，再次介绍torndao的hello world，以便管中窥豹，一叶知秋去了解torndao和一般的tornado应用程序的代码结构，以及本文的重点heandler。\n\n下面的hello world是我在tornado中的demos中获取的，torndao的demos自带有很多经典的demo：\n\n```python\n#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n\nfrom tornado.options import define, options\n\ndefine(\"port\", default=8888, help=\"run on the given port\", type=int)\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\n\ndef main():\n    tornado.options.parse_command_line()\n    application = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n    http_server = tornado.httpserver.HTTPServer(application)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n - **xxHandler类型的函数：** xxHandler主要是针对映射的url的一些具体的实现。\n - **main函数说明：** 应用程序执行的时候，会先创建一个Application实例并传递给HTTPServer实例，之后启动这个实例，此时，http server就启动了。tornado.httpserver模块用来支持非阻塞的HTTP Server。启动服务器后，接下来就是启动IOLoop实例了，IOLoop主要是一个事件循环机制，配合非阻塞的HTTP Server工作，后面会详细解决。\n - **Application：** 这个是tornado中一个男二号，很重要的一个模块，定义在web.py中，后面我们会深入的分析这个模块的。torndao中解释，Application类实际上是一个Handler的集合，这些Handler组成了一个web应用程序的。\n\n# torndao中的handler\n\ntorndao中的handler其实就是Django中的View层的函数，即MVC模式中的V层，是真正处理一些用户的请求，并根据用户的请求，返回用户所需要的信息的函数，可以理解为tornado一个真正干活的地方。\n\n我们知道，当你在浏览器中打来一个网站的时候，他会提交一个URL，表示“把这个地址的数据给我”，当然这中间涉及到DNS解析等各种中间环节才能到你服务器，此处略去。你这个url的数据可能是一个网页，如https://tornado/index.htm；可能是一张图片，如https://tornaado/tornado.png。这些数据传递给浏览器的时候，经过浏览器的渲染，就是你所看到的网站的东西。\n对于每个url，应用服务可以设置一个handler来处理，如https://tornado/index.htm请求就交给handler_1_htm来处理；https://tornaado/tornado.png就交给handler_2_png来处理，这些handler函数的作用就是负责根据客户端的请求的内容通过http协议返回给客户端。**这就是tornado中的handler。**\n\n这些handler相对于静态网页而言，就很有优势了，可以动态展示，比如根据每个人的工号，从数据库中取出这个人的基本信息展示在浏览器，没个人看到的网页都是不一样的，就是说就成动态的了。其实torndao开发网站，绝大多数时候，其实都是在开发handler。\n\n至于URL如何和handler对应起来，这就是所谓的映射需要干的活，如hello中就是通过：\n```python\napplication = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n```\n这样每个请求url和handler组成一个tuple，如**(r\"/\", MainHandler)**，就把handler与用户请求之间的映射关系建立起来了，显然Application的handlers是一个list，每个list中的元素是一个tuple，这样组成了handler和url的映射map。\n上述中的tuple表示，当用户请求根目录的时候，就请MainHandler这个handler来处理了，你所在浏览器中看到的结果，就是MainHandler处理的结果了。\n\n当然，不是说每个浏览器地址栏中的url并不一定表示这个服务器上一定有这个文件，它可以是web服务器虚拟映射的一个路径。\n\n以上就是Handler的主要介绍，看看，其实handler还是蛮简单的嘛。雄关漫步真如铁，而今漫步从头越，加油，少年！\n学Python，我们是认真的。\n\n\n","slug":"聊聊tornado源码之前奏曲-深入了解handler","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoiroob000jta02rw8hq7us","content":"<p>在深度聊tornado之前，我们先要聊聊torndao中非常重要的handler。<br><a id=\"more\"></a></p>\n<h1 id=\"重提hello-world\"><a href=\"#重提hello-world\" class=\"headerlink\" title=\"重提hello world\"></a>重提hello world</h1><p>我们在<a href=\"http://lingyue.github.io/2016/05/04/tornado%E7%9A%84%E7%AE%80%E5%8E%86/\" target=\"_blank\" rel=\"external\">tornado简历</a>一文中曾重点介绍过程序员世界经典的的hello world，本文将旧事重提，再次介绍torndao的hello world，以便管中窥豹，一叶知秋去了解torndao和一般的tornado应用程序的代码结构，以及本文的重点heandler。</p>\n<p>下面的hello world是我在tornado中的demos中获取的，torndao的demos自带有很多经典的demo：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#</span></div><div class=\"line\"><span class=\"comment\"># Copyright 2009 Facebook</span></div><div class=\"line\"><span class=\"comment\">#</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> tornado.httpserver</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.ioloop</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.options</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.web</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> tornado.options <span class=\"keyword\">import</span> define, options</div><div class=\"line\"></div><div class=\"line\">define(<span class=\"string\">\"port\"</span>, default=<span class=\"number\">8888</span>, help=<span class=\"string\">\"run on the given port\"</span>, type=int)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainHandler</span><span class=\"params\">(tornado.web.RequestHandler)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.write(<span class=\"string\">\"Hello, world\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    tornado.options.parse_command_line()</div><div class=\"line\">    application = tornado.web.Application([</div><div class=\"line\">        (<span class=\"string\">r\"/\"</span>, MainHandler),</div><div class=\"line\">    ])</div><div class=\"line\">    http_server = tornado.httpserver.HTTPServer(application)</div><div class=\"line\">    http_server.listen(options.port)</div><div class=\"line\">    tornado.ioloop.IOLoop.current().start()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>xxHandler类型的函数：</strong> xxHandler主要是针对映射的url的一些具体的实现。</li>\n<li><strong>main函数说明：</strong> 应用程序执行的时候，会先创建一个Application实例并传递给HTTPServer实例，之后启动这个实例，此时，http server就启动了。tornado.httpserver模块用来支持非阻塞的HTTP Server。启动服务器后，接下来就是启动IOLoop实例了，IOLoop主要是一个事件循环机制，配合非阻塞的HTTP Server工作，后面会详细解决。</li>\n<li><strong>Application：</strong> 这个是tornado中一个男二号，很重要的一个模块，定义在web.py中，后面我们会深入的分析这个模块的。torndao中解释，Application类实际上是一个Handler的集合，这些Handler组成了一个web应用程序的。</li>\n</ul>\n<h1 id=\"torndao中的handler\"><a href=\"#torndao中的handler\" class=\"headerlink\" title=\"torndao中的handler\"></a>torndao中的handler</h1><p>torndao中的handler其实就是Django中的View层的函数，即MVC模式中的V层，是真正处理一些用户的请求，并根据用户的请求，返回用户所需要的信息的函数，可以理解为tornado一个真正干活的地方。</p>\n<p>我们知道，当你在浏览器中打来一个网站的时候，他会提交一个URL，表示“把这个地址的数据给我”，当然这中间涉及到DNS解析等各种中间环节才能到你服务器，此处略去。你这个url的数据可能是一个网页，如<a href=\"https://tornado/index.htm；可能是一张图片，如https://tornaado/tornado.png。这些数据传递给浏览器的时候，经过浏览器的渲染，就是你所看到的网站的东西。\" target=\"_blank\" rel=\"external\">https://tornado/index.htm；可能是一张图片，如https://tornaado/tornado.png。这些数据传递给浏览器的时候，经过浏览器的渲染，就是你所看到的网站的东西。</a><br>对于每个url，应用服务可以设置一个handler来处理，如<a href=\"https://tornado/index.htm请求就交给handler_1_htm来处理；https://tornaado/tornado.png就交给handler_2_png来处理，这些handler函数的作用就是负责根据客户端的请求的内容通过http协议返回给客户端。**这就是tornado中的handler。**\" target=\"_blank\" rel=\"external\">https://tornado/index.htm请求就交给handler_1_htm来处理；https://tornaado/tornado.png就交给handler_2_png来处理，这些handler函数的作用就是负责根据客户端的请求的内容通过http协议返回给客户端。**这就是tornado中的handler。**</a></p>\n<p>这些handler相对于静态网页而言，就很有优势了，可以动态展示，比如根据每个人的工号，从数据库中取出这个人的基本信息展示在浏览器，没个人看到的网页都是不一样的，就是说就成动态的了。其实torndao开发网站，绝大多数时候，其实都是在开发handler。</p>\n<p>至于URL如何和handler对应起来，这就是所谓的映射需要干的活，如hello中就是通过：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = tornado.web.Application([</div><div class=\"line\">        (<span class=\"string\">r\"/\"</span>, MainHandler),</div><div class=\"line\">    ])</div></pre></td></tr></table></figure></p>\n<p>这样每个请求url和handler组成一个tuple，如<strong>(r”/“, MainHandler)</strong>，就把handler与用户请求之间的映射关系建立起来了，显然Application的handlers是一个list，每个list中的元素是一个tuple，这样组成了handler和url的映射map。<br>上述中的tuple表示，当用户请求根目录的时候，就请MainHandler这个handler来处理了，你所在浏览器中看到的结果，就是MainHandler处理的结果了。</p>\n<p>当然，不是说每个浏览器地址栏中的url并不一定表示这个服务器上一定有这个文件，它可以是web服务器虚拟映射的一个路径。</p>\n<p>以上就是Handler的主要介绍，看看，其实handler还是蛮简单的嘛。雄关漫步真如铁，而今漫步从头越，加油，少年！<br>学Python，我们是认真的。</p>\n","excerpt":"<p>在深度聊tornado之前，我们先要聊聊torndao中非常重要的handler。<br>","more":"</p>\n<h1 id=\"重提hello-world\"><a href=\"#重提hello-world\" class=\"headerlink\" title=\"重提hello world\"></a>重提hello world</h1><p>我们在<a href=\"http://lingyue.github.io/2016/05/04/tornado%E7%9A%84%E7%AE%80%E5%8E%86/\">tornado简历</a>一文中曾重点介绍过程序员世界经典的的hello world，本文将旧事重提，再次介绍torndao的hello world，以便管中窥豹，一叶知秋去了解torndao和一般的tornado应用程序的代码结构，以及本文的重点heandler。</p>\n<p>下面的hello world是我在tornado中的demos中获取的，torndao的demos自带有很多经典的demo：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"comment\">#</span></div><div class=\"line\"><span class=\"comment\"># Copyright 2009 Facebook</span></div><div class=\"line\"><span class=\"comment\">#</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> tornado.httpserver</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.ioloop</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.options</div><div class=\"line\"><span class=\"keyword\">import</span> tornado.web</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> tornado.options <span class=\"keyword\">import</span> define, options</div><div class=\"line\"></div><div class=\"line\">define(<span class=\"string\">\"port\"</span>, default=<span class=\"number\">8888</span>, help=<span class=\"string\">\"run on the given port\"</span>, type=int)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainHandler</span><span class=\"params\">(tornado.web.RequestHandler)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.write(<span class=\"string\">\"Hello, world\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    tornado.options.parse_command_line()</div><div class=\"line\">    application = tornado.web.Application([</div><div class=\"line\">        (<span class=\"string\">r\"/\"</span>, MainHandler),</div><div class=\"line\">    ])</div><div class=\"line\">    http_server = tornado.httpserver.HTTPServer(application)</div><div class=\"line\">    http_server.listen(options.port)</div><div class=\"line\">    tornado.ioloop.IOLoop.current().start()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>xxHandler类型的函数：</strong> xxHandler主要是针对映射的url的一些具体的实现。</li>\n<li><strong>main函数说明：</strong> 应用程序执行的时候，会先创建一个Application实例并传递给HTTPServer实例，之后启动这个实例，此时，http server就启动了。tornado.httpserver模块用来支持非阻塞的HTTP Server。启动服务器后，接下来就是启动IOLoop实例了，IOLoop主要是一个事件循环机制，配合非阻塞的HTTP Server工作，后面会详细解决。</li>\n<li><strong>Application：</strong> 这个是tornado中一个男二号，很重要的一个模块，定义在web.py中，后面我们会深入的分析这个模块的。torndao中解释，Application类实际上是一个Handler的集合，这些Handler组成了一个web应用程序的。</li>\n</ul>\n<h1 id=\"torndao中的handler\"><a href=\"#torndao中的handler\" class=\"headerlink\" title=\"torndao中的handler\"></a>torndao中的handler</h1><p>torndao中的handler其实就是Django中的View层的函数，即MVC模式中的V层，是真正处理一些用户的请求，并根据用户的请求，返回用户所需要的信息的函数，可以理解为tornado一个真正干活的地方。</p>\n<p>我们知道，当你在浏览器中打来一个网站的时候，他会提交一个URL，表示“把这个地址的数据给我”，当然这中间涉及到DNS解析等各种中间环节才能到你服务器，此处略去。你这个url的数据可能是一个网页，如<a href=\"https://tornado/index.htm；可能是一张图片，如https://tornaado/tornado.png。这些数据传递给浏览器的时候，经过浏览器的渲染，就是你所看到的网站的东西。\">https://tornado/index.htm；可能是一张图片，如https://tornaado/tornado.png。这些数据传递给浏览器的时候，经过浏览器的渲染，就是你所看到的网站的东西。</a><br>对于每个url，应用服务可以设置一个handler来处理，如<a href=\"https://tornado/index.htm请求就交给handler_1_htm来处理；https://tornaado/tornado.png就交给handler_2_png来处理，这些handler函数的作用就是负责根据客户端的请求的内容通过http协议返回给客户端。**这就是tornado中的handler。**\">https://tornado/index.htm请求就交给handler_1_htm来处理；https://tornaado/tornado.png就交给handler_2_png来处理，这些handler函数的作用就是负责根据客户端的请求的内容通过http协议返回给客户端。**这就是tornado中的handler。**</a></p>\n<p>这些handler相对于静态网页而言，就很有优势了，可以动态展示，比如根据每个人的工号，从数据库中取出这个人的基本信息展示在浏览器，没个人看到的网页都是不一样的，就是说就成动态的了。其实torndao开发网站，绝大多数时候，其实都是在开发handler。</p>\n<p>至于URL如何和handler对应起来，这就是所谓的映射需要干的活，如hello中就是通过：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">application = tornado.web.Application([</div><div class=\"line\">        (<span class=\"string\">r\"/\"</span>, MainHandler),</div><div class=\"line\">    ])</div></pre></td></tr></table></figure></p>\n<p>这样每个请求url和handler组成一个tuple，如<strong>(r”/“, MainHandler)</strong>，就把handler与用户请求之间的映射关系建立起来了，显然Application的handlers是一个list，每个list中的元素是一个tuple，这样组成了handler和url的映射map。<br>上述中的tuple表示，当用户请求根目录的时候，就请MainHandler这个handler来处理了，你所在浏览器中看到的结果，就是MainHandler处理的结果了。</p>\n<p>当然，不是说每个浏览器地址栏中的url并不一定表示这个服务器上一定有这个文件，它可以是web服务器虚拟映射的一个路径。</p>\n<p>以上就是Handler的主要介绍，看看，其实handler还是蛮简单的嘛。雄关漫步真如铁，而今漫步从头越，加油，少年！<br>学Python，我们是认真的。</p>"},{"title":"鸟瞰Tornado框架","date":"2016-05-08T08:31:15.000Z","toc":true,"comments":1,"_content":"\n\n聊torndao源码前，先看看torndao框架的整体设计模型。在俯瞰Torndao的设计框架前，我们聊了web server的基本只是，handler的了解等，我们知道torndao是web framework，因为tornado把重复性的工作提炼出来，比如非常高效的Handler机制，比如鼎鼎大名的IOLoop，用起来非常方便，舒适，它把重复“造轮子”的工作给提炼出来了。torndao已经把一个http server的各个流程已经搭建好了，你只需呀按照你的需求去装修这个房子就成了，基础设施torndao会帮你干。\n\n<!-- more -->\n\n那么既然torndao是一个web framework，肯定是会遵循web server的三部曲，我们在前面文章的hello world中见到了lister，但是并没有看到最主要的appect、send、rev等常见的流程，为什么呢？\n如果你记忆力很好，你肯定记得hello world中有这么一句话：\n```python\ntornado.ioloop.IOLoop.instance().start()\n```\n原来tornado把accept、rev、send等都封装在IOLoop中，因为其实大伙写accept都大同小异，写一个死循环，不断的appect客户端的请求，用rev、send来处理。既然都大同小异，torndao就干脆把这些封装在IOLoop中了，你只要启动IOLOOP，那么他自动会帮你干这些事情，你只需要安心写你的Handler就行了。\n\n# torndao响应请求\n\n我们在浏览器中输入：http://127.0.0.1:8888，浏览器会连接到我们的服务器，把HTTP请求转发到HTTPServer中，HTTPServer会先parse request，然后把request交给第一个匹配的Handler。Handler负责组织数据，调用发送API把数据发给客户端，收工！\n\n\n# torndao解决C10K问题的模型：\n\n对于C10K问题，torndao采用的是多进程 + 非阻塞 + epoll模型来解决的，下面是torndao的网络模型相关的：\n\n![torndao的网络模型](聊聊tornado源码之鸟瞰tornado框架/tornado_001.gif)\n\n# Tornado框架设计模型\n\n![torndao的网络模型](聊聊tornado源码之鸟瞰tornado框架/tornado_002.png)\n\n# Tornado的HTTP服务器的工作流程\n\n![torndao的网络模型](聊聊tornado源码之鸟瞰tornado框架/tornado_003.png)\n\n由上图看到，服务器的工作流程：\n**首先按照socket->bind->listen顺序创建listen socket监听客户端，并将每个listen socket的fd注册到IOLoop的单例实例中；当listen socket可读时回调_handle_events处理客户端请求；在与客户端通信的过程中使用IOStream封装了读、写缓冲区，实现与客户端的异步读写。**\n","source":"_posts/聊聊tornado源码之鸟瞰tornado框架.md","raw":"---\ntitle: 鸟瞰Tornado框架\ndate: 2016-05-08 16:31:15\ntags: Tornado源码分析\ncategories: Tornado系列\ntoc: true\ncomments: true\n---\n\n\n聊torndao源码前，先看看torndao框架的整体设计模型。在俯瞰Torndao的设计框架前，我们聊了web server的基本只是，handler的了解等，我们知道torndao是web framework，因为tornado把重复性的工作提炼出来，比如非常高效的Handler机制，比如鼎鼎大名的IOLoop，用起来非常方便，舒适，它把重复“造轮子”的工作给提炼出来了。torndao已经把一个http server的各个流程已经搭建好了，你只需呀按照你的需求去装修这个房子就成了，基础设施torndao会帮你干。\n\n<!-- more -->\n\n那么既然torndao是一个web framework，肯定是会遵循web server的三部曲，我们在前面文章的hello world中见到了lister，但是并没有看到最主要的appect、send、rev等常见的流程，为什么呢？\n如果你记忆力很好，你肯定记得hello world中有这么一句话：\n```python\ntornado.ioloop.IOLoop.instance().start()\n```\n原来tornado把accept、rev、send等都封装在IOLoop中，因为其实大伙写accept都大同小异，写一个死循环，不断的appect客户端的请求，用rev、send来处理。既然都大同小异，torndao就干脆把这些封装在IOLoop中了，你只要启动IOLOOP，那么他自动会帮你干这些事情，你只需要安心写你的Handler就行了。\n\n# torndao响应请求\n\n我们在浏览器中输入：http://127.0.0.1:8888，浏览器会连接到我们的服务器，把HTTP请求转发到HTTPServer中，HTTPServer会先parse request，然后把request交给第一个匹配的Handler。Handler负责组织数据，调用发送API把数据发给客户端，收工！\n\n\n# torndao解决C10K问题的模型：\n\n对于C10K问题，torndao采用的是多进程 + 非阻塞 + epoll模型来解决的，下面是torndao的网络模型相关的：\n\n![torndao的网络模型](聊聊tornado源码之鸟瞰tornado框架/tornado_001.gif)\n\n# Tornado框架设计模型\n\n![torndao的网络模型](聊聊tornado源码之鸟瞰tornado框架/tornado_002.png)\n\n# Tornado的HTTP服务器的工作流程\n\n![torndao的网络模型](聊聊tornado源码之鸟瞰tornado框架/tornado_003.png)\n\n由上图看到，服务器的工作流程：\n**首先按照socket->bind->listen顺序创建listen socket监听客户端，并将每个listen socket的fd注册到IOLoop的单例实例中；当listen socket可读时回调_handle_events处理客户端请求；在与客户端通信的过程中使用IOStream封装了读、写缓冲区，实现与客户端的异步读写。**\n","slug":"聊聊tornado源码之鸟瞰tornado框架","published":1,"updated":"2016-09-29T15:49:03.000Z","layout":"post","photos":[],"link":"","_id":"citoirooc000mta02vdl5joaf","content":"<p>聊torndao源码前，先看看torndao框架的整体设计模型。在俯瞰Torndao的设计框架前，我们聊了web server的基本只是，handler的了解等，我们知道torndao是web framework，因为tornado把重复性的工作提炼出来，比如非常高效的Handler机制，比如鼎鼎大名的IOLoop，用起来非常方便，舒适，它把重复“造轮子”的工作给提炼出来了。torndao已经把一个http server的各个流程已经搭建好了，你只需呀按照你的需求去装修这个房子就成了，基础设施torndao会帮你干。</p>\n<a id=\"more\"></a>\n<p>那么既然torndao是一个web framework，肯定是会遵循web server的三部曲，我们在前面文章的hello world中见到了lister，但是并没有看到最主要的appect、send、rev等常见的流程，为什么呢？<br>如果你记忆力很好，你肯定记得hello world中有这么一句话：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>\n<p>原来tornado把accept、rev、send等都封装在IOLoop中，因为其实大伙写accept都大同小异，写一个死循环，不断的appect客户端的请求，用rev、send来处理。既然都大同小异，torndao就干脆把这些封装在IOLoop中了，你只要启动IOLOOP，那么他自动会帮你干这些事情，你只需要安心写你的Handler就行了。</p>\n<h1 id=\"torndao响应请求\"><a href=\"#torndao响应请求\" class=\"headerlink\" title=\"torndao响应请求\"></a>torndao响应请求</h1><p>我们在浏览器中输入：<a href=\"http://127.0.0.1:8888，浏览器会连接到我们的服务器，把HTTP请求转发到HTTPServer中，HTTPServer会先parse\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8888，浏览器会连接到我们的服务器，把HTTP请求转发到HTTPServer中，HTTPServer会先parse</a> request，然后把request交给第一个匹配的Handler。Handler负责组织数据，调用发送API把数据发给客户端，收工！</p>\n<h1 id=\"torndao解决C10K问题的模型：\"><a href=\"#torndao解决C10K问题的模型：\" class=\"headerlink\" title=\"torndao解决C10K问题的模型：\"></a>torndao解决C10K问题的模型：</h1><p>对于C10K问题，torndao采用的是多进程 + 非阻塞 + epoll模型来解决的，下面是torndao的网络模型相关的：</p>\n<p><img src=\"聊聊tornado源码之鸟瞰tornado框架/tornado_001.gif\" alt=\"torndao的网络模型\"></p>\n<h1 id=\"Tornado框架设计模型\"><a href=\"#Tornado框架设计模型\" class=\"headerlink\" title=\"Tornado框架设计模型\"></a>Tornado框架设计模型</h1><p><img src=\"聊聊tornado源码之鸟瞰tornado框架/tornado_002.png\" alt=\"torndao的网络模型\"></p>\n<h1 id=\"Tornado的HTTP服务器的工作流程\"><a href=\"#Tornado的HTTP服务器的工作流程\" class=\"headerlink\" title=\"Tornado的HTTP服务器的工作流程\"></a>Tornado的HTTP服务器的工作流程</h1><p><img src=\"聊聊tornado源码之鸟瞰tornado框架/tornado_003.png\" alt=\"torndao的网络模型\"></p>\n<p>由上图看到，服务器的工作流程：<br><strong>首先按照socket-&gt;bind-&gt;listen顺序创建listen socket监听客户端，并将每个listen socket的fd注册到IOLoop的单例实例中；当listen socket可读时回调_handle_events处理客户端请求；在与客户端通信的过程中使用IOStream封装了读、写缓冲区，实现与客户端的异步读写。</strong></p>\n","excerpt":"<p>聊torndao源码前，先看看torndao框架的整体设计模型。在俯瞰Torndao的设计框架前，我们聊了web server的基本只是，handler的了解等，我们知道torndao是web framework，因为tornado把重复性的工作提炼出来，比如非常高效的Handler机制，比如鼎鼎大名的IOLoop，用起来非常方便，舒适，它把重复“造轮子”的工作给提炼出来了。torndao已经把一个http server的各个流程已经搭建好了，你只需呀按照你的需求去装修这个房子就成了，基础设施torndao会帮你干。</p>","more":"<p>那么既然torndao是一个web framework，肯定是会遵循web server的三部曲，我们在前面文章的hello world中见到了lister，但是并没有看到最主要的appect、send、rev等常见的流程，为什么呢？<br>如果你记忆力很好，你肯定记得hello world中有这么一句话：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>\n<p>原来tornado把accept、rev、send等都封装在IOLoop中，因为其实大伙写accept都大同小异，写一个死循环，不断的appect客户端的请求，用rev、send来处理。既然都大同小异，torndao就干脆把这些封装在IOLoop中了，你只要启动IOLOOP，那么他自动会帮你干这些事情，你只需要安心写你的Handler就行了。</p>\n<h1 id=\"torndao响应请求\"><a href=\"#torndao响应请求\" class=\"headerlink\" title=\"torndao响应请求\"></a>torndao响应请求</h1><p>我们在浏览器中输入：<a href=\"http://127.0.0.1:8888，浏览器会连接到我们的服务器，把HTTP请求转发到HTTPServer中，HTTPServer会先parse\">http://127.0.0.1:8888，浏览器会连接到我们的服务器，把HTTP请求转发到HTTPServer中，HTTPServer会先parse</a> request，然后把request交给第一个匹配的Handler。Handler负责组织数据，调用发送API把数据发给客户端，收工！</p>\n<h1 id=\"torndao解决C10K问题的模型：\"><a href=\"#torndao解决C10K问题的模型：\" class=\"headerlink\" title=\"torndao解决C10K问题的模型：\"></a>torndao解决C10K问题的模型：</h1><p>对于C10K问题，torndao采用的是多进程 + 非阻塞 + epoll模型来解决的，下面是torndao的网络模型相关的：</p>\n<p><img src=\"聊聊tornado源码之鸟瞰tornado框架/tornado_001.gif\" alt=\"torndao的网络模型\"></p>\n<h1 id=\"Tornado框架设计模型\"><a href=\"#Tornado框架设计模型\" class=\"headerlink\" title=\"Tornado框架设计模型\"></a>Tornado框架设计模型</h1><p><img src=\"聊聊tornado源码之鸟瞰tornado框架/tornado_002.png\" alt=\"torndao的网络模型\"></p>\n<h1 id=\"Tornado的HTTP服务器的工作流程\"><a href=\"#Tornado的HTTP服务器的工作流程\" class=\"headerlink\" title=\"Tornado的HTTP服务器的工作流程\"></a>Tornado的HTTP服务器的工作流程</h1><p><img src=\"聊聊tornado源码之鸟瞰tornado框架/tornado_003.png\" alt=\"torndao的网络模型\"></p>\n<p>由上图看到，服务器的工作流程：<br><strong>首先按照socket-&gt;bind-&gt;listen顺序创建listen socket监听客户端，并将每个listen socket的fd注册到IOLoop的单例实例中；当listen socket可读时回调_handle_events处理客户端请求；在与客户端通信的过程中使用IOStream封装了读、写缓冲区，实现与客户端的异步读写。</strong></p>"}],"PostAsset":[{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_004.png","slug":"tornado_004.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_007.png","slug":"tornado_007.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_006.png","slug":"tornado_006.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_005.png","slug":"tornado_005.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/tornado-web源码分析/torndao_001.PNG","slug":"torndao_001.PNG","post":"citoiroo6000eta02solcpsz1","modified":0,"renderable":0},{"_id":"source/_posts/聊聊tornado源码之鸟瞰tornado框架/tornado_001.gif","slug":"tornado_001.gif","post":"citoirooc000mta02vdl5joaf","modified":0,"renderable":0},{"_id":"source/_posts/聊聊tornado源码之鸟瞰tornado框架/tornado_002.png","slug":"tornado_002.png","post":"citoirooc000mta02vdl5joaf","modified":0,"renderable":0},{"_id":"source/_posts/聊聊tornado源码之鸟瞰tornado框架/tornado_003.png","slug":"tornado_003.png","post":"citoirooc000mta02vdl5joaf","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/2013_10_14_03.gif","slug":"2013_10_14_03.gif","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_000.png","slug":"tornado_000.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_002.png","slug":"tornado_002.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_003.png","slug":"tornado_003.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0},{"_id":"source/_posts/Tornado之web服务器的网络知识了解/tornado_008.png","slug":"tornado_008.png","post":"citoirono0006ta02io7de0xx","modified":0,"renderable":0}],"PostCategory":[{"post_id":"citoiron40000ta02q7pi09gl","category_id":"citoironi0004ta02o9pnlg6a","_id":"citoiroo8000fta02eefocxu1"},{"post_id":"citoironc0002ta024uxmmttl","category_id":"citoironi0004ta02o9pnlg6a","_id":"citoiroob000lta020susnc59"},{"post_id":"citoiroob000jta02rw8hq7us","category_id":"citoiroo9000hta02xgypqwng","_id":"citoiroof000qta02f5howrgz"},{"post_id":"citoirono0006ta02io7de0xx","category_id":"citoiroo9000hta02xgypqwng","_id":"citoiroog000uta02qm1umrzq"},{"post_id":"citoirooc000mta02vdl5joaf","category_id":"citoiroo9000hta02xgypqwng","_id":"citoirooi000wta02eiitnleg"},{"post_id":"citoironw0008ta02fyqh96ev","category_id":"citoiroo9000hta02xgypqwng","_id":"citoirooj0010ta020nh9k1jh"},{"post_id":"citoiroo3000ata02jkit1y59","category_id":"citoiroo9000hta02xgypqwng","_id":"citoirooj0012ta020kufjp18"},{"post_id":"citoiroo6000eta02solcpsz1","category_id":"citoiroo9000hta02xgypqwng","_id":"citoiroom0016ta02d7gcirjw"},{"post_id":"citoiroo8000gta025wyum7u3","category_id":"citoiroo9000hta02xgypqwng","_id":"citoiroop0018ta02ko1vuyjv"}],"PostTag":[{"post_id":"citoiron40000ta02q7pi09gl","tag_id":"citoironn0005ta02typo6q5j","_id":"citoiroo6000dta02ortp3s12"},{"post_id":"citoironc0002ta024uxmmttl","tag_id":"citoiroo5000cta02su3mq692","_id":"citoiroob000kta027wzr7vn3"},{"post_id":"citoiroob000jta02rw8hq7us","tag_id":"citoirooa000ita02ure93oq6","_id":"citoirooe000pta026v8wyv2g"},{"post_id":"citoirono0006ta02io7de0xx","tag_id":"citoirooa000ita02ure93oq6","_id":"citoiroof000rta02mcrr4sih"},{"post_id":"citoirooc000mta02vdl5joaf","tag_id":"citoirooa000ita02ure93oq6","_id":"citoiroog000vta0204s2lek0"},{"post_id":"citoironw0008ta02fyqh96ev","tag_id":"citoirooa000ita02ure93oq6","_id":"citoirooi000xta02b4bzakzp"},{"post_id":"citoiroo3000ata02jkit1y59","tag_id":"citoirooa000ita02ure93oq6","_id":"citoirooj0011ta026s2dmmwx"},{"post_id":"citoiroo6000eta02solcpsz1","tag_id":"citoirooa000ita02ure93oq6","_id":"citoirool0015ta021ndzj4v4"},{"post_id":"citoiroo8000gta025wyum7u3","tag_id":"citoirooa000ita02ure93oq6","_id":"citoiroop0017ta0254i8e2rk"}],"Tag":[{"name":"Python基础","_id":"citoironn0005ta02typo6q5j"},{"name":"Python命令行解析","_id":"citoiroo5000cta02su3mq692"},{"name":"Tornado源码分析","_id":"citoirooa000ita02ure93oq6"}]}}